{"version":3,"sources":["webpack:///3.js","webpack:///./www/src/js/summernote.js","webpack:///./~/codemirror/lib/codemirror.js","webpack:///./~/summernote-webpack/dist/summernote.js","webpack:///(webpack)/buildin/amd-options.js"],"names":["webpackJsonp","137","module","__webpack_exports__","__webpack_require__","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","__WEBPACK_IMPORTED_MODULE_0_summernote_webpack__","SummerNote","n","this","$","summernote","height","144","exports","global","factory","classTest","cls","RegExp","removeChildren","e","count","childNodes","length","removeChild","firstChild","removeChildrenAndAdd","parent","appendChild","elt","tag","content","className","style","document","createElement","cssText","createTextNode","i","eltP","setAttribute","contains","child","nodeType","parentNode","host","activeElt","activeElement","body","shadowRoot","addClass","node","current","test","joinClasses","a","b","as","split","bind","f","args","Array","prototype","slice","call","arguments","apply","copyObj","obj","target","overwrite","prop","hasOwnProperty","countColumn","string","end","tabSize","startIndex","startValue","search","nextTab","indexOf","array","findColumn","goal","pos","col","skipped","Math","min","spaceStr","spaceStrs","push","lst","arr","map","out","insertSorted","score","priority","splice","nothing","createObj","base","props","inst","create","isWordCharBasic","ch","toUpperCase","toLowerCase","nonASCIISingleCaseWordChar","isWordChar","helper","source","isEmpty","isExtendingChar","charCodeAt","extendingChars","skipExtendingChars","str","dir","charAt","findFirst","pred","from","to","abs","mid","floor","Display","place","doc","input","d","scrollbarFiller","gutterFiller","lineDiv","selectionDiv","cursorDiv","measure","lineMeasure","lineSpace","lines","mover","sizer","sizerWidth","heightForcer","scrollerGap","gutters","lineGutter","scroller","wrapper","ie","ie_version","zIndex","paddingRight","webkit","gecko","mobile","draggable","viewFrom","viewTo","first","reportedViewFrom","reportedViewTo","view","renderedView","externalMeasured","viewOffset","lastWrapHeight","lastWrapWidth","updateLineNumbers","nativeBarWidth","barHeight","barWidth","scrollbarsClipped","lineNumWidth","lineNumInnerWidth","lineNumChars","alignWidgets","cachedCharWidth","cachedTextHeight","cachedPaddingH","maxLine","maxLineLength","maxLineChanged","wheelDX","wheelDY","wheelStartX","wheelStartY","shift","selForContextMenu","activeTouch","init","getLine","size","Error","chunk","children","sz","chunkSize","getBetween","start","line","iter","text","getLines","updateLineHeight","diff","lineNo","cur","no","lineAtHeight","h","outer","i$1","lh","isLine","l","lineNumberFor","options","String","lineNumberFormatter","firstLineNumber","Pos","sticky","cmp","equalCursorPos","copyPos","x","maxPos","minPos","clipLine","max","clipPos","last","clipToLen","linelen","clipPosArray","seeReadOnlySpans","sawReadOnlySpans","seeCollapsedSpans","sawCollapsedSpans","MarkedSpan","marker","getMarkedSpanFor","spans","span","removeMarkedSpan","r","addMarkedSpan","markedSpans","concat","attachLine","markedSpansBefore","old","startCh","isInsert","nw","startsBefore","inclusiveLeft","type","insertLeft","endsAfter","inclusiveRight","markedSpansAfter","endCh","stretchSpansOverChange","change","full","oldFirst","oldLast","sameLine","offset","found","span$1","found$1","clearEmptySpans","newMarkers","gapMarkers","gap","i$2","i$3","clearWhenEmpty","removeReadOnlyRanges","markers","mark","readOnly","parts","mk","m","find","j","p","newParts","dfrom","dto","detachMarkedSpans","detachLine","attachMarkedSpans","extraLeft","extraRight","compareCollapsedMarkers","lenDiff","aPos","bPos","fromCmp","toCmp","id","collapsedSpanAtSide","sps","sp","collapsed","collapsedSpanAtStart","collapsedSpanAtEnd","conflictingCollapsedRange","lineNo$$1","visualLine","merged","visualLineEnd","visualLineContinued","visualLineNo","lineN","vis","visualLineEndNo","lastLine","lineIsHidden","widgetNode","lineIsHiddenInner","heightAtLine","lineObj","lineLength","len","findMaxLine","cm","display","iterateBidiSections","order","part","level","getBidiPartAt","bidiOther","getOrder","direction","bidiOrdering","moveCharLogically","moveLogically","endOfLine","visually","moveInStorageOrder","prep","prepareMeasureForLine","targetTop","measureCharPrepared","top","moveVisually","bidi","partPos","mv","getWrappedLineExtent","lineWrapping","wrappedLineExtentChar","begin","wrappedLineExtent","searchInVisualLine","getRes","res","nextCh","getHandlers","emitter","_handlers","noHandlers","off","removeEventListener","detachEvent","map$$1","index","signal","handlers","signalDOMEvent","override","preventDefault","defaultPrevented","e_defaultPrevented","codemirrorIgnore","signalCursorActivity","cursorActivity","set","curOp","cursorActivityHandlers","hasHandler","eventMixin","ctor","on","e_preventDefault","returnValue","e_stopPropagation","stopPropagation","cancelBubble","e_stop","e_target","srcElement","e_button","which","button","mac","ctrlKey","zeroWidthElement","zwspSupported","offsetHeight","offsetWidth","hasBadBidiRects","badBidiRects","txt","r0","range","getBoundingClientRect","r1","left","right","hasBadZoomedRects","badZoomedRects","normal","fromRange","defineMode","name","mode","dependencies","modes","defineMIME","mime","spec","mimeModes","resolveMode","getMode","mfactory","modeObj","modeExtensions","exts","helperType","modeProps","prop$1","extendMode","properties","copyState","state","nstate","val","innerMode","info","startState","a1","a2","highlightLine","context","forceToEnd","st","modeGen","lineClasses","runMode","o","overlays","overlay","at","i_end","opaque","styles","classes","bgClass","textClass","getLineStyles","updateFrontier","getContextBefore","resetState","maxHighlightLength","result","stateAfter","save","styleClasses","highlightFrontier","modeFrontier","precise","Context","findStartLine","saved","fromSaved","processLine","nextLine","startAt","stream","StringStream","callBlankLine","eol","readToken","blankLine","inner","token","takeToken","asArray","tokens","Token","extractLineClasses","output","lineClass","match","flattenSpans","curStart","curStyle","addModeClass","mName","minindent","minline","lim","after","SavedContext","lookAhead","indented","retreatFrontier","updateLine","estimateHeight","estHeight","cleanUpLine","interpretTokenStyle","cache","styleToClassCacheWithMode","styleToClassCache","replace","buildLineContent","lineView","builder","pre","trailingSpace","splitSpaces","getOption","rest","addToken","buildToken","buildTokenBadBidi","insertLineContent","maps","caches","lastChild","querySelector","defaultSpecialCharPlaceholder","title","toString","startStyle","endStyle","css","displayText","special","specialChars","mustWrap","createDocumentFragment","lastIndex","exec","txt$1","tabWidth","specialCharPlaceholder","fullStyle","trailingBefore","spaceBefore","buildCollapsedSpan","ignoreWidget","widget","needsContentAttribute","setUneditable","allText","spanStyle","spanEndStyle","spanStartStyle","nextChange","Infinity","foundBookmarks","endStyles","j$1","j$2","upto","tokenText","LineView","hidden","buildViewArray","nextPos","pushOperation","op","operationGroup","ops","ownsGroup","delayedCallbacks","fireCallbacksForOps","group","callbacks","cursorActivityCalled","finishOperation","endCb","signalLater","list","orphanDelayedCallbacks","setTimeout","fireOrphanDelayed","delayed","updateLineForChanges","dims","changes","updateLineText","updateLineGutter","updateLineClasses","updateLineWidgets","ensureLineWrapped","replaceChild","updateLineBackground","background","wrap","insertBefore","getLineContent","ext","built","wrapClass","gutter","gutterBackground","gutterClass","fixedGutter","fixedPos","gutterTotalWidth","gutterMarkers","lineNumbers","wrap$1","gutterWrap","lineNumber","gutterLeft","k","gutterWidth","alignable","next","nextSibling","insertLineWidgets","buildLineElement","insertLineWidgetsFor","allowAbove","widgets","ws","handleMouseEvents","positionLineWidget","above","noHScroll","width","wrapperWidth","coverGutter","paddingLeft","position","marginLeft","widgetHeight","parentStyle","clientWidth","eventInWidget","getAttribute","paddingTop","offsetTop","paddingVert","paddingH","window","getComputedStyle","currentStyle","data","parseInt","isNaN","scrollGap","displayWidth","displayHeight","clientHeight","ensureLineHeights","rect","wrapping","curWidth","heights","rects","getClientRects","bottom","mapFromLineView","before","updateExternalMeasurement","measureChar","bias","findViewForLine","findViewIndex","getDimensions","forceUpdate","hasHeights","prepared","varHeight","key","measureCharInner","bogus","rtop","rbottom","nodeAndOffsetInLineMap","collapse","mStart","mEnd","coverStart","coverEnd","getUsefulRect","nullRect","maybeUpdateRectForZooming","rSpan","charWidth","rbot","bot","singleCursorHeightPerLine","screen","logicalXDPI","deviceXDPI","scaleX","scaleY","logicalYDPI","deviceYDPI","clearLineMeasurementCacheFor","clearLineMeasurementCache","externalMeasure","clearCaches","pageScrollX","chrome","android","pageXOffset","documentElement","scrollLeft","pageScrollY","marginTop","pageYOffset","scrollTop","intoCoordSystem","includeWidgets","yOff","lOff","xOff","fromCoordSystem","coords","localBox","lineSpaceBox","charCoords","cursorCoords","preparedMeasure","get","getBidi","invert","other","estimateCoords","PosWithInfo","outside","xRel","coordsChar","y","coordsCharInner","mergedPos","assign","prevDiff","prevPos","beginLeft","steps","ceil","prevPos$1","diff_change_per_step","box","textHeight","measureText","anchor","clientLeft","offsetLeft","compensateForHScroll","th","perLine","widgetsHeight","estimateLineHeights","est","posFromMouse","liberal","forRect","space","clientX","clientY","colDiff","round","updateSelection","showSelection","prepareSelection","primary","curFragment","cursors","selFragment","selection","sel","ranges","primIndex","range$$1","empty","showCursorWhenSelecting","drawSelectionCursor","head","drawSelectionRange","cursor","cursorHeight","otherCursor","add","fragment","rightSide","drawForLine","fromArg","toArg","lineLen","rightPos","leftPos","tmp","leftSide","padding","sFrom","sTo","fromLine","toLine","singleVLine","leftEnd","rightStart","restartBlink","focused","clearInterval","blinker","visibility","cursorBlinkRate","setInterval","ensureFocus","focus","onFocus","delayBlurEvent","delayingBlurEvent","onBlur","reset","receivedFocus","rmClass","updateHeightsInViewport","prevBottom","updateWidgetHeight","visibleLines","viewport","ensure","ensureFrom","ensureTo","alignHorizontally","comp","gutterW","align","maybeUpdateLineNumberWidth","innerW","updateGutterSpace","maybeScrollWindow","doScroll","innerHeight","phantom","scrollNode","scrollIntoView","scrollPosIntoView","margin","limit","changed","endCoords","scrollPos","calculateScrollPos","startTop","startLeft","updateScrollTop","setScrollLeft","snapMargin","screentop","docBottom","atTop","atBottom","newTop","screenleft","screenw","tooWide","addToScrollTop","resolveScrollToPos","ensureCursorVisible","getCursor","scrollToPos","cursorScrollMargin","scrollToCoords","scrollToRange","scrollToCoordsRange","sPos","updateDisplaySimple","setScrollTop","startWorker","forceScroll","scrollHeight","scrollbars","isScroller","scrollWidth","measureForScrollbars","docH","viewHeight","viewWidth","barLeft","docHeight","updateScrollbars","startWidth","startHeight","updateScrollbarsInner","sizes","update","paddingBottom","borderBottom","coverGutterNextToScrollbar","initScrollbars","clear","scrollbarModel","scrollbarStyle","axis","startOperation","viewChanged","updateInput","typing","changeObjs","selectionChanged","updateMaxLine","nextOpId","endOperation","endOperations","endOperation_R1","endOperation_W1","endOperation_R2","endOperation_W2","i$4","endOperation_finish","maybeClipScrollbars","mustUpdate","DisplayUpdate","updatedDisplay","updateDisplayIfNeeded","barMeasure","adjustWidthTo","maxScrollLeft","preparedSelection","minWidth","takeFocus","hasFocus","setDocumentHeight","postUpdateDisplay","maybeHiddenMarkers","unhidden","maybeUnhiddenMarkers","finish","runInOp","operation","methodOp","docMethodOp","regChange","lendiff","resetView","cut","viewCuttingPoint","cut$1","cutTop","cutBot","regLineChange","oldN","newN","adjustView","countDirtyView","dirty","time","highlight","highlightWorker","Date","workTime","changedLines","oldStyles","highlighted","oldCls","newCls","ischange","workDelay","marginBottom","borderRightWidth","selectionSnapshot","active","getSelection","anchorNode","extend","anchorOffset","focusNode","focusOffset","restoreSelection","snapshot","createRange","setEnd","removeAllRanges","addRange","editorIsHidden","force","visible","viewportMargin","different","wrapperHeight","toUpdate","selSnapshot","patchDisplay","minHeight","oldDisplayWidth","updateNumbersFrom","rm","currentWheelTarget","container","updateNumber","updateGutters","specs","gElt","setGuttersForLineNumbers","wheelEventDelta","dx","wheelDeltaX","dy","wheelDeltaY","detail","HORIZONTAL_AXIS","VERTICAL_AXIS","wheelDelta","wheelEventPixels","delta","wheelPixelsPerUnit","onScrollWheel","scroll","canScrollX","canScrollY","presto","pixels","wheelSamples","movedX","movedY","sample","normalizeSelection","prim","sort","prev","inv","Range","Selection","simpleSelection","changeEnd","adjustForChange","computeSelAfterChange","offsetPos","computeReplacedSel","hint","oldPrev","newPrev","loadMode","modeOption","resetModeState","isWholeLineUpdate","wholeLineUpdateBefore","updateDoc","estimateHeight$$1","spansFor","linesFor","Line","firstLine","lastText","lastSpans","nlines","insert","remove","added","added$1","added$2","linkedDocs","sharedHistOnly","propagate","skip","sharedHist","linked","rel","shared","attachDoc","setDirectionClass","directionChanged","History","startGen","done","undone","undoDepth","lastModTime","lastSelTime","lastOp","lastSelOp","lastOrigin","lastSelOrigin","generation","maxGeneration","historyChangeFromChange","histChange","attachLocalSpans","clearSelectionEvents","pop","lastChangeEvent","hist","addChangeToHistory","selAfter","opId","history","origin","historyEventDelay","pushSelectionToHistory","selectionEventCanBeMerged","somethingSelected","addSelectionToHistory","clearRedo","dest","equals","existing","removeClearedSpans","explicitlyCleared","getOldSpans","mergeOldSpans","stretched","oldCur","stretchCur","copyHistoryArray","events","newGroup","instantiateSel","copy","event","deepCopy","newChanges","Number","extendRange","posBefore","extendSelection","setSelection","extendSelections","heads","replaceOneSelection","setSimpleSelection","filterSelectionChange","this$1","setSelectionReplaceHistory","setSelectionNoUndo","NaN","setSelectionInner","skipAtomicInSelection","reCheckSelection","mayClear","newAnchor","skipAtomic","newHead","skipAtomicInner","oldPos","atomic","near","movePos","far","cantEdit","selectAll","sel_dontScroll","filterChange","canceled","cancel","undefined","makeChange","ignoreReadOnly","suppressEdits","makeChangeInner","makeChangeSingleDoc","rebased","rebaseHist","makeChangeFromHistory","allowSelectionOnly","antiChanges","filter","returned","v","shiftDoc","distance","removed","makeChangeSingleDocInEditor","recomputeMaxLength","checkWidthStart","changesHandler","changeHandler","replaceRange","code","splitLines","rebaseHistSelSingle","rebaseHistArray","sub","ok","copied","changeLine","handle","changeType","LeafChunk","BranchChunk","adjustScrollWhenAboveVisible","addLineWidget","LineWidget","insertAt","aboveVisible","markText","markTextShared","TextMarker","replacedWith","addToHistory","curLine","clearOnEnter","clearHistory","nextMarkerId","cloneNode","isParent","SharedTextMarker","findSharedMarkers","findMarks","copySharedMarkers","mFrom","mTo","subMark","detachSharedMarkers","subMarker","onDrop","clearDragCursor","lastDrop","files","dataTransfer","isReadOnly","FileReader","File","read","file","allowDropFileTypes","reader","onload","join","lineSeparator","readAsText","draggingText","text$1","getData","selected","listSelections","replaceSelection","onDragStart","setData","effectAllowed","setDragImage","safari","img","src","_top","onDragOver","frag","dragCursor","forEachCodeMirror","getElementsByClassName","byClass","CodeMirror","ensureGlobalHandlers","globalsRegistered","registerGlobalHandlers","resizeTimer","onResize","setSize","normalizeKeyName","alt","ctrl","cmd","mod","normalizeKeyMap","keymap","keyname","keys","lookupKey","getKeyMap","fallthrough","isModifierKey","keyNames","keyCode","addModifierNames","noShift","altKey","flipCtrlCmd","metaKey","shiftKey","keyName","altGraphKey","keyMap","deleteNearSelection","compute","kill","toKill","replaced","lineStart","visual","lineEnd","lineStartSmart","firstNonWS","inWS","doHandleBinding","bound","dropShift","commands","ensurePolled","prevShift","Pass","lookupKeyForEditor","keyMaps","extraKeys","dispatchKey","seq","keySeq","stopSeq","handleKeyBinding","motion","handleCharBinding","onKeyDown","handled","lastStoppedKey","hasCopyEvent","showCrossHair","up","onKeyUp","onKeyPress","charCode","fromCharCode","clickRepeat","now","lastDoubleClick","compare","lastClick","PastClick","onMouseDown","supportsTouch","clickInGutter","repeat","selectingText","handleMappedButton","leftButtonDown","captureRightClick","onContextMenu","configureMouse","option","unit","chromeOS","addNew","moveOnDrag","contained","behavior","dragDrop","dragAndDrop","leftButtonStartDrag","leftButtonSelect","moved","dragEnd","mouseMove","dragStart","e2","rangeForUnit","findWordAt","extendTo","lastPos","startCol","posCol","startSel","ourIndex","oldRange","ourRange","ranges$1","sel_mouse","curCount","counter","editorSize","move","gutterEvent","prevent","mX","mY","lineBox","g","contextMenuInGutter","themeChanged","theme","guttersChanged","dragDropChanged","Init","funcs","dragFunctions","toggle","enter","over","leave","drop","wrappingChanged","CodeMirror$1","defaults","Doc","inputStyles","inputStyle","pasteIncoming","cutIncoming","Delayed","autofocus","registerEventHandlers","opt","optionHandlers","finishInit","initHooks","textRendering","finishTouch","touchFinished","prevTouch","isMouseLikeTouchEvent","touches","touch","radiusX","radiusY","farAway","word","clearTimeout","pageX","pageY","inp","getField","indentLine","how","aggressive","indent","curSpace","indentation","curSpaceString","indentUnit","indentString","indentWithTabs","pos$1","setLastCopied","newLastCopied","lastCopied","applyTextInput","inserted","deleted","paste","textLines","splitLinesAuto","multiPaste","pasteLinesPerSelection","lineWise","changeEvent","triggerElectric","handlePaste","pasted","clipboardData","disableInput","electricChars","smartIndent","getModeAt","electricInput","copyableRanges","lineRange","getRange","disableBrowserMagic","field","spellcheck","hiddenTextarea","te","div","ios","border","findPosH","findNextLine","moveOnce","boundToLine","origDir","sawType","getHelper","hitSide","findPosV","pageSize","moveAmount","posToDOM","side","isInGutter","scan","badPos","bad","domTextBetween","recognizeMarker","close","closing","lineSep","addText","walk","cmText","textContent","markerID","isBlock","nodeName","nodeValue","domToPos","lineNode","locateNodeInLineView","textNode","topNode","curNode","dist","previousSibling","dist$1","fromTextArea","textarea","getValue","tabindex","tabIndex","placeholder","realSubmit","form","leaveSubmitMethodAlone","submit","wrappedSubmit","getTextArea","toTextArea","getWrapperElement","userAgent","navigator","platform","ie_upto10","ie_11up","edge","documentMode","qtwebkit","vendor","mac_geMountainLion","windows","presto_version","endNode","setStart","createTextRange","moveToElementText","moveEnd","moveStart","selectInput","select","selectionStart","selectionEnd","_e","ms","sel_move","charType","lowTypes","arabicTypes","BidiSpan","bidiRE","isNeutral","isStrong","countsAsLeft","countsAsNum","outerType","types","type$1","prev$1","type$2","type$3","i$5","cur$1","type$4","i$6","end$1","replace$1","i$7","nstart","unshift","reverse","addEventListener","attachEvent","nl","rt","hasSelection","ownerDocument","parentElement","compareEndPoints","oncopy","lineOracle","lastColumnPos","lastColumnValue","sol","peek","eat","eatWhile","eatSpace","skipToEnd","skipTo","backUp","column","pattern","consume","caseInsensitive","cased","substr","hideFirstChars","oracle","maxLookAhead","NativeScrollbars","vert","horiz","checkedZeroWidth","needsH","needsV","sWidth","totalHeight","totalWidth","zeroWidthHack","disableHoriz","enableZeroWidthBar","disableVert","w","pointerEvents","bar","delay","maybeDisable","elementFromPoint","NullScrollbars","native","null","here","there","removeInner","insertInner","iterN","oldHeight","remaining","leaf","maybeSpill","me","spilled","sibling","myIndex","used","oldH","withOp","dHeight","nextDocId","cleanGeneration","constructor","setValue","getLineHandle","getLineNumber","getLineHandleVisualStart","lineCount","setCursor","extendSelectionsBy","setSelections","addSelection","getSelections","dup","replaceSelections","newSel","undo","redo","undoSelection","redoSelection","setExtending","getExtending","historySize","markClean","changeGeneration","forceSplit","isClean","gen","getHistory","setHistory","histData","setGutterMarker","gutterID","clearGutter","lineInfo","addLineClass","where","removeLineClass","removeLineWidget","setBookmark","realOpts","findMarksAt","getAllMarks","posFromIndex","sepSize","indexFromPos","copyHistory","linkedDoc","unlinkDoc","link","splitIds","iterLinkedDocs","getEditor","setDirection","eachLine","3","8","9","13","16","17","18","19","20","27","32","33","34","35","36","37","38","39","40","44","45","46","59","61","91","92","93","106","107","109","110","111","127","173","186","187","188","189","190","191","192","219","220","221","222","63232","63233","63234","63235","63272","63273","63275","63276","63277","63302","basic","Left","Right","Up","Down","End","Home","PageUp","PageDown","Delete","Backspace","Shift-Backspace","Tab","Shift-Tab","Enter","Insert","Esc","pcDefault","Ctrl-A","Ctrl-D","Ctrl-Z","Shift-Ctrl-Z","Ctrl-Y","Ctrl-Home","Ctrl-End","Ctrl-Up","Ctrl-Down","Ctrl-Left","Ctrl-Right","Alt-Left","Alt-Right","Ctrl-Backspace","Ctrl-Delete","Ctrl-S","Ctrl-F","Ctrl-G","Shift-Ctrl-G","Shift-Ctrl-F","Shift-Ctrl-R","Ctrl-[","Ctrl-]","Ctrl-U","Shift-Ctrl-U","Alt-U","emacsy","Ctrl-B","Ctrl-P","Ctrl-N","Alt-F","Alt-B","Ctrl-E","Ctrl-V","Shift-Ctrl-V","Ctrl-H","Alt-D","Alt-Backspace","Ctrl-K","Ctrl-T","Ctrl-O","macDefault","Cmd-A","Cmd-D","Cmd-Z","Shift-Cmd-Z","Cmd-Y","Cmd-Home","Cmd-Up","Cmd-End","Cmd-Down","Cmd-Left","Cmd-Right","Ctrl-Alt-Backspace","Alt-Delete","Cmd-S","Cmd-F","Cmd-G","Shift-Cmd-G","Cmd-Alt-F","Shift-Cmd-Alt-F","Cmd-[","Cmd-]","Cmd-Backspace","Cmd-Delete","Cmd-U","Shift-Cmd-U","singleSelection","killLine","deleteLine","delLineLeft","delWrappedLineLeft","delWrappedLineRight","goDocStart","goDocEnd","goLineStart","goLineStartSmart","goLineEnd","goLineRight","goLineLeft","goLineLeftSmart","goLineUp","moveV","goLineDown","goPageUp","goPageDown","goCharLeft","moveH","goCharRight","goColumnLeft","goColumnRight","goWordLeft","goGroupRight","goGroupLeft","goWordRight","delCharBefore","deleteH","delCharAfter","delWordBefore","delWordAfter","delGroupBefore","delGroupAfter","indentAuto","indentSelection","indentMore","indentLess","insertTab","insertSoftTab","spaces","defaultTab","execCommand","transposeChars","newlineAndIndent","sels","openLine","toggleOverwrite","defineInitHook","ContentEditableInput","lastAnchorNode","lastAnchorOffset","lastFocusNode","lastFocusOffset","polling","composing","gracePeriod","readDOMTimeout","onCopyCut","lineWiseCopyCut","clearData","kludge","hadFocus","showPrimarySelection","updateFromDOM","readFromDOMSoon","forceCompositionEnd","showMultipleSelections","curAnchor","curFocus","rng","rangeCount","getRangeAt","startGracePeriod","rememberSelection","selectionInEditor","commonAncestorContainer","blur","poll","pollSelection","pollInterval","triggerOnKeyDown","pollContent","fromIndex","fromNode","toNode","toIndex","newText","oldText","cutFront","cutEnd","oldTop","maxCutFront","newBot","oldBot","maxCutEnd","chFrom","chTo","contentEditable","readOnlyChanged","resetPosition","TextareaInput","prevInput","pollingFast","prepareCopyCut","fastPoll","moveInputWithCursor","headPos","wrapOff","lineOff","teTop","teLeft","drawn","contextMenuPending","slowPoll","missed","same","prepareSelectAllHack","extval","rehide","oldWrapperCSS","oldCSS","detectingSelectAll","resetSelectionOnContextMenu","wrapperBox","oldScrollY","scrollY","scrollTo","mouseup","disabled","deflt","notOnInit","defineOption","newBreaks","refresh","getInputField","detach","attach","integer","helpers","setOption","getDoc","addKeyMap","removeKeyMap","addOverlay","modeSpec","removeOverlay","newRanges","getTokenAt","getLineTokens","getTokenTypeAt","getHelpers","help","_global","getStateAfter","defaultTextHeight","defaultCharWidth","getViewport","addWidget","vspace","hspace","triggerOnKeyPress","triggerOnKeyUp","triggerOnMouseDown","amount","rtlMoveVisually","goalColumn","goals","startChar","check","getScrollInfo","interpret","swapDoc","getScrollerElement","getGutterElement","registerHelper","registerGlobalHelper","predicate","dontDelegate","method","contenteditable","defineExtension","func","defineDocExtension","cmpPos","version","179","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","browserVersion","eq","itemA","itemB","eq2","peq2","propName","fail","not","and","fA","fB","item","idCounter","self","invoke","uniqueId","prefix","rect2bnd","$document","invertObject","inverted","namespaceToCamel","namespace","substring","initial","tail","idx","all","inArray","sum","fn","reduce","memo","collection","clusterBy","aLast","compact","aResult","unique","results","isSupportAmd","isFontInstalled","fontName","testFontName","$tester","fontSize","appendTo","originalWidth","isMSIE","matches","parseFloat","isEdge","hasCodeMirror","agent","isMac","appVersion","isFF","isPhantom","isWebkit","isChrome","isSafari","jqueryVersion","jquery","isW3CRangeSupport","NBSP_CHAR","dom","isEditable","hasClass","isControlSizing","makePredByNodeName","isText","isElement","isVoid","isPara","isHeading","isPre","isLi","isPurePara","isTable","isInline","isBodyContainer","isList","isHr","isBlockquote","isCell","isAnchor","isParaInline","ancestor","isBodyInline","isBody","isClosestSibling","nodeA","nodeB","withClosestSiblings","siblings","blankHTML","nodeLength","innerHTML","paddingBlankHTML","singleChildAncestor","listAncestor","ancestors","el","lastAncestor","commonAncestor","listPrev","nodes","listNext","listDescendant","descendants","fnWalk","wrapperName","insertAfter","preceding","appendChildNodes","aChild","each","isLeftEdgePoint","point","isRightEdgePoint","isEdgePoint","isLeftEdgeOf","isRightEdgeOf","isLeftEdgePointOf","isRightEdgePointOf","hasChildren","prevPoint","isSkipInnerOffset","nextPoint","isSamePoint","pointA","pointB","isVisiblePoint","leftNode","rightNode","prevPointUntil","nextPointUntil","isCharPoint","walkPoint","startPoint","endPoint","handler","isSkipOffset","makeOffsetPath","fromOffsetPath","offsets","splitNode","isSkipPaddingBlankHTML","isNotSplitEdgePoint","splitText","childNode","clone","splitTree","root","splitPoint","splitRoot","topAncestor","pivot","createText","isRemoveChild","removeNode","removeWhile","newNode","isTextarea","$node","stripLinebreaks","html","isNewlineOnBlock","markup","regexTag","endSlash","isEndOfInlineContainer","isBlockNode","trim","posFromPlaceholder","$placeholder","outerHeight","attachEvents","forEach","detachEvents","ZERO_WIDTH_NBSP_CHAR","blank","emptyPara","isDiv","isBR","isSpan","isB","isU","isS","isI","isImg","isEmptyAnchor","$note","ui","memos","modules","layoutInfo","initialize","createLayout","_initialize","hide","destroy","_destroy","removeData","removeLayout","isDisabled","disable","buttons","plugins","initializeModule","removeModule","removeMemo","isActivated","codable","editable","triggerEvent","attr","enable","callback","trigger","shouldInitialize","ModuleClass","withoutIntialize","createInvokeHandler","closest","splits","hasSeparator","moduleName","methodName","isExternalAPICalled","hasInitOptions","langInfo","lang","note","Renderer","render","$parent","contents","click","$container","append","renderer","isArray","editor","toolbar","editingArea","statusbar","airEditor","airEditable","buttonGroup","tooltip","placement","dropdown","items","template","dropdownCheck","icon","checkClassName","palette","row","rowSize","colors","eventName","colSize","color","dialog","fade","footer","popover","hideArrow","iconClassName","tagName","toggleBtn","$btn","isEnable","toggleClass","toggleBtnActive","isActive","onDialogShown","$dialog","one","onDialogHidden","showDialog","modal","hideDialog","$editor","airMode","show","en-US","font","bold","italic","underline","strikethrough","subscript","superscript","image","resizeFull","resizeHalf","resizeQuarter","floatLeft","floatRight","floatNone","shapeRounded","shapeCircle","shapeThumbnail","shapeNone","dragImageHere","dropImage","selectFromFiles","maximumFileSize","maximumFileSizeError","url","video","videoLink","providers","unlink","edit","textToDisplay","openInNewWindow","table","hr","blockquote","h1","h2","h3","h4","h5","h6","lists","unordered","ordered","fullscreen","codeview","paragraph","outdent","center","justify","recent","more","foreground","transparent","setTransparent","resetToDefault","shortcut","shortcuts","textFormatting","action","paragraphFormatting","documentStyle","insertParagraph","tab","untab","removeFormat","justifyLeft","justifyCenter","justifyRight","justifyFull","insertUnorderedList","insertOrderedList","formatPara","formatH1","formatH2","formatH3","formatH4","formatH5","formatH6","insertHorizontalRule","linkDialog.show","specialChar","BACKSPACE","TAB","ENTER","SPACE","LEFT","UP","RIGHT","DOWN","NUM0","NUM1","NUM2","NUM3","NUM4","NUM5","NUM6","NUM7","NUM8","B","E","I","J","K","L","R","S","U","V","Y","Z","SLASH","LEFTBRACKET","BACKSLASH","RIGHTBRACKET","isEdit","isMove","nameFromCode","textRangeToPoint","textRange","isStart","prevContainer","tester","textRangeStart","curTextNode","pointTester","duplicate","setEndPoint","textCount","cont","pointToTextRange","textRangeInfo","isCollapseToStart","prevTextNodes","collapseToStart","WrappedRange","sc","so","ec","eo","nativeRange","w3cRange","getPoints","getStartPoint","getEndPoint","nativeRng","normalize","getVisiblePoint","isLeftToRight","block","isCollapsed","includeAncestor","fullyContains","leftEdgeNodes","expand","startAncestor","endAncestor","boundaryPoints","isSameContainer","deleteContents","emptyParents","makeIsOn","isOnEditable","isOnList","isOnAnchor","isOnCell","wrapBodyInlineWithPara","inlineSiblings","para","insertNode","pasteHTML","contentsContainer","getWordRange","findAfter","bookmark","s","path","paraBookmark","paras","wrappedRange","createFromSelection","createFromNode","startContainer","startOffset","endContainer","endOffset","textRangeEnd","isTextNode","createFromNodeBefore","createFromNodeAfter","createFromBookmark","createFromParaBookmark","async","readFileAsDataURL","Deferred","deferred","dataURL","resolve","onerror","reject","readAsDataURL","promise","createImage","$img","$editable","stack","stackOffset","makeSnapshot","emptyBookmark","applySnapshot","rewind","recordUndo","Style","jQueryCSS","$obj","propertyNames","propertyName","styleInfo","stylePara","styleNodes","expandClosestSibling","onlyPartialContains","nodesInRange","tails","elem","$cont","font-bold","queryCommandState","font-italic","font-underline","font-subscript","font-superscript","font-strikethrough","orderedTypes","isUnordered","lineHeight","toFixed","Bullet","toggleList","clustereds","wrapList","releaseList","listName","wrappedParas","diffLists","listNode","prevList","nextList","isEscapseToBody","releasedParas","headList","lastList","middleList","rootLists","rootList","listNodes","Typing","bullet","tabsize","nextPara","emptyAnchors","Table","isShift","cell","cells","nextCell","createTable","colCount","rowCount","tdHTML","tds","idxCol","trHTML","trs","idxRow","$table","tableClassName","Editor","lastRange","isDefaultPrevented","handleKeyMap","changeEventName","setHeight","maxHeight","afterCommand","saveRange","thenCollapse","restoreRange","saveTarget","clearTarget","restoreTarget","styleFromNode","beforeCommand","isPreventTrigger","sCmd","wrapCommand","insertImage","param","then","$image","insertImages","filename","maximumImageFileSize","insertImagesOrCallback","onImageUpload","insertText","getSelectedText","formatBlock","firstSpan","font-size","hrNode","removeBogus","bogusNode","bogusCharIdx","deleteData","createLink","linkInfo","linkUrl","linkText","isNewWindow","isTextChanged","onCreateLink","anchors","removeAttr","startRange","endRange","getLinkInfo","$anchor","colorInfo","foreColor","backColor","insertTable","dim","dimension","floatMe","resize","resizeTo","$target","bKeepRatio","imageSize","newRatio","ratio","removeMedia","is","Clipboard","summernote.keydown","we","needKeydownHook","$paste","pasteByHook","opacity","pasteByEvent","dataURI","decodedData","atob","Uint8Array","blob","Blob","pasteContent","originalEvent","kind","getAsFile","Dropzone","$dropzone","prependTo","disableDragAndDrop","attachDragAndDropEvent","$dropzoneMessage","isCodeview","hasEditorSize","removeClass","Promise","__WEBPACK_AMD_REQUIRE_ARRAY__","catch","oe","Codeview","$codable","sync","deactivate","activate","prettifyHtml","cmEditor","codemirror","tern","server","TernServer","ternServer","updateArgHints","isChange","Statusbar","$statusbar","disableResizeEditor","editableTop","minheight","Fullscreen","$toolbar","$window","$scrollbar","setsize","isFullscreen","Handle","$editingArea","summernote.mousedown","summernote.keyup summernote.scroll summernote.change summernote.dialog.shown","$handle","disableResizeImage","posStart","isImage","$selection","outerWidth","sizingText","AutoLink","linkPattern","summernote.keyup","handleKeyup","handleKeydown","lastWordRange","keyword","wordRange","AutoSync","summernote.change","Placeholder","summernote.init summernote.change","summernote.codeview.toggled","isShow","Buttons","invertedKeyMap","representShortcut","editorMethod","addToolbarButtons","addImagePopoverButtons","addLinkPopoverButtons","fontInstalledMap","fontNamesIgnoreCheck","icons","magic","caret","styleTags","eraser","menuCheck","fontNames","fontSizes","$button","currentTarget","$dropdown","$holder","$color","$currentButton","unorderedlist","orderedlist","alignLeft","alignCenter","alignRight","alignJustify","lineHeights","insertTableMaxSize","mousedown","tableMoveHandler","picture","minus","arrowsAlt","question","trash","build","groups","groupIdx","groupLen","groupName","$group","updateCurrentStyle","updateBtnStates",".note-btn-bold",".note-btn-italic",".note-btn-underline",".note-btn-subscript",".note-btn-superscript",".note-btn-strikethrough","isChecked","infos","selector","posOffset","$picker","$dimensionDisplay","$catcher","$highlighted","$unhighlighted","offsetX","posCatcher","offsetY","c","Toolbar","toolbarContainer","updateFullscreen","updateCodeview","isIncludeCodeview","LinkDialog","dialogsInBody","disableLinkTarget","dialogsFade","bindEnterKey","$input","showLinkDialog","$linkText","$linkUrl","$linkBtn","$openInNewWindow","LinkPopover","summernote.keyup summernote.mouseup summernote.change summernote.scroll","summernote.dialog.shown","$popover","prepend","$content","href","ImageDialog","imageLimitation","log","readableSize","pow","showImageDialog","$imageInput","$imageUrl","$imageBtn","replaceWith","ImagePopover","VideoDialog","createVideoNode","$video","ytRegExp","ytMatch","igRegExp","igMatch","vRegExp","vMatch","vimRegExp","vimMatch","dmRegExp","dmMatch","youkuRegExp","youkuMatch","mp4RegExp","mp4Match","oggRegExp","oggMatch","webmRegExp","webmMatch","youtubeId","showVideoDialog","$videoUrl","$videoBtn","HelpDialog","createShortCutList","command","$row","margin-right","max-height","overflow","showHelpDialog","AirPopover","summernote.keyup summernote.mouseup summernote.scroll","summernote.change summernote.dialog.shown","summernote.focusout","relatedTarget","air","bnd","HintPopover","hintDirection","hints","selectItem","$item","moveDown","$current","$next","$nextGroup","moveUp","$prev","$prevGroup","nodeFromItem","createItemTemplates","hintIdx","searchKeyword","createGroup","clipboard","dropzone","hintPopover","autoLink","autoSync","linkDialog","linkPopover","imageDialog","imagePopover","videoDialog","helpDialog","airPopover","styleWithSpan","textareaAutoSync","onInit","onEnter","onKeyup","onKeydown","onSubmit","onImageUploadError","htmlMode","pc","CTRL+Z","CTRL+Y","SHIFT+TAB","CTRL+B","CTRL+I","CTRL+U","CTRL+SHIFT+S","CTRL+BACKSLASH","CTRL+SHIFT+L","CTRL+SHIFT+E","CTRL+SHIFT+R","CTRL+SHIFT+J","CTRL+SHIFT+NUM7","CTRL+SHIFT+NUM8","CTRL+LEFTBRACKET","CTRL+RIGHTBRACKET","CTRL+NUM0","CTRL+NUM1","CTRL+NUM2","CTRL+NUM3","CTRL+NUM4","CTRL+NUM5","CTRL+NUM6","CTRL+ENTER","CTRL+K","CMD+Z","CMD+SHIFT+Z","CMD+B","CMD+I","CMD+U","CMD+SHIFT+S","CMD+BACKSLASH","CMD+SHIFT+L","CMD+SHIFT+E","CMD+SHIFT+R","CMD+SHIFT+J","CMD+SHIFT+NUM7","CMD+SHIFT+NUM8","CMD+LEFTBRACKET","CMD+RIGHTBRACKET","CMD+NUM0","CMD+NUM1","CMD+NUM2","CMD+NUM3","CMD+NUM4","CMD+NUM5","CMD+NUM6","CMD+ENTER","CMD+K","circle","frame","pencil","square","180","__webpack_amd_options__"],"mappings":"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","file":"3.js","sourcesContent":["webpackJsonp([3],{\n\n/***/ 137:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_summernote_webpack__ = __webpack_require__(179);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_summernote_webpack___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_summernote_webpack__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\nvar SummerNote = function SummerNote() {\n    _classCallCheck(this, SummerNote);\n\n    $('.summernote').summernote({\n        height: 400\n    });\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SummerNote);\n\n/***/ }),\n\n/***/ 144:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// This is CodeMirror (http://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.CodeMirror = factory());\n}(this, (function () { 'use strict';\n\n// Kludges for bugs and behavior differences that can't be feature\n// detected are enabled based on userAgent etc sniffing.\nvar userAgent = navigator.userAgent;\nvar platform = navigator.platform;\n\nvar gecko = /gecko\\/\\d/i.test(userAgent);\nvar ie_upto10 = /MSIE \\d/.test(userAgent);\nvar ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\nvar edge = /Edge\\/(\\d+)/.exec(userAgent);\nvar ie = ie_upto10 || ie_11up || edge;\nvar ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\nvar webkit = !edge && /WebKit\\//.test(userAgent);\nvar qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\nvar chrome = !edge && /Chrome\\//.test(userAgent);\nvar presto = /Opera\\//.test(userAgent);\nvar safari = /Apple Computer/.test(navigator.vendor);\nvar mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\nvar phantom = /PhantomJS/.test(userAgent);\n\nvar ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\nvar android = /Android/.test(userAgent);\n// This is woefully incomplete. Suggestions for alternative methods welcome.\nvar mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\nvar mac = ios || /Mac/.test(platform);\nvar chromeOS = /\\bCrOS\\b/.test(userAgent);\nvar windows = /win/i.test(platform);\n\nvar presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\nif (presto_version) { presto_version = Number(presto_version[1]); }\nif (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n// Some browsers use the wrong event properties to signal cmd/ctrl on OS X\nvar flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\nvar captureRightClick = gecko || (ie && ie_version >= 9);\n\nfunction classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\n\nvar rmClass = function(node, cls) {\n  var current = node.className;\n  var match = classTest(cls).exec(current);\n  if (match) {\n    var after = current.slice(match.index + match[0].length);\n    node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n  }\n};\n\nfunction removeChildren(e) {\n  for (var count = e.childNodes.length; count > 0; --count)\n    { e.removeChild(e.firstChild); }\n  return e\n}\n\nfunction removeChildrenAndAdd(parent, e) {\n  return removeChildren(parent).appendChild(e)\n}\n\nfunction elt(tag, content, className, style) {\n  var e = document.createElement(tag);\n  if (className) { e.className = className; }\n  if (style) { e.style.cssText = style; }\n  if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\n  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\n  return e\n}\n// wrapper for elt, which removes the elt from the accessibility tree\nfunction eltP(tag, content, className, style) {\n  var e = elt(tag, content, className, style);\n  e.setAttribute(\"role\", \"presentation\");\n  return e\n}\n\nvar range;\nif (document.createRange) { range = function(node, start, end, endNode) {\n  var r = document.createRange();\n  r.setEnd(endNode || node, end);\n  r.setStart(node, start);\n  return r\n}; }\nelse { range = function(node, start, end) {\n  var r = document.body.createTextRange();\n  try { r.moveToElementText(node.parentNode); }\n  catch(e) { return r }\n  r.collapse(true);\n  r.moveEnd(\"character\", end);\n  r.moveStart(\"character\", start);\n  return r\n}; }\n\nfunction contains(parent, child) {\n  if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n    { child = child.parentNode; }\n  if (parent.contains)\n    { return parent.contains(child) }\n  do {\n    if (child.nodeType == 11) { child = child.host; }\n    if (child == parent) { return true }\n  } while (child = child.parentNode)\n}\n\nfunction activeElt() {\n  // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n  // IE < 10 will throw when accessed while the page is loading or in an iframe.\n  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n  var activeElement;\n  try {\n    activeElement = document.activeElement;\n  } catch(e) {\n    activeElement = document.body || null;\n  }\n  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n    { activeElement = activeElement.shadowRoot.activeElement; }\n  return activeElement\n}\n\nfunction addClass(node, cls) {\n  var current = node.className;\n  if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\n}\nfunction joinClasses(a, b) {\n  var as = a.split(\" \");\n  for (var i = 0; i < as.length; i++)\n    { if (as[i] && !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\n  return b\n}\n\nvar selectInput = function(node) { node.select(); };\nif (ios) // Mobile Safari apparently has a bug where select() is broken.\n  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\nelse if (ie) // Suppress mysterious IE10 errors\n  { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\n\nfunction bind(f) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return function(){return f.apply(null, args)}\n}\n\nfunction copyObj(obj, target, overwrite) {\n  if (!target) { target = {}; }\n  for (var prop in obj)\n    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n      { target[prop] = obj[prop]; } }\n  return target\n}\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countColumn(string, end, tabSize, startIndex, startValue) {\n  if (end == null) {\n    end = string.search(/[^\\s\\u00a0]/);\n    if (end == -1) { end = string.length; }\n  }\n  for (var i = startIndex || 0, n = startValue || 0;;) {\n    var nextTab = string.indexOf(\"\\t\", i);\n    if (nextTab < 0 || nextTab >= end)\n      { return n + (end - i) }\n    n += nextTab - i;\n    n += tabSize - (n % tabSize);\n    i = nextTab + 1;\n  }\n}\n\nvar Delayed = function() {this.id = null;};\nDelayed.prototype.set = function (ms, f) {\n  clearTimeout(this.id);\n  this.id = setTimeout(f, ms);\n};\n\nfunction indexOf(array, elt) {\n  for (var i = 0; i < array.length; ++i)\n    { if (array[i] == elt) { return i } }\n  return -1\n}\n\n// Number of pixels added to scroller and sizer to hide scrollbar\nvar scrollerGap = 30;\n\n// Returned or thrown by various protocols to signal 'I'm not\n// handling this'.\nvar Pass = {toString: function(){return \"CodeMirror.Pass\"}};\n\n// Reused option objects for setSelection & friends\nvar sel_dontScroll = {scroll: false};\nvar sel_mouse = {origin: \"*mouse\"};\nvar sel_move = {origin: \"+move\"};\n\n// The inverse of countColumn -- find the offset that corresponds to\n// a particular column.\nfunction findColumn(string, goal, tabSize) {\n  for (var pos = 0, col = 0;;) {\n    var nextTab = string.indexOf(\"\\t\", pos);\n    if (nextTab == -1) { nextTab = string.length; }\n    var skipped = nextTab - pos;\n    if (nextTab == string.length || col + skipped >= goal)\n      { return pos + Math.min(skipped, goal - col) }\n    col += nextTab - pos;\n    col += tabSize - (col % tabSize);\n    pos = nextTab + 1;\n    if (col >= goal) { return pos }\n  }\n}\n\nvar spaceStrs = [\"\"];\nfunction spaceStr(n) {\n  while (spaceStrs.length <= n)\n    { spaceStrs.push(lst(spaceStrs) + \" \"); }\n  return spaceStrs[n]\n}\n\nfunction lst(arr) { return arr[arr.length-1] }\n\nfunction map(array, f) {\n  var out = [];\n  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\n  return out\n}\n\nfunction insertSorted(array, value, score) {\n  var pos = 0, priority = score(value);\n  while (pos < array.length && score(array[pos]) <= priority) { pos++; }\n  array.splice(pos, 0, value);\n}\n\nfunction nothing() {}\n\nfunction createObj(base, props) {\n  var inst;\n  if (Object.create) {\n    inst = Object.create(base);\n  } else {\n    nothing.prototype = base;\n    inst = new nothing();\n  }\n  if (props) { copyObj(props, inst); }\n  return inst\n}\n\nvar nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nfunction isWordCharBasic(ch) {\n  return /\\w/.test(ch) || ch > \"\\x80\" &&\n    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n}\nfunction isWordChar(ch, helper) {\n  if (!helper) { return isWordCharBasic(ch) }\n  if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) { return true }\n  return helper.test(ch)\n}\n\nfunction isEmpty(obj) {\n  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\n  return true\n}\n\n// Extending unicode characters. A series of a non-extending char +\n// any number of extending chars is treated as a single unit as far\n// as editing and measuring is concerned. This is not fully correct,\n// since some scripts/fonts/browsers also treat other configurations\n// of code points as a group.\nvar extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\nfunction isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\n\n// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\nfunction skipExtendingChars(str, pos, dir) {\n  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\n  return pos\n}\n\n// Returns the value from the range [`from`; `to`] that satisfies\n// `pred` and is closest to `from`. Assumes that at least `to` satisfies `pred`.\nfunction findFirst(pred, from, to) {\n  for (;;) {\n    if (Math.abs(from - to) <= 1) { return pred(from) ? from : to }\n    var mid = Math.floor((from + to) / 2);\n    if (pred(mid)) { to = mid; }\n    else { from = mid; }\n  }\n}\n\n// The display handles the DOM integration, both for input reading\n// and content drawing. It holds references to DOM nodes and\n// display-related state.\n\nfunction Display(place, doc, input) {\n  var d = this;\n  this.input = input;\n\n  // Covers bottom-right square when both scrollbars are present.\n  d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n  d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n  // Covers bottom of gutter when coverGutterNextToScrollbar is on\n  // and h scrollbar is present.\n  d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n  d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n  // Will contain the actual code, positioned to cover the viewport.\n  d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\n  // Elements are added to these to represent selection and cursors.\n  d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n  d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n  // A visibility: hidden element used to find the size of things.\n  d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n  // When lines outside of the viewport are measured, they are drawn in this.\n  d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n  // Wraps everything that needs to exist inside the vertically-padded coordinate system\n  d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                    null, \"position: relative; outline: none\");\n  var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\n  // Moved around its parent to cover visible view.\n  d.mover = elt(\"div\", [lines], null, \"position: relative\");\n  // Set to the height of the document, allowing scrolling.\n  d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n  d.sizerWidth = null;\n  // Behavior of elts with overflow: auto and padding is\n  // inconsistent across browsers. This is used to ensure the\n  // scrollable area is big enough.\n  d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n  // Will contain the gutters, if any.\n  d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n  d.lineGutter = null;\n  // Actual scrollable element.\n  d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n  d.scroller.setAttribute(\"tabIndex\", \"-1\");\n  // The element in which the editor lives.\n  d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\n\n  if (place) {\n    if (place.appendChild) { place.appendChild(d.wrapper); }\n    else { place(d.wrapper); }\n  }\n\n  // Current rendered range (may be bigger than the view window).\n  d.viewFrom = d.viewTo = doc.first;\n  d.reportedViewFrom = d.reportedViewTo = doc.first;\n  // Information about the rendered lines.\n  d.view = [];\n  d.renderedView = null;\n  // Holds info about a single rendered line when it was rendered\n  // for measurement, while not in view.\n  d.externalMeasured = null;\n  // Empty space (in pixels) above the view\n  d.viewOffset = 0;\n  d.lastWrapHeight = d.lastWrapWidth = 0;\n  d.updateLineNumbers = null;\n\n  d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n  d.scrollbarsClipped = false;\n\n  // Used to only resize the line number gutter when necessary (when\n  // the amount of lines crosses a boundary that makes its width change)\n  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n  // Set to true when a non-horizontal-scrolling line widget is\n  // added. As an optimization, line widget aligning is skipped when\n  // this is false.\n  d.alignWidgets = false;\n\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n  // Tracks the maximum line length so that the horizontal scrollbar\n  // can be kept static when scrolling.\n  d.maxLine = null;\n  d.maxLineLength = 0;\n  d.maxLineChanged = false;\n\n  // Used for measuring wheel scrolling granularity\n  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n  // True when shift is held down.\n  d.shift = false;\n\n  // Used to track whether anything happened since the context menu\n  // was opened.\n  d.selForContextMenu = null;\n\n  d.activeTouch = null;\n\n  input.init(d);\n}\n\n// Find the line object corresponding to the given line number.\nfunction getLine(doc, n) {\n  n -= doc.first;\n  if (n < 0 || n >= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\n  var chunk = doc;\n  while (!chunk.lines) {\n    for (var i = 0;; ++i) {\n      var child = chunk.children[i], sz = child.chunkSize();\n      if (n < sz) { chunk = child; break }\n      n -= sz;\n    }\n  }\n  return chunk.lines[n]\n}\n\n// Get the part of a document between two positions, as an array of\n// strings.\nfunction getBetween(doc, start, end) {\n  var out = [], n = start.line;\n  doc.iter(start.line, end.line + 1, function (line) {\n    var text = line.text;\n    if (n == end.line) { text = text.slice(0, end.ch); }\n    if (n == start.line) { text = text.slice(start.ch); }\n    out.push(text);\n    ++n;\n  });\n  return out\n}\n// Get the lines between from and to, as array of strings.\nfunction getLines(doc, from, to) {\n  var out = [];\n  doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\n  return out\n}\n\n// Update the height of a line, propagating the height change\n// upwards to parent nodes.\nfunction updateLineHeight(line, height) {\n  var diff = height - line.height;\n  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\n}\n\n// Given a line object, find its line number by walking up through\n// its parent links.\nfunction lineNo(line) {\n  if (line.parent == null) { return null }\n  var cur = line.parent, no = indexOf(cur.lines, line);\n  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n    for (var i = 0;; ++i) {\n      if (chunk.children[i] == cur) { break }\n      no += chunk.children[i].chunkSize();\n    }\n  }\n  return no + cur.first\n}\n\n// Find the line at the given vertical position, using the height\n// information in the document tree.\nfunction lineAtHeight(chunk, h) {\n  var n = chunk.first;\n  outer: do {\n    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n      var child = chunk.children[i$1], ch = child.height;\n      if (h < ch) { chunk = child; continue outer }\n      h -= ch;\n      n += child.chunkSize();\n    }\n    return n\n  } while (!chunk.lines)\n  var i = 0;\n  for (; i < chunk.lines.length; ++i) {\n    var line = chunk.lines[i], lh = line.height;\n    if (h < lh) { break }\n    h -= lh;\n  }\n  return n + i\n}\n\nfunction isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\n\nfunction lineNumberFor(options, i) {\n  return String(options.lineNumberFormatter(i + options.firstLineNumber))\n}\n\n// A Pos instance represents a position within the text.\nfunction Pos(line, ch, sticky) {\n  if ( sticky === void 0 ) sticky = null;\n\n  if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\n  this.line = line;\n  this.ch = ch;\n  this.sticky = sticky;\n}\n\n// Compare two positions, return 0 if they are the same, a negative\n// number when a is less, and a positive number otherwise.\nfunction cmp(a, b) { return a.line - b.line || a.ch - b.ch }\n\nfunction equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\n\nfunction copyPos(x) {return Pos(x.line, x.ch)}\nfunction maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\nfunction minPos(a, b) { return cmp(a, b) < 0 ? a : b }\n\n// Most of the external API clips given positions to make sure they\n// actually exist within the document.\nfunction clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\nfunction clipPos(doc, pos) {\n  if (pos.line < doc.first) { return Pos(doc.first, 0) }\n  var last = doc.first + doc.size - 1;\n  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\n  return clipToLen(pos, getLine(doc, pos.line).text.length)\n}\nfunction clipToLen(pos, linelen) {\n  var ch = pos.ch;\n  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\n  else if (ch < 0) { return Pos(pos.line, 0) }\n  else { return pos }\n}\nfunction clipPosArray(doc, array) {\n  var out = [];\n  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\n  return out\n}\n\n// Optimize some code when these features are not used.\nvar sawReadOnlySpans = false;\nvar sawCollapsedSpans = false;\n\nfunction seeReadOnlySpans() {\n  sawReadOnlySpans = true;\n}\n\nfunction seeCollapsedSpans() {\n  sawCollapsedSpans = true;\n}\n\n// TEXTMARKER SPANS\n\nfunction MarkedSpan(marker, from, to) {\n  this.marker = marker;\n  this.from = from; this.to = to;\n}\n\n// Search an array of spans for a span matching the given marker.\nfunction getMarkedSpanFor(spans, marker) {\n  if (spans) { for (var i = 0; i < spans.length; ++i) {\n    var span = spans[i];\n    if (span.marker == marker) { return span }\n  } }\n}\n// Remove a span from an array, returning undefined if no spans are\n// left (we don't store arrays for lines without spans).\nfunction removeMarkedSpan(spans, span) {\n  var r;\n  for (var i = 0; i < spans.length; ++i)\n    { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\n  return r\n}\n// Add a span to a line.\nfunction addMarkedSpan(line, span) {\n  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n  span.marker.attachLine(line);\n}\n\n// Used for the algorithm that adjusts markers for a change in the\n// document. These functions cut an array of spans at a given\n// character position, returning an array of remaining chunks (or\n// undefined if nothing remains).\nfunction markedSpansBefore(old, startCh, isInsert) {\n  var nw;\n  if (old) { for (var i = 0; i < old.length; ++i) {\n    var span = old[i], marker = span.marker;\n    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n    if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n    }\n  } }\n  return nw\n}\nfunction markedSpansAfter(old, endCh, isInsert) {\n  var nw;\n  if (old) { for (var i = 0; i < old.length; ++i) {\n    var span = old[i], marker = span.marker;\n    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n    if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                            span.to == null ? null : span.to - endCh));\n    }\n  } }\n  return nw\n}\n\n// Given a change object, compute the new set of marker spans that\n// cover the line in which the change took place. Removes spans\n// entirely within the change, reconnects spans belonging to the\n// same marker that appear on both sides of the change, and cuts off\n// spans partially within the change. Returns an array of span\n// arrays with one element for each line in (after) the change.\nfunction stretchSpansOverChange(doc, change) {\n  if (change.full) { return null }\n  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n  if (!oldFirst && !oldLast) { return null }\n\n  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n  // Get the spans that 'stick out' on both sides\n  var first = markedSpansBefore(oldFirst, startCh, isInsert);\n  var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n  // Next, merge those two ends\n  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n  if (first) {\n    // Fix up .to properties of first\n    for (var i = 0; i < first.length; ++i) {\n      var span = first[i];\n      if (span.to == null) {\n        var found = getMarkedSpanFor(last, span.marker);\n        if (!found) { span.to = startCh; }\n        else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\n      }\n    }\n  }\n  if (last) {\n    // Fix up .from in last (or move them into first in case of sameLine)\n    for (var i$1 = 0; i$1 < last.length; ++i$1) {\n      var span$1 = last[i$1];\n      if (span$1.to != null) { span$1.to += offset; }\n      if (span$1.from == null) {\n        var found$1 = getMarkedSpanFor(first, span$1.marker);\n        if (!found$1) {\n          span$1.from = offset;\n          if (sameLine) { (first || (first = [])).push(span$1); }\n        }\n      } else {\n        span$1.from += offset;\n        if (sameLine) { (first || (first = [])).push(span$1); }\n      }\n    }\n  }\n  // Make sure we didn't create any zero-length spans\n  if (first) { first = clearEmptySpans(first); }\n  if (last && last != first) { last = clearEmptySpans(last); }\n\n  var newMarkers = [first];\n  if (!sameLine) {\n    // Fill gap with whole-line-spans\n    var gap = change.text.length - 2, gapMarkers;\n    if (gap > 0 && first)\n      { for (var i$2 = 0; i$2 < first.length; ++i$2)\n        { if (first[i$2].to == null)\n          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\n    for (var i$3 = 0; i$3 < gap; ++i$3)\n      { newMarkers.push(gapMarkers); }\n    newMarkers.push(last);\n  }\n  return newMarkers\n}\n\n// Remove spans that are empty and don't have a clearWhenEmpty\n// option of false.\nfunction clearEmptySpans(spans) {\n  for (var i = 0; i < spans.length; ++i) {\n    var span = spans[i];\n    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n      { spans.splice(i--, 1); }\n  }\n  if (!spans.length) { return null }\n  return spans\n}\n\n// Used to 'clip' out readOnly ranges when making a change.\nfunction removeReadOnlyRanges(doc, from, to) {\n  var markers = null;\n  doc.iter(from.line, to.line + 1, function (line) {\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n      var mark = line.markedSpans[i].marker;\n      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n        { (markers || (markers = [])).push(mark); }\n    } }\n  });\n  if (!markers) { return null }\n  var parts = [{from: from, to: to}];\n  for (var i = 0; i < markers.length; ++i) {\n    var mk = markers[i], m = mk.find(0);\n    for (var j = 0; j < parts.length; ++j) {\n      var p = parts[j];\n      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\n      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n        { newParts.push({from: p.from, to: m.from}); }\n      if (dto > 0 || !mk.inclusiveRight && !dto)\n        { newParts.push({from: m.to, to: p.to}); }\n      parts.splice.apply(parts, newParts);\n      j += newParts.length - 3;\n    }\n  }\n  return parts\n}\n\n// Connect or disconnect spans from a line.\nfunction detachMarkedSpans(line) {\n  var spans = line.markedSpans;\n  if (!spans) { return }\n  for (var i = 0; i < spans.length; ++i)\n    { spans[i].marker.detachLine(line); }\n  line.markedSpans = null;\n}\nfunction attachMarkedSpans(line, spans) {\n  if (!spans) { return }\n  for (var i = 0; i < spans.length; ++i)\n    { spans[i].marker.attachLine(line); }\n  line.markedSpans = spans;\n}\n\n// Helpers used when computing which overlapping collapsed span\n// counts as the larger one.\nfunction extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\nfunction extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\n\n// Returns a number indicating which of two overlapping collapsed\n// spans is larger (and thus includes the other). Falls back to\n// comparing ids when the spans cover exactly the same range.\nfunction compareCollapsedMarkers(a, b) {\n  var lenDiff = a.lines.length - b.lines.length;\n  if (lenDiff != 0) { return lenDiff }\n  var aPos = a.find(), bPos = b.find();\n  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n  if (fromCmp) { return -fromCmp }\n  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n  if (toCmp) { return toCmp }\n  return b.id - a.id\n}\n\n// Find out whether a line ends or starts in a collapsed span. If\n// so, return the marker for that span.\nfunction collapsedSpanAtSide(line, start) {\n  var sps = sawCollapsedSpans && line.markedSpans, found;\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n    sp = sps[i];\n    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n        (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n      { found = sp.marker; }\n  } }\n  return found\n}\nfunction collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\nfunction collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\n\n// Test whether there exists a collapsed span that partially\n// overlaps (covers the start or end, but not both) of a new span.\n// Such overlap is not allowed.\nfunction conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {\n  var line = getLine(doc, lineNo$$1);\n  var sps = sawCollapsedSpans && line.markedSpans;\n  if (sps) { for (var i = 0; i < sps.length; ++i) {\n    var sp = sps[i];\n    if (!sp.marker.collapsed) { continue }\n    var found = sp.marker.find(0);\n    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\n    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n      { return true }\n  } }\n}\n\n// A visual line is a line as drawn on the screen. Folding, for\n// example, can cause multiple logical lines to appear on the same\n// visual line. This finds the start of the visual line that the\n// given line is part of (usually that is the line itself).\nfunction visualLine(line) {\n  var merged;\n  while (merged = collapsedSpanAtStart(line))\n    { line = merged.find(-1, true).line; }\n  return line\n}\n\nfunction visualLineEnd(line) {\n  var merged;\n  while (merged = collapsedSpanAtEnd(line))\n    { line = merged.find(1, true).line; }\n  return line\n}\n\n// Returns an array of logical lines that continue the visual line\n// started by the argument, or undefined if there are no such lines.\nfunction visualLineContinued(line) {\n  var merged, lines;\n  while (merged = collapsedSpanAtEnd(line)) {\n    line = merged.find(1, true).line\n    ;(lines || (lines = [])).push(line);\n  }\n  return lines\n}\n\n// Get the line number of the start of the visual line that the\n// given line number is part of.\nfunction visualLineNo(doc, lineN) {\n  var line = getLine(doc, lineN), vis = visualLine(line);\n  if (line == vis) { return lineN }\n  return lineNo(vis)\n}\n\n// Get the line number of the start of the next visual line after\n// the given line.\nfunction visualLineEndNo(doc, lineN) {\n  if (lineN > doc.lastLine()) { return lineN }\n  var line = getLine(doc, lineN), merged;\n  if (!lineIsHidden(doc, line)) { return lineN }\n  while (merged = collapsedSpanAtEnd(line))\n    { line = merged.find(1, true).line; }\n  return lineNo(line) + 1\n}\n\n// Compute whether a line is hidden. Lines count as hidden when they\n// are part of a visual line that starts with another line, or when\n// they are entirely covered by collapsed, non-widget span.\nfunction lineIsHidden(doc, line) {\n  var sps = sawCollapsedSpans && line.markedSpans;\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n    sp = sps[i];\n    if (!sp.marker.collapsed) { continue }\n    if (sp.from == null) { return true }\n    if (sp.marker.widgetNode) { continue }\n    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n      { return true }\n  } }\n}\nfunction lineIsHiddenInner(doc, line, span) {\n  if (span.to == null) {\n    var end = span.marker.find(1, true);\n    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\n  }\n  if (span.marker.inclusiveRight && span.to == line.text.length)\n    { return true }\n  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\n    sp = line.markedSpans[i];\n    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n        (sp.to == null || sp.to != span.from) &&\n        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n        lineIsHiddenInner(doc, line, sp)) { return true }\n  }\n}\n\n// Find the height above the given line.\nfunction heightAtLine(lineObj) {\n  lineObj = visualLine(lineObj);\n\n  var h = 0, chunk = lineObj.parent;\n  for (var i = 0; i < chunk.lines.length; ++i) {\n    var line = chunk.lines[i];\n    if (line == lineObj) { break }\n    else { h += line.height; }\n  }\n  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n      var cur = p.children[i$1];\n      if (cur == chunk) { break }\n      else { h += cur.height; }\n    }\n  }\n  return h\n}\n\n// Compute the character length of a line, taking into account\n// collapsed ranges (see markText) that might hide parts, and join\n// other lines onto it.\nfunction lineLength(line) {\n  if (line.height == 0) { return 0 }\n  var len = line.text.length, merged, cur = line;\n  while (merged = collapsedSpanAtStart(cur)) {\n    var found = merged.find(0, true);\n    cur = found.from.line;\n    len += found.from.ch - found.to.ch;\n  }\n  cur = line;\n  while (merged = collapsedSpanAtEnd(cur)) {\n    var found$1 = merged.find(0, true);\n    len -= cur.text.length - found$1.from.ch;\n    cur = found$1.to.line;\n    len += cur.text.length - found$1.to.ch;\n  }\n  return len\n}\n\n// Find the longest line in the document.\nfunction findMaxLine(cm) {\n  var d = cm.display, doc = cm.doc;\n  d.maxLine = getLine(doc, doc.first);\n  d.maxLineLength = lineLength(d.maxLine);\n  d.maxLineChanged = true;\n  doc.iter(function (line) {\n    var len = lineLength(line);\n    if (len > d.maxLineLength) {\n      d.maxLineLength = len;\n      d.maxLine = line;\n    }\n  });\n}\n\n// BIDI HELPERS\n\nfunction iterateBidiSections(order, from, to, f) {\n  if (!order) { return f(from, to, \"ltr\") }\n  var found = false;\n  for (var i = 0; i < order.length; ++i) {\n    var part = order[i];\n    if (part.from < to && part.to > from || from == to && part.to == from) {\n      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n      found = true;\n    }\n  }\n  if (!found) { f(from, to, \"ltr\"); }\n}\n\nvar bidiOther = null;\nfunction getBidiPartAt(order, ch, sticky) {\n  var found;\n  bidiOther = null;\n  for (var i = 0; i < order.length; ++i) {\n    var cur = order[i];\n    if (cur.from < ch && cur.to > ch) { return i }\n    if (cur.to == ch) {\n      if (cur.from != cur.to && sticky == \"before\") { found = i; }\n      else { bidiOther = i; }\n    }\n    if (cur.from == ch) {\n      if (cur.from != cur.to && sticky != \"before\") { found = i; }\n      else { bidiOther = i; }\n    }\n  }\n  return found != null ? found : bidiOther\n}\n\n// Bidirectional ordering algorithm\n// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n// that this (partially) implements.\n\n// One-char codes used for character types:\n// L (L):   Left-to-Right\n// R (R):   Right-to-Left\n// r (AL):  Right-to-Left Arabic\n// 1 (EN):  European Number\n// + (ES):  European Number Separator\n// % (ET):  European Number Terminator\n// n (AN):  Arabic Number\n// , (CS):  Common Number Separator\n// m (NSM): Non-Spacing Mark\n// b (BN):  Boundary Neutral\n// s (B):   Paragraph Separator\n// t (S):   Segment Separator\n// w (WS):  Whitespace\n// N (ON):  Other Neutrals\n\n// Returns null if characters are ordered as they appear\n// (left-to-right), or an array of sections ({from, to, level}\n// objects) in the order in which they occur visually.\nvar bidiOrdering = (function() {\n  // Character types for codepoints 0 to 0xff\n  var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n  // Character types for codepoints 0x600 to 0x6f9\n  var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n  function charType(code) {\n    if (code <= 0xf7) { return lowTypes.charAt(code) }\n    else if (0x590 <= code && code <= 0x5f4) { return \"R\" }\n    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\n    else if (0x6ee <= code && code <= 0x8ac) { return \"r\" }\n    else if (0x2000 <= code && code <= 0x200b) { return \"w\" }\n    else if (code == 0x200c) { return \"b\" }\n    else { return \"L\" }\n  }\n\n  var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\n  function BidiSpan(level, from, to) {\n    this.level = level;\n    this.from = from; this.to = to;\n  }\n\n  return function(str, direction) {\n    var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n    if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) { return false }\n    var len = str.length, types = [];\n    for (var i = 0; i < len; ++i)\n      { types.push(charType(str.charCodeAt(i))); }\n\n    // W1. Examine each non-spacing mark (NSM) in the level run, and\n    // change the type of the NSM to the type of the previous\n    // character. If the NSM is at the start of the level run, it will\n    // get the type of sor.\n    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n      var type = types[i$1];\n      if (type == \"m\") { types[i$1] = prev; }\n      else { prev = type; }\n    }\n\n    // W2. Search backwards from each instance of a European number\n    // until the first strong type (R, L, AL, or sor) is found. If an\n    // AL is found, change the type of the European number to Arabic\n    // number.\n    // W3. Change all ALs to R.\n    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n      var type$1 = types[i$2];\n      if (type$1 == \"1\" && cur == \"r\") { types[i$2] = \"n\"; }\n      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\n    }\n\n    // W4. A single European separator between two European numbers\n    // changes to a European number. A single common separator between\n    // two numbers of the same type changes to that type.\n    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n      var type$2 = types[i$3];\n      if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\n      else if (type$2 == \",\" && prev$1 == types[i$3+1] &&\n               (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\n      prev$1 = type$2;\n    }\n\n    // W5. A sequence of European terminators adjacent to European\n    // numbers changes to all European numbers.\n    // W6. Otherwise, separators and terminators change to Other\n    // Neutral.\n    for (var i$4 = 0; i$4 < len; ++i$4) {\n      var type$3 = types[i$4];\n      if (type$3 == \",\") { types[i$4] = \"N\"; }\n      else if (type$3 == \"%\") {\n        var end = (void 0);\n        for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\n        var replace = (i$4 && types[i$4-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n        for (var j = i$4; j < end; ++j) { types[j] = replace; }\n        i$4 = end - 1;\n      }\n    }\n\n    // W7. Search backwards from each instance of a European number\n    // until the first strong type (R, L, or sor) is found. If an L is\n    // found, then change the type of the European number to L.\n    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n      var type$4 = types[i$5];\n      if (cur$1 == \"L\" && type$4 == \"1\") { types[i$5] = \"L\"; }\n      else if (isStrong.test(type$4)) { cur$1 = type$4; }\n    }\n\n    // N1. A sequence of neutrals takes the direction of the\n    // surrounding strong text if the text on both sides has the same\n    // direction. European and Arabic numbers act as if they were R in\n    // terms of their influence on neutrals. Start-of-level-run (sor)\n    // and end-of-level-run (eor) are used at level run boundaries.\n    // N2. Any remaining neutrals take the embedding direction.\n    for (var i$6 = 0; i$6 < len; ++i$6) {\n      if (isNeutral.test(types[i$6])) {\n        var end$1 = (void 0);\n        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n        var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\n        var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n        var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\n        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\n        i$6 = end$1 - 1;\n      }\n    }\n\n    // Here we depart from the documented algorithm, in order to avoid\n    // building up an actual levels array. Since there are only three\n    // levels (0, 1, 2) in an implementation that doesn't take\n    // explicit embedding into account, we can build up the order on\n    // the fly, without following the level-based algorithm.\n    var order = [], m;\n    for (var i$7 = 0; i$7 < len;) {\n      if (countsAsLeft.test(types[i$7])) {\n        var start = i$7;\n        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n        order.push(new BidiSpan(0, start, i$7));\n      } else {\n        var pos = i$7, at = order.length;\n        for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\n        for (var j$2 = pos; j$2 < i$7;) {\n          if (countsAsNum.test(types[j$2])) {\n            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }\n            var nstart = j$2;\n            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n            order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n            pos = j$2;\n          } else { ++j$2; }\n        }\n        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\n      }\n    }\n    if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n      order[0].from = m[0].length;\n      order.unshift(new BidiSpan(0, 0, m[0].length));\n    }\n    if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n      lst(order).to -= m[0].length;\n      order.push(new BidiSpan(0, len - m[0].length, len));\n    }\n\n    return direction == \"rtl\" ? order.reverse() : order\n  }\n})();\n\n// Get the bidi ordering for the given line (and cache it). Returns\n// false for lines that are fully left-to-right, and an array of\n// BidiSpan objects otherwise.\nfunction getOrder(line, direction) {\n  var order = line.order;\n  if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\n  return order\n}\n\nfunction moveCharLogically(line, ch, dir) {\n  var target = skipExtendingChars(line.text, ch + dir, dir);\n  return target < 0 || target > line.text.length ? null : target\n}\n\nfunction moveLogically(line, start, dir) {\n  var ch = moveCharLogically(line, start.ch, dir);\n  return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\")\n}\n\nfunction endOfLine(visually, cm, lineObj, lineNo, dir) {\n  if (visually) {\n    var order = getOrder(lineObj, cm.doc.direction);\n    if (order) {\n      var part = dir < 0 ? lst(order) : order[0];\n      var moveInStorageOrder = (dir < 0) == (part.level == 1);\n      var sticky = moveInStorageOrder ? \"after\" : \"before\";\n      var ch;\n      // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n      // it could be that the last bidi part is not on the last visual line,\n      // since visual lines contain content order-consecutive chunks.\n      // Thus, in rtl, we are looking for the first (content-order) character\n      // in the rtl chunk that is on the last line (that is, the same line\n      // as the last (content-order) character).\n      if (part.level > 0) {\n        var prep = prepareMeasureForLine(cm, lineObj);\n        ch = dir < 0 ? lineObj.text.length - 1 : 0;\n        var targetTop = measureCharPrepared(cm, prep, ch).top;\n        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\n        if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\n      } else { ch = dir < 0 ? part.to : part.from; }\n      return new Pos(lineNo, ch, sticky)\n    }\n  }\n  return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\")\n}\n\nfunction moveVisually(cm, line, start, dir) {\n  var bidi = getOrder(line, cm.doc.direction);\n  if (!bidi) { return moveLogically(line, start, dir) }\n  if (start.ch >= line.text.length) {\n    start.ch = line.text.length;\n    start.sticky = \"before\";\n  } else if (start.ch <= 0) {\n    start.ch = 0;\n    start.sticky = \"after\";\n  }\n  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n  if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n    // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n    // nothing interesting happens.\n    return moveLogically(line, start, dir)\n  }\n\n  var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\n  var prep;\n  var getWrappedLineExtent = function (ch) {\n    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\n    prep = prep || prepareMeasureForLine(cm, line);\n    return wrappedLineExtentChar(cm, line, prep, ch)\n  };\n  var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n  if (cm.doc.direction == \"rtl\" || part.level == 1) {\n    var moveInStorageOrder = (part.level == 1) == (dir < 0);\n    var ch = mv(start, moveInStorageOrder ? 1 : -1);\n    if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n      // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n      var sticky = moveInStorageOrder ? \"before\" : \"after\";\n      return new Pos(start.line, ch, sticky)\n    }\n  }\n\n  // Case 3: Could not move within this bidi part in this visual line, so leave\n  // the current bidi part\n\n  var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\n    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\n      ? new Pos(start.line, mv(ch, 1), \"before\")\n      : new Pos(start.line, ch, \"after\"); };\n\n    for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n      var part = bidi[partPos];\n      var moveInStorageOrder = (dir > 0) == (part.level != 1);\n      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n      if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\n      ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n      if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\n    }\n  };\n\n  // Case 3a: Look for other bidi parts on the same visual line\n  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n  if (res) { return res }\n\n  // Case 3b: Look for other bidi parts on the next visual line\n  var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n    if (res) { return res }\n  }\n\n  // Case 4: Nowhere to move\n  return null\n}\n\n// EVENT HANDLING\n\n// Lightweight event framework. on/off also work on DOM nodes,\n// registering native DOM handlers.\n\nvar noHandlers = [];\n\nvar on = function(emitter, type, f) {\n  if (emitter.addEventListener) {\n    emitter.addEventListener(type, f, false);\n  } else if (emitter.attachEvent) {\n    emitter.attachEvent(\"on\" + type, f);\n  } else {\n    var map$$1 = emitter._handlers || (emitter._handlers = {});\n    map$$1[type] = (map$$1[type] || noHandlers).concat(f);\n  }\n};\n\nfunction getHandlers(emitter, type) {\n  return emitter._handlers && emitter._handlers[type] || noHandlers\n}\n\nfunction off(emitter, type, f) {\n  if (emitter.removeEventListener) {\n    emitter.removeEventListener(type, f, false);\n  } else if (emitter.detachEvent) {\n    emitter.detachEvent(\"on\" + type, f);\n  } else {\n    var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];\n    if (arr) {\n      var index = indexOf(arr, f);\n      if (index > -1)\n        { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\n    }\n  }\n}\n\nfunction signal(emitter, type /*, values...*/) {\n  var handlers = getHandlers(emitter, type);\n  if (!handlers.length) { return }\n  var args = Array.prototype.slice.call(arguments, 2);\n  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\n}\n\n// The DOM events that CodeMirror handles can be overridden by\n// registering a (non-DOM) handler on the editor for the event name,\n// and preventDefault-ing the event in that handler.\nfunction signalDOMEvent(cm, e, override) {\n  if (typeof e == \"string\")\n    { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\n  signal(cm, override || e.type, cm, e);\n  return e_defaultPrevented(e) || e.codemirrorIgnore\n}\n\nfunction signalCursorActivity(cm) {\n  var arr = cm._handlers && cm._handlers.cursorActivity;\n  if (!arr) { return }\n  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\n    { set.push(arr[i]); } }\n}\n\nfunction hasHandler(emitter, type) {\n  return getHandlers(emitter, type).length > 0\n}\n\n// Add on and off methods to a constructor's prototype, to make\n// registering events on such objects more convenient.\nfunction eventMixin(ctor) {\n  ctor.prototype.on = function(type, f) {on(this, type, f);};\n  ctor.prototype.off = function(type, f) {off(this, type, f);};\n}\n\n// Due to the fact that we still support jurassic IE versions, some\n// compatibility wrappers are needed.\n\nfunction e_preventDefault(e) {\n  if (e.preventDefault) { e.preventDefault(); }\n  else { e.returnValue = false; }\n}\nfunction e_stopPropagation(e) {\n  if (e.stopPropagation) { e.stopPropagation(); }\n  else { e.cancelBubble = true; }\n}\nfunction e_defaultPrevented(e) {\n  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\n}\nfunction e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n\nfunction e_target(e) {return e.target || e.srcElement}\nfunction e_button(e) {\n  var b = e.which;\n  if (b == null) {\n    if (e.button & 1) { b = 1; }\n    else if (e.button & 2) { b = 3; }\n    else if (e.button & 4) { b = 2; }\n  }\n  if (mac && e.ctrlKey && b == 1) { b = 3; }\n  return b\n}\n\n// Detect drag-and-drop\nvar dragAndDrop = function() {\n  // There is *some* kind of drag-and-drop support in IE6-8, but I\n  // couldn't get it to work yet.\n  if (ie && ie_version < 9) { return false }\n  var div = elt('div');\n  return \"draggable\" in div || \"dragDrop\" in div\n}();\n\nvar zwspSupported;\nfunction zeroWidthElement(measure) {\n  if (zwspSupported == null) {\n    var test = elt(\"span\", \"\\u200b\");\n    removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n    if (measure.firstChild.offsetHeight != 0)\n      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\n  }\n  var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n    elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n  node.setAttribute(\"cm-text\", \"\");\n  return node\n}\n\n// Feature-detect IE's crummy client rect reporting for bidi text\nvar badBidiRects;\nfunction hasBadBidiRects(measure) {\n  if (badBidiRects != null) { return badBidiRects }\n  var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n  var r0 = range(txt, 0, 1).getBoundingClientRect();\n  var r1 = range(txt, 1, 2).getBoundingClientRect();\n  removeChildren(measure);\n  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\n  return badBidiRects = (r1.right - r0.right < 3)\n}\n\n// See if \"\".split is the broken IE version, if so, provide an\n// alternative way to split lines.\nvar splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n  var pos = 0, result = [], l = string.length;\n  while (pos <= l) {\n    var nl = string.indexOf(\"\\n\", pos);\n    if (nl == -1) { nl = string.length; }\n    var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n    var rt = line.indexOf(\"\\r\");\n    if (rt != -1) {\n      result.push(line.slice(0, rt));\n      pos += rt + 1;\n    } else {\n      result.push(line);\n      pos = nl + 1;\n    }\n  }\n  return result\n} : function (string) { return string.split(/\\r\\n?|\\n/); };\n\nvar hasSelection = window.getSelection ? function (te) {\n  try { return te.selectionStart != te.selectionEnd }\n  catch(e) { return false }\n} : function (te) {\n  var range$$1;\n  try {range$$1 = te.ownerDocument.selection.createRange();}\n  catch(e) {}\n  if (!range$$1 || range$$1.parentElement() != te) { return false }\n  return range$$1.compareEndPoints(\"StartToEnd\", range$$1) != 0\n};\n\nvar hasCopyEvent = (function () {\n  var e = elt(\"div\");\n  if (\"oncopy\" in e) { return true }\n  e.setAttribute(\"oncopy\", \"return;\");\n  return typeof e.oncopy == \"function\"\n})();\n\nvar badZoomedRects = null;\nfunction hasBadZoomedRects(measure) {\n  if (badZoomedRects != null) { return badZoomedRects }\n  var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n  var normal = node.getBoundingClientRect();\n  var fromRange = range(node, 0, 1).getBoundingClientRect();\n  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\n}\n\n// Known modes, by name and by MIME\nvar modes = {};\nvar mimeModes = {};\n\n// Extra arguments are stored as the mode's dependencies, which is\n// used by (legacy) mechanisms like loadmode.js to automatically\n// load a mode. (Preferred mechanism is the require/define calls.)\nfunction defineMode(name, mode) {\n  if (arguments.length > 2)\n    { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\n  modes[name] = mode;\n}\n\nfunction defineMIME(mime, spec) {\n  mimeModes[mime] = spec;\n}\n\n// Given a MIME type, a {name, ...options} config object, or a name\n// string, return a mode config object.\nfunction resolveMode(spec) {\n  if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n    spec = mimeModes[spec];\n  } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n    var found = mimeModes[spec.name];\n    if (typeof found == \"string\") { found = {name: found}; }\n    spec = createObj(found, spec);\n    spec.name = found.name;\n  } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n    return resolveMode(\"application/xml\")\n  } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n    return resolveMode(\"application/json\")\n  }\n  if (typeof spec == \"string\") { return {name: spec} }\n  else { return spec || {name: \"null\"} }\n}\n\n// Given a mode spec (anything that resolveMode accepts), find and\n// initialize an actual mode object.\nfunction getMode(options, spec) {\n  spec = resolveMode(spec);\n  var mfactory = modes[spec.name];\n  if (!mfactory) { return getMode(options, \"text/plain\") }\n  var modeObj = mfactory(options, spec);\n  if (modeExtensions.hasOwnProperty(spec.name)) {\n    var exts = modeExtensions[spec.name];\n    for (var prop in exts) {\n      if (!exts.hasOwnProperty(prop)) { continue }\n      if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\n      modeObj[prop] = exts[prop];\n    }\n  }\n  modeObj.name = spec.name;\n  if (spec.helperType) { modeObj.helperType = spec.helperType; }\n  if (spec.modeProps) { for (var prop$1 in spec.modeProps)\n    { modeObj[prop$1] = spec.modeProps[prop$1]; } }\n\n  return modeObj\n}\n\n// This can be used to attach properties to mode objects from\n// outside the actual mode definition.\nvar modeExtensions = {};\nfunction extendMode(mode, properties) {\n  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n  copyObj(properties, exts);\n}\n\nfunction copyState(mode, state) {\n  if (state === true) { return state }\n  if (mode.copyState) { return mode.copyState(state) }\n  var nstate = {};\n  for (var n in state) {\n    var val = state[n];\n    if (val instanceof Array) { val = val.concat([]); }\n    nstate[n] = val;\n  }\n  return nstate\n}\n\n// Given a mode and a state (for that mode), find the inner mode and\n// state at the position that the state refers to.\nfunction innerMode(mode, state) {\n  var info;\n  while (mode.innerMode) {\n    info = mode.innerMode(state);\n    if (!info || info.mode == mode) { break }\n    state = info.state;\n    mode = info.mode;\n  }\n  return info || {mode: mode, state: state}\n}\n\nfunction startState(mode, a1, a2) {\n  return mode.startState ? mode.startState(a1, a2) : true\n}\n\n// STRING STREAM\n\n// Fed to the mode parsers, provides helper functions to make\n// parsers more succinct.\n\nvar StringStream = function(string, tabSize, lineOracle) {\n  this.pos = this.start = 0;\n  this.string = string;\n  this.tabSize = tabSize || 8;\n  this.lastColumnPos = this.lastColumnValue = 0;\n  this.lineStart = 0;\n  this.lineOracle = lineOracle;\n};\n\nStringStream.prototype.eol = function () {return this.pos >= this.string.length};\nStringStream.prototype.sol = function () {return this.pos == this.lineStart};\nStringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\nStringStream.prototype.next = function () {\n  if (this.pos < this.string.length)\n    { return this.string.charAt(this.pos++) }\n};\nStringStream.prototype.eat = function (match) {\n  var ch = this.string.charAt(this.pos);\n  var ok;\n  if (typeof match == \"string\") { ok = ch == match; }\n  else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\n  if (ok) {++this.pos; return ch}\n};\nStringStream.prototype.eatWhile = function (match) {\n  var start = this.pos;\n  while (this.eat(match)){}\n  return this.pos > start\n};\nStringStream.prototype.eatSpace = function () {\n    var this$1 = this;\n\n  var start = this.pos;\n  while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }\n  return this.pos > start\n};\nStringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\nStringStream.prototype.skipTo = function (ch) {\n  var found = this.string.indexOf(ch, this.pos);\n  if (found > -1) {this.pos = found; return true}\n};\nStringStream.prototype.backUp = function (n) {this.pos -= n;};\nStringStream.prototype.column = function () {\n  if (this.lastColumnPos < this.start) {\n    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n    this.lastColumnPos = this.start;\n  }\n  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n};\nStringStream.prototype.indentation = function () {\n  return countColumn(this.string, null, this.tabSize) -\n    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n};\nStringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n  if (typeof pattern == \"string\") {\n    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n    var substr = this.string.substr(this.pos, pattern.length);\n    if (cased(substr) == cased(pattern)) {\n      if (consume !== false) { this.pos += pattern.length; }\n      return true\n    }\n  } else {\n    var match = this.string.slice(this.pos).match(pattern);\n    if (match && match.index > 0) { return null }\n    if (match && consume !== false) { this.pos += match[0].length; }\n    return match\n  }\n};\nStringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\nStringStream.prototype.hideFirstChars = function (n, inner) {\n  this.lineStart += n;\n  try { return inner() }\n  finally { this.lineStart -= n; }\n};\nStringStream.prototype.lookAhead = function (n) {\n  var oracle = this.lineOracle;\n  return oracle && oracle.lookAhead(n)\n};\n\nvar SavedContext = function(state, lookAhead) {\n  this.state = state;\n  this.lookAhead = lookAhead;\n};\n\nvar Context = function(doc, state, line, lookAhead) {\n  this.state = state;\n  this.doc = doc;\n  this.line = line;\n  this.maxLookAhead = lookAhead || 0;\n};\n\nContext.prototype.lookAhead = function (n) {\n  var line = this.doc.getLine(this.line + n);\n  if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }\n  return line\n};\n\nContext.prototype.nextLine = function () {\n  this.line++;\n  if (this.maxLookAhead > 0) { this.maxLookAhead--; }\n};\n\nContext.fromSaved = function (doc, saved, line) {\n  if (saved instanceof SavedContext)\n    { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }\n  else\n    { return new Context(doc, copyState(doc.mode, saved), line) }\n};\n\nContext.prototype.save = function (copy) {\n  var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n  return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state\n};\n\n\n// Compute a style array (an array starting with a mode generation\n// -- for invalidation -- followed by pairs of end positions and\n// style strings), which is used to highlight the tokens on the\n// line.\nfunction highlightLine(cm, line, context, forceToEnd) {\n  // A styles array always starts with a number identifying the\n  // mode/overlays that it is based on (for easy invalidation).\n  var st = [cm.state.modeGen], lineClasses = {};\n  // Compute the base array of styles\n  runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },\n          lineClasses, forceToEnd);\n  var state = context.state;\n\n  // Run overlays, adjust style array.\n  var loop = function ( o ) {\n    var overlay = cm.state.overlays[o], i = 1, at = 0;\n    context.state = true;\n    runMode(cm, line.text, overlay.mode, context, function (end, style) {\n      var start = i;\n      // Ensure there's a token end at the current position, and that i points at it\n      while (at < end) {\n        var i_end = st[i];\n        if (i_end > end)\n          { st.splice(i, 1, end, st[i+1], i_end); }\n        i += 2;\n        at = Math.min(end, i_end);\n      }\n      if (!style) { return }\n      if (overlay.opaque) {\n        st.splice(start, i - start, end, \"overlay \" + style);\n        i = start + 2;\n      } else {\n        for (; start < i; start += 2) {\n          var cur = st[start+1];\n          st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n        }\n      }\n    }, lineClasses);\n  };\n\n  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\n  context.state = state;\n\n  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\n}\n\nfunction getLineStyles(cm, line, updateFrontier) {\n  if (!line.styles || line.styles[0] != cm.state.modeGen) {\n    var context = getContextBefore(cm, lineNo(line));\n    var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n    var result = highlightLine(cm, line, context);\n    if (resetState) { context.state = resetState; }\n    line.stateAfter = context.save(!resetState);\n    line.styles = result.styles;\n    if (result.classes) { line.styleClasses = result.classes; }\n    else if (line.styleClasses) { line.styleClasses = null; }\n    if (updateFrontier === cm.doc.highlightFrontier)\n      { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }\n  }\n  return line.styles\n}\n\nfunction getContextBefore(cm, n, precise) {\n  var doc = cm.doc, display = cm.display;\n  if (!doc.mode.startState) { return new Context(doc, true, n) }\n  var start = findStartLine(cm, n, precise);\n  var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n  var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n\n  doc.iter(start, n, function (line) {\n    processLine(cm, line.text, context);\n    var pos = context.line;\n    line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n    context.nextLine();\n  });\n  if (precise) { doc.modeFrontier = context.line; }\n  return context\n}\n\n// Lightweight form of highlight -- proceed over this line and\n// update state, but don't save a style array. Used for lines that\n// aren't currently visible.\nfunction processLine(cm, text, context, startAt) {\n  var mode = cm.doc.mode;\n  var stream = new StringStream(text, cm.options.tabSize, context);\n  stream.start = stream.pos = startAt || 0;\n  if (text == \"\") { callBlankLine(mode, context.state); }\n  while (!stream.eol()) {\n    readToken(mode, stream, context.state);\n    stream.start = stream.pos;\n  }\n}\n\nfunction callBlankLine(mode, state) {\n  if (mode.blankLine) { return mode.blankLine(state) }\n  if (!mode.innerMode) { return }\n  var inner = innerMode(mode, state);\n  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\n}\n\nfunction readToken(mode, stream, state, inner) {\n  for (var i = 0; i < 10; i++) {\n    if (inner) { inner[0] = innerMode(mode, state).mode; }\n    var style = mode.token(stream, state);\n    if (stream.pos > stream.start) { return style }\n  }\n  throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\n}\n\nvar Token = function(stream, type, state) {\n  this.start = stream.start; this.end = stream.pos;\n  this.string = stream.current();\n  this.type = type || null;\n  this.state = state;\n};\n\n// Utility for getTokenAt and getLineTokens\nfunction takeToken(cm, pos, precise, asArray) {\n  var doc = cm.doc, mode = doc.mode, style;\n  pos = clipPos(doc, pos);\n  var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n  var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n  if (asArray) { tokens = []; }\n  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n    stream.start = stream.pos;\n    style = readToken(mode, stream, context.state);\n    if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }\n  }\n  return asArray ? tokens : new Token(stream, style, context.state)\n}\n\nfunction extractLineClasses(type, output) {\n  if (type) { for (;;) {\n    var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n    if (!lineClass) { break }\n    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n    var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n    if (output[prop] == null)\n      { output[prop] = lineClass[2]; }\n    else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n      { output[prop] += \" \" + lineClass[2]; }\n  } }\n  return type\n}\n\n// Run the given mode's parser over a line, calling f for each token.\nfunction runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n  var flattenSpans = mode.flattenSpans;\n  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\n  var curStart = 0, curStyle = null;\n  var stream = new StringStream(text, cm.options.tabSize, context), style;\n  var inner = cm.options.addModeClass && [null];\n  if (text == \"\") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }\n  while (!stream.eol()) {\n    if (stream.pos > cm.options.maxHighlightLength) {\n      flattenSpans = false;\n      if (forceToEnd) { processLine(cm, text, context, stream.pos); }\n      stream.pos = text.length;\n      style = null;\n    } else {\n      style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n    }\n    if (inner) {\n      var mName = inner[0].name;\n      if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\n    }\n    if (!flattenSpans || curStyle != style) {\n      while (curStart < stream.start) {\n        curStart = Math.min(stream.start, curStart + 5000);\n        f(curStart, curStyle);\n      }\n      curStyle = style;\n    }\n    stream.start = stream.pos;\n  }\n  while (curStart < stream.pos) {\n    // Webkit seems to refuse to render text nodes longer than 57444\n    // characters, and returns inaccurate measurements in nodes\n    // starting around 5000 chars.\n    var pos = Math.min(stream.pos, curStart + 5000);\n    f(pos, curStyle);\n    curStart = pos;\n  }\n}\n\n// Finds the line to start with when starting a parse. Tries to\n// find a line with a stateAfter, so that it can start with a\n// valid state. If that fails, it returns the line with the\n// smallest indentation, which tends to need the least context to\n// parse correctly.\nfunction findStartLine(cm, n, precise) {\n  var minindent, minline, doc = cm.doc;\n  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n  for (var search = n; search > lim; --search) {\n    if (search <= doc.first) { return doc.first }\n    var line = getLine(doc, search - 1), after = line.stateAfter;\n    if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))\n      { return search }\n    var indented = countColumn(line.text, null, cm.options.tabSize);\n    if (minline == null || minindent > indented) {\n      minline = search - 1;\n      minindent = indented;\n    }\n  }\n  return minline\n}\n\nfunction retreatFrontier(doc, n) {\n  doc.modeFrontier = Math.min(doc.modeFrontier, n);\n  if (doc.highlightFrontier < n - 10) { return }\n  var start = doc.first;\n  for (var line = n - 1; line > start; line--) {\n    var saved = getLine(doc, line).stateAfter;\n    // change is on 3\n    // state on line 1 looked ahead 2 -- so saw 3\n    // test 1 + 2 < 3 should cover this\n    if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n      start = line + 1;\n      break\n    }\n  }\n  doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n}\n\n// LINE DATA STRUCTURE\n\n// Line objects. These hold state related to a line, including\n// highlighting info (the styles array).\nvar Line = function(text, markedSpans, estimateHeight) {\n  this.text = text;\n  attachMarkedSpans(this, markedSpans);\n  this.height = estimateHeight ? estimateHeight(this) : 1;\n};\n\nLine.prototype.lineNo = function () { return lineNo(this) };\neventMixin(Line);\n\n// Change the content (text, markers) of a line. Automatically\n// invalidates cached information and tries to re-estimate the\n// line's height.\nfunction updateLine(line, text, markedSpans, estimateHeight) {\n  line.text = text;\n  if (line.stateAfter) { line.stateAfter = null; }\n  if (line.styles) { line.styles = null; }\n  if (line.order != null) { line.order = null; }\n  detachMarkedSpans(line);\n  attachMarkedSpans(line, markedSpans);\n  var estHeight = estimateHeight ? estimateHeight(line) : 1;\n  if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n}\n\n// Detach a line from the document tree and its markers.\nfunction cleanUpLine(line) {\n  line.parent = null;\n  detachMarkedSpans(line);\n}\n\n// Convert a style as returned by a mode (either null, or a string\n// containing one or more styles) to a CSS style. This is cached,\n// and also looks for line-wide styles.\nvar styleToClassCache = {};\nvar styleToClassCacheWithMode = {};\nfunction interpretTokenStyle(style, options) {\n  if (!style || /^\\s*$/.test(style)) { return null }\n  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n  return cache[style] ||\n    (cache[style] = style.replace(/\\S+/g, \"cm-$&\"))\n}\n\n// Render the DOM representation of the text of a line. Also builds\n// up a 'line map', which points at the DOM nodes that represent\n// specific stretches of text, and is used by the measuring code.\n// The returned object contains the DOM node, this map, and\n// information about line-wide styles that were set by the mode.\nfunction buildLineContent(cm, lineView) {\n  // The padding-right forces the element to have a 'border', which\n  // is needed on Webkit to be able to get line-level bounding\n  // rectangles for it (in measureChar).\n  var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n  var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                 col: 0, pos: 0, cm: cm,\n                 trailingSpace: false,\n                 splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\n  lineView.measure = {};\n\n  // Iterate over the logical lines that make up this visual line.\n  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\n    builder.pos = 0;\n    builder.addToken = buildToken;\n    // Optionally wire in some hacks into the token-rendering\n    // algorithm, to deal with browser quirks.\n    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\n      { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\n    builder.map = [];\n    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n    if (line.styleClasses) {\n      if (line.styleClasses.bgClass)\n        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\n      if (line.styleClasses.textClass)\n        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\n    }\n\n    // Ensure at least a single node is present, for measuring.\n    if (builder.map.length == 0)\n      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\n\n    // Store the map and a cache object for the current logical line\n    if (i == 0) {\n      lineView.measure.map = builder.map;\n      lineView.measure.cache = {};\n    } else {\n      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\n      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\n    }\n  }\n\n  // See issue #2901\n  if (webkit) {\n    var last = builder.content.lastChild;\n    if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n      { builder.content.className = \"cm-tab-wrap-hack\"; }\n  }\n\n  signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n  if (builder.pre.className)\n    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\n\n  return builder\n}\n\nfunction defaultSpecialCharPlaceholder(ch) {\n  var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n  token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n  token.setAttribute(\"aria-label\", token.title);\n  return token\n}\n\n// Build up the DOM representation for a single token, and add it to\n// the line map. Takes care to render special characters separately.\nfunction buildToken(builder, text, style, startStyle, endStyle, title, css) {\n  if (!text) { return }\n  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n  var special = builder.cm.state.specialChars, mustWrap = false;\n  var content;\n  if (!special.test(text)) {\n    builder.col += text.length;\n    content = document.createTextNode(displayText);\n    builder.map.push(builder.pos, builder.pos + text.length, content);\n    if (ie && ie_version < 9) { mustWrap = true; }\n    builder.pos += text.length;\n  } else {\n    content = document.createDocumentFragment();\n    var pos = 0;\n    while (true) {\n      special.lastIndex = pos;\n      var m = special.exec(text);\n      var skipped = m ? m.index - pos : text.length - pos;\n      if (skipped) {\n        var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n        if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt])); }\n        else { content.appendChild(txt); }\n        builder.map.push(builder.pos, builder.pos + skipped, txt);\n        builder.col += skipped;\n        builder.pos += skipped;\n      }\n      if (!m) { break }\n      pos += skipped + 1;\n      var txt$1 = (void 0);\n      if (m[0] == \"\\t\") {\n        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n        txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n        txt$1.setAttribute(\"role\", \"presentation\");\n        txt$1.setAttribute(\"cm-text\", \"\\t\");\n        builder.col += tabWidth;\n      } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n        txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n        txt$1.setAttribute(\"cm-text\", m[0]);\n        builder.col += 1;\n      } else {\n        txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n        txt$1.setAttribute(\"cm-text\", m[0]);\n        if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt$1])); }\n        else { content.appendChild(txt$1); }\n        builder.col += 1;\n      }\n      builder.map.push(builder.pos, builder.pos + 1, txt$1);\n      builder.pos++;\n    }\n  }\n  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n  if (style || startStyle || endStyle || mustWrap || css) {\n    var fullStyle = style || \"\";\n    if (startStyle) { fullStyle += startStyle; }\n    if (endStyle) { fullStyle += endStyle; }\n    var token = elt(\"span\", [content], fullStyle, css);\n    if (title) { token.title = title; }\n    return builder.content.appendChild(token)\n  }\n  builder.content.appendChild(content);\n}\n\nfunction splitSpaces(text, trailingBefore) {\n  if (text.length > 1 && !/  /.test(text)) { return text }\n  var spaceBefore = trailingBefore, result = \"\";\n  for (var i = 0; i < text.length; i++) {\n    var ch = text.charAt(i);\n    if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n      { ch = \"\\u00a0\"; }\n    result += ch;\n    spaceBefore = ch == \" \";\n  }\n  return result\n}\n\n// Work around nonsense dimensions being reported for stretches of\n// right-to-left text.\nfunction buildTokenBadBidi(inner, order) {\n  return function (builder, text, style, startStyle, endStyle, title, css) {\n    style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n    var start = builder.pos, end = start + text.length;\n    for (;;) {\n      // Find the part that overlaps with the start of this text\n      var part = (void 0);\n      for (var i = 0; i < order.length; i++) {\n        part = order[i];\n        if (part.to > start && part.from <= start) { break }\n      }\n      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }\n      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\n      startStyle = null;\n      text = text.slice(part.to - start);\n      start = part.to;\n    }\n  }\n}\n\nfunction buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n  var widget = !ignoreWidget && marker.widgetNode;\n  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\n  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n    if (!widget)\n      { widget = builder.content.appendChild(document.createElement(\"span\")); }\n    widget.setAttribute(\"cm-marker\", marker.id);\n  }\n  if (widget) {\n    builder.cm.display.input.setUneditable(widget);\n    builder.content.appendChild(widget);\n  }\n  builder.pos += size;\n  builder.trailingSpace = false;\n}\n\n// Outputs a number of spans to make up a line, taking highlighting\n// and marked text into account.\nfunction insertLineContent(line, builder, styles) {\n  var spans = line.markedSpans, allText = line.text, at = 0;\n  if (!spans) {\n    for (var i$1 = 1; i$1 < styles.length; i$1+=2)\n      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\n    return\n  }\n\n  var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n  for (;;) {\n    if (nextChange == pos) { // Update current marker set\n      spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\n      collapsed = null; nextChange = Infinity;\n      var foundBookmarks = [], endStyles = (void 0);\n      for (var j = 0; j < spans.length; ++j) {\n        var sp = spans[j], m = sp.marker;\n        if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n          foundBookmarks.push(m);\n        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n          if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n            nextChange = sp.to;\n            spanEndStyle = \"\";\n          }\n          if (m.className) { spanStyle += \" \" + m.className; }\n          if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\n          if (m.startStyle && sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\n          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\n          if (m.title && !title) { title = m.title; }\n          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n            { collapsed = sp; }\n        } else if (sp.from > pos && nextChange > sp.from) {\n          nextChange = sp.from;\n        }\n      }\n      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\n        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\n\n      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\n        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\n      if (collapsed && (collapsed.from || 0) == pos) {\n        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                           collapsed.marker, collapsed.from == null);\n        if (collapsed.to == null) { return }\n        if (collapsed.to == pos) { collapsed = false; }\n      }\n    }\n    if (pos >= len) { break }\n\n    var upto = Math.min(len, nextChange);\n    while (true) {\n      if (text) {\n        var end = pos + text.length;\n        if (!collapsed) {\n          var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\n        }\n        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\n        pos = end;\n        spanStartStyle = \"\";\n      }\n      text = allText.slice(at, at = styles[i++]);\n      style = interpretTokenStyle(styles[i++], builder.cm.options);\n    }\n  }\n}\n\n\n// These objects are used to represent the visible (currently drawn)\n// part of the document. A LineView may correspond to multiple\n// logical lines, if those are connected by collapsed ranges.\nfunction LineView(doc, line, lineN) {\n  // The starting line\n  this.line = line;\n  // Continuing lines, if any\n  this.rest = visualLineContinued(line);\n  // Number of logical lines in this visual line\n  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n  this.node = this.text = null;\n  this.hidden = lineIsHidden(doc, line);\n}\n\n// Create a range of LineView objects for the given lines.\nfunction buildViewArray(cm, from, to) {\n  var array = [], nextPos;\n  for (var pos = from; pos < to; pos = nextPos) {\n    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n    nextPos = pos + view.size;\n    array.push(view);\n  }\n  return array\n}\n\nvar operationGroup = null;\n\nfunction pushOperation(op) {\n  if (operationGroup) {\n    operationGroup.ops.push(op);\n  } else {\n    op.ownsGroup = operationGroup = {\n      ops: [op],\n      delayedCallbacks: []\n    };\n  }\n}\n\nfunction fireCallbacksForOps(group) {\n  // Calls delayed callbacks and cursorActivity handlers until no\n  // new ones appear\n  var callbacks = group.delayedCallbacks, i = 0;\n  do {\n    for (; i < callbacks.length; i++)\n      { callbacks[i].call(null); }\n    for (var j = 0; j < group.ops.length; j++) {\n      var op = group.ops[j];\n      if (op.cursorActivityHandlers)\n        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\n    }\n  } while (i < callbacks.length)\n}\n\nfunction finishOperation(op, endCb) {\n  var group = op.ownsGroup;\n  if (!group) { return }\n\n  try { fireCallbacksForOps(group); }\n  finally {\n    operationGroup = null;\n    endCb(group);\n  }\n}\n\nvar orphanDelayedCallbacks = null;\n\n// Often, we want to signal events at a point where we are in the\n// middle of some work, but don't want the handler to start calling\n// other methods on the editor, which might be in an inconsistent\n// state or simply not expect any other events to happen.\n// signalLater looks whether there are any handlers, and schedules\n// them to be executed when the last operation ends, or, if no\n// operation is active, when a timeout fires.\nfunction signalLater(emitter, type /*, values...*/) {\n  var arr = getHandlers(emitter, type);\n  if (!arr.length) { return }\n  var args = Array.prototype.slice.call(arguments, 2), list;\n  if (operationGroup) {\n    list = operationGroup.delayedCallbacks;\n  } else if (orphanDelayedCallbacks) {\n    list = orphanDelayedCallbacks;\n  } else {\n    list = orphanDelayedCallbacks = [];\n    setTimeout(fireOrphanDelayed, 0);\n  }\n  var loop = function ( i ) {\n    list.push(function () { return arr[i].apply(null, args); });\n  };\n\n  for (var i = 0; i < arr.length; ++i)\n    loop( i );\n}\n\nfunction fireOrphanDelayed() {\n  var delayed = orphanDelayedCallbacks;\n  orphanDelayedCallbacks = null;\n  for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\n}\n\n// When an aspect of a line changes, a string is added to\n// lineView.changes. This updates the relevant part of the line's\n// DOM structure.\nfunction updateLineForChanges(cm, lineView, lineN, dims) {\n  for (var j = 0; j < lineView.changes.length; j++) {\n    var type = lineView.changes[j];\n    if (type == \"text\") { updateLineText(cm, lineView); }\n    else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\n    else if (type == \"class\") { updateLineClasses(cm, lineView); }\n    else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\n  }\n  lineView.changes = null;\n}\n\n// Lines with gutter elements, widgets or a background class need to\n// be wrapped, and have the extra elements added to the wrapper div\nfunction ensureLineWrapped(lineView) {\n  if (lineView.node == lineView.text) {\n    lineView.node = elt(\"div\", null, null, \"position: relative\");\n    if (lineView.text.parentNode)\n      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\n    lineView.node.appendChild(lineView.text);\n    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\n  }\n  return lineView.node\n}\n\nfunction updateLineBackground(cm, lineView) {\n  var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n  if (cls) { cls += \" CodeMirror-linebackground\"; }\n  if (lineView.background) {\n    if (cls) { lineView.background.className = cls; }\n    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n  } else if (cls) {\n    var wrap = ensureLineWrapped(lineView);\n    lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n    cm.display.input.setUneditable(lineView.background);\n  }\n}\n\n// Wrapper around buildLineContent which will reuse the structure\n// in display.externalMeasured when possible.\nfunction getLineContent(cm, lineView) {\n  var ext = cm.display.externalMeasured;\n  if (ext && ext.line == lineView.line) {\n    cm.display.externalMeasured = null;\n    lineView.measure = ext.measure;\n    return ext.built\n  }\n  return buildLineContent(cm, lineView)\n}\n\n// Redraw the line's text. Interacts with the background and text\n// classes because the mode may output tokens that influence these\n// classes.\nfunction updateLineText(cm, lineView) {\n  var cls = lineView.text.className;\n  var built = getLineContent(cm, lineView);\n  if (lineView.text == lineView.node) { lineView.node = built.pre; }\n  lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n  lineView.text = built.pre;\n  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n    lineView.bgClass = built.bgClass;\n    lineView.textClass = built.textClass;\n    updateLineClasses(cm, lineView);\n  } else if (cls) {\n    lineView.text.className = cls;\n  }\n}\n\nfunction updateLineClasses(cm, lineView) {\n  updateLineBackground(cm, lineView);\n  if (lineView.line.wrapClass)\n    { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\n  else if (lineView.node != lineView.text)\n    { lineView.node.className = \"\"; }\n  var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n  lineView.text.className = textClass || \"\";\n}\n\nfunction updateLineGutter(cm, lineView, lineN, dims) {\n  if (lineView.gutter) {\n    lineView.node.removeChild(lineView.gutter);\n    lineView.gutter = null;\n  }\n  if (lineView.gutterBackground) {\n    lineView.node.removeChild(lineView.gutterBackground);\n    lineView.gutterBackground = null;\n  }\n  if (lineView.line.gutterClass) {\n    var wrap = ensureLineWrapped(lineView);\n    lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                    (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\n    cm.display.input.setUneditable(lineView.gutterBackground);\n    wrap.insertBefore(lineView.gutterBackground, lineView.text);\n  }\n  var markers = lineView.line.gutterMarkers;\n  if (cm.options.lineNumbers || markers) {\n    var wrap$1 = ensureLineWrapped(lineView);\n    var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\n    cm.display.input.setUneditable(gutterWrap);\n    wrap$1.insertBefore(gutterWrap, lineView.text);\n    if (lineView.line.gutterClass)\n      { gutterWrap.className += \" \" + lineView.line.gutterClass; }\n    if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n      { lineView.lineNumber = gutterWrap.appendChild(\n        elt(\"div\", lineNumberFor(cm.options, lineN),\n            \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n            (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\n    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {\n      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n      if (found)\n        { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\n                                   (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\n    } }\n  }\n}\n\nfunction updateLineWidgets(cm, lineView, dims) {\n  if (lineView.alignable) { lineView.alignable = null; }\n  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\n    next = node.nextSibling;\n    if (node.className == \"CodeMirror-linewidget\")\n      { lineView.node.removeChild(node); }\n  }\n  insertLineWidgets(cm, lineView, dims);\n}\n\n// Build a line's DOM representation from scratch\nfunction buildLineElement(cm, lineView, lineN, dims) {\n  var built = getLineContent(cm, lineView);\n  lineView.text = lineView.node = built.pre;\n  if (built.bgClass) { lineView.bgClass = built.bgClass; }\n  if (built.textClass) { lineView.textClass = built.textClass; }\n\n  updateLineClasses(cm, lineView);\n  updateLineGutter(cm, lineView, lineN, dims);\n  insertLineWidgets(cm, lineView, dims);\n  return lineView.node\n}\n\n// A lineView may contain multiple logical lines (when merged by\n// collapsed spans). The widgets for all of them need to be drawn.\nfunction insertLineWidgets(cm, lineView, dims) {\n  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\n}\n\nfunction insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n  if (!line.widgets) { return }\n  var wrap = ensureLineWrapped(lineView);\n  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n    var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n    if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\n    positionLineWidget(widget, node, lineView, dims);\n    cm.display.input.setUneditable(node);\n    if (allowAbove && widget.above)\n      { wrap.insertBefore(node, lineView.gutter || lineView.text); }\n    else\n      { wrap.appendChild(node); }\n    signalLater(widget, \"redraw\");\n  }\n}\n\nfunction positionLineWidget(widget, node, lineView, dims) {\n  if (widget.noHScroll) {\n    (lineView.alignable || (lineView.alignable = [])).push(node);\n    var width = dims.wrapperWidth;\n    node.style.left = dims.fixedPos + \"px\";\n    if (!widget.coverGutter) {\n      width -= dims.gutterTotalWidth;\n      node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n    }\n    node.style.width = width + \"px\";\n  }\n  if (widget.coverGutter) {\n    node.style.zIndex = 5;\n    node.style.position = \"relative\";\n    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\n  }\n}\n\nfunction widgetHeight(widget) {\n  if (widget.height != null) { return widget.height }\n  var cm = widget.doc.cm;\n  if (!cm) { return 0 }\n  if (!contains(document.body, widget.node)) {\n    var parentStyle = \"position: relative;\";\n    if (widget.coverGutter)\n      { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\n    if (widget.noHScroll)\n      { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\n    removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n  }\n  return widget.height = widget.node.parentNode.offsetHeight\n}\n\n// Return true when the given mouse event happened in a widget\nfunction eventInWidget(display, e) {\n  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n    if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n        (n.parentNode == display.sizer && n != display.mover))\n      { return true }\n  }\n}\n\n// POSITION MEASUREMENT\n\nfunction paddingTop(display) {return display.lineSpace.offsetTop}\nfunction paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\nfunction paddingH(display) {\n  if (display.cachedPaddingH) { return display.cachedPaddingH }\n  var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\n  return data\n}\n\nfunction scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\nfunction displayWidth(cm) {\n  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\n}\nfunction displayHeight(cm) {\n  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\n}\n\n// Ensure the lineView.wrapping.heights array is populated. This is\n// an array of bottom offsets for the lines that make up a drawn\n// line. When lineWrapping is on, there might be more than one\n// height.\nfunction ensureLineHeights(cm, lineView, rect) {\n  var wrapping = cm.options.lineWrapping;\n  var curWidth = wrapping && displayWidth(cm);\n  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n    var heights = lineView.measure.heights = [];\n    if (wrapping) {\n      lineView.measure.width = curWidth;\n      var rects = lineView.text.firstChild.getClientRects();\n      for (var i = 0; i < rects.length - 1; i++) {\n        var cur = rects[i], next = rects[i + 1];\n        if (Math.abs(cur.bottom - next.bottom) > 2)\n          { heights.push((cur.bottom + next.top) / 2 - rect.top); }\n      }\n    }\n    heights.push(rect.bottom - rect.top);\n  }\n}\n\n// Find a line map (mapping character offsets to text nodes) and a\n// measurement cache for the given line number. (A line view might\n// contain multiple lines when collapsed ranges are present.)\nfunction mapFromLineView(lineView, line, lineN) {\n  if (lineView.line == line)\n    { return {map: lineView.measure.map, cache: lineView.measure.cache} }\n  for (var i = 0; i < lineView.rest.length; i++)\n    { if (lineView.rest[i] == line)\n      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\n  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\n    { if (lineNo(lineView.rest[i$1]) > lineN)\n      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\n}\n\n// Render a line into the hidden node display.externalMeasured. Used\n// when measurement is needed for a line that's not in the viewport.\nfunction updateExternalMeasurement(cm, line) {\n  line = visualLine(line);\n  var lineN = lineNo(line);\n  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n  view.lineN = lineN;\n  var built = view.built = buildLineContent(cm, view);\n  view.text = built.pre;\n  removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n  return view\n}\n\n// Get a {top, bottom, left, right} box (in line-local coordinates)\n// for a given character.\nfunction measureChar(cm, line, ch, bias) {\n  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\n}\n\n// Find a line view that corresponds to the given line number.\nfunction findViewForLine(cm, lineN) {\n  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n    { return cm.display.view[findViewIndex(cm, lineN)] }\n  var ext = cm.display.externalMeasured;\n  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n    { return ext }\n}\n\n// Measurement can be split in two steps, the set-up work that\n// applies to the whole line, and the measurement of the actual\n// character. Functions like coordsChar, that need to do a lot of\n// measurements in a row, can thus ensure that the set-up work is\n// only done once.\nfunction prepareMeasureForLine(cm, line) {\n  var lineN = lineNo(line);\n  var view = findViewForLine(cm, lineN);\n  if (view && !view.text) {\n    view = null;\n  } else if (view && view.changes) {\n    updateLineForChanges(cm, view, lineN, getDimensions(cm));\n    cm.curOp.forceUpdate = true;\n  }\n  if (!view)\n    { view = updateExternalMeasurement(cm, line); }\n\n  var info = mapFromLineView(view, line, lineN);\n  return {\n    line: line, view: view, rect: null,\n    map: info.map, cache: info.cache, before: info.before,\n    hasHeights: false\n  }\n}\n\n// Given a prepared measurement object, measures the position of an\n// actual character (or fetches it from the cache).\nfunction measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n  if (prepared.before) { ch = -1; }\n  var key = ch + (bias || \"\"), found;\n  if (prepared.cache.hasOwnProperty(key)) {\n    found = prepared.cache[key];\n  } else {\n    if (!prepared.rect)\n      { prepared.rect = prepared.view.text.getBoundingClientRect(); }\n    if (!prepared.hasHeights) {\n      ensureLineHeights(cm, prepared.view, prepared.rect);\n      prepared.hasHeights = true;\n    }\n    found = measureCharInner(cm, prepared, ch, bias);\n    if (!found.bogus) { prepared.cache[key] = found; }\n  }\n  return {left: found.left, right: found.right,\n          top: varHeight ? found.rtop : found.top,\n          bottom: varHeight ? found.rbottom : found.bottom}\n}\n\nvar nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\nfunction nodeAndOffsetInLineMap(map$$1, ch, bias) {\n  var node, start, end, collapse, mStart, mEnd;\n  // First, search the line map for the text node corresponding to,\n  // or closest to, the target character.\n  for (var i = 0; i < map$$1.length; i += 3) {\n    mStart = map$$1[i];\n    mEnd = map$$1[i + 1];\n    if (ch < mStart) {\n      start = 0; end = 1;\n      collapse = \"left\";\n    } else if (ch < mEnd) {\n      start = ch - mStart;\n      end = start + 1;\n    } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {\n      end = mEnd - mStart;\n      start = end - 1;\n      if (ch >= mEnd) { collapse = \"right\"; }\n    }\n    if (start != null) {\n      node = map$$1[i + 2];\n      if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n        { collapse = bias; }\n      if (bias == \"left\" && start == 0)\n        { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {\n          node = map$$1[(i -= 3) + 2];\n          collapse = \"left\";\n        } }\n      if (bias == \"right\" && start == mEnd - mStart)\n        { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {\n          node = map$$1[(i += 3) + 2];\n          collapse = \"right\";\n        } }\n      break\n    }\n  }\n  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\n}\n\nfunction getUsefulRect(rects, bias) {\n  var rect = nullRect;\n  if (bias == \"left\") { for (var i = 0; i < rects.length; i++) {\n    if ((rect = rects[i]).left != rect.right) { break }\n  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n    if ((rect = rects[i$1]).left != rect.right) { break }\n  } }\n  return rect\n}\n\nfunction measureCharInner(cm, prepared, ch, bias) {\n  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n  var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n  var rect;\n  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\n      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\n      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n        { rect = node.parentNode.getBoundingClientRect(); }\n      else\n        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\n      if (rect.left || rect.right || start == 0) { break }\n      end = start;\n      start = start - 1;\n      collapse = \"right\";\n    }\n    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\n  } else { // If it is a widget, simply get the box for the whole widget.\n    if (start > 0) { collapse = bias = \"right\"; }\n    var rects;\n    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n      { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\n    else\n      { rect = node.getBoundingClientRect(); }\n  }\n  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n    var rSpan = node.parentNode.getClientRects()[0];\n    if (rSpan)\n      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\n    else\n      { rect = nullRect; }\n  }\n\n  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n  var mid = (rtop + rbot) / 2;\n  var heights = prepared.view.measure.heights;\n  var i = 0;\n  for (; i < heights.length - 1; i++)\n    { if (mid < heights[i]) { break } }\n  var top = i ? heights[i - 1] : 0, bot = heights[i];\n  var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                top: top, bottom: bot};\n  if (!rect.left && !rect.right) { result.bogus = true; }\n  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n  return result\n}\n\n// Work around problem with bounding client rects on ranges being\n// returned incorrectly when zoomed on IE10 and below.\nfunction maybeUpdateRectForZooming(measure, rect) {\n  if (!window.screen || screen.logicalXDPI == null ||\n      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n    { return rect }\n  var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n  var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n  return {left: rect.left * scaleX, right: rect.right * scaleX,\n          top: rect.top * scaleY, bottom: rect.bottom * scaleY}\n}\n\nfunction clearLineMeasurementCacheFor(lineView) {\n  if (lineView.measure) {\n    lineView.measure.cache = {};\n    lineView.measure.heights = null;\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n      { lineView.measure.caches[i] = {}; } }\n  }\n}\n\nfunction clearLineMeasurementCache(cm) {\n  cm.display.externalMeasure = null;\n  removeChildren(cm.display.lineMeasure);\n  for (var i = 0; i < cm.display.view.length; i++)\n    { clearLineMeasurementCacheFor(cm.display.view[i]); }\n}\n\nfunction clearCaches(cm) {\n  clearLineMeasurementCache(cm);\n  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\n  cm.display.lineNumChars = null;\n}\n\nfunction pageScrollX() {\n  // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n  // which causes page_Offset and bounding client rects to use\n  // different reference viewports and invalidate our calculations.\n  if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\n  return window.pageXOffset || (document.documentElement || document.body).scrollLeft\n}\nfunction pageScrollY() {\n  if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\n  return window.pageYOffset || (document.documentElement || document.body).scrollTop\n}\n\n// Converts a {top, bottom, left, right} box from line-local\n// coordinates into another coordinate system. Context may be one of\n// \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n// or \"page\".\nfunction intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n  if (!includeWidgets && lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above) {\n    var size = widgetHeight(lineObj.widgets[i]);\n    rect.top += size; rect.bottom += size;\n  } } }\n  if (context == \"line\") { return rect }\n  if (!context) { context = \"local\"; }\n  var yOff = heightAtLine(lineObj);\n  if (context == \"local\") { yOff += paddingTop(cm.display); }\n  else { yOff -= cm.display.viewOffset; }\n  if (context == \"page\" || context == \"window\") {\n    var lOff = cm.display.lineSpace.getBoundingClientRect();\n    yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n    var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n    rect.left += xOff; rect.right += xOff;\n  }\n  rect.top += yOff; rect.bottom += yOff;\n  return rect\n}\n\n// Coverts a box from \"div\" coords to another coordinate system.\n// Context may be \"window\", \"page\", \"div\", or \"local\"./null.\nfunction fromCoordSystem(cm, coords, context) {\n  if (context == \"div\") { return coords }\n  var left = coords.left, top = coords.top;\n  // First move into \"page\" coordinate system\n  if (context == \"page\") {\n    left -= pageScrollX();\n    top -= pageScrollY();\n  } else if (context == \"local\" || !context) {\n    var localBox = cm.display.sizer.getBoundingClientRect();\n    left += localBox.left;\n    top += localBox.top;\n  }\n\n  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\n}\n\nfunction charCoords(cm, pos, context, lineObj, bias) {\n  if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\n  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\n}\n\n// Returns a box for a given cursor position, which may have an\n// 'other' property containing the position of the secondary cursor\n// on a bidi boundary.\n// A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n// and after `char - 1` in writing order of `char - 1`\n// A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n// and before `char` in writing order of `char`\n// Examples (upper-case letters are RTL, lower-case are LTR):\n//     Pos(0, 1, ...)\n//     before   after\n// ab     a|b     a|b\n// aB     a|B     aB|\n// Ab     |Ab     A|b\n// AB     B|A     B|A\n// Every position after the last character on a line is considered to stick\n// to the last character on the line.\nfunction cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n  lineObj = lineObj || getLine(cm.doc, pos.line);\n  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n  function get(ch, right) {\n    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n    if (right) { m.left = m.right; } else { m.right = m.left; }\n    return intoCoordSystem(cm, lineObj, m, context)\n  }\n  var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n  if (ch >= lineObj.text.length) {\n    ch = lineObj.text.length;\n    sticky = \"before\";\n  } else if (ch <= 0) {\n    ch = 0;\n    sticky = \"after\";\n  }\n  if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\n\n  function getBidi(ch, partPos, invert) {\n    var part = order[partPos], right = (part.level % 2) != 0;\n    return get(invert ? ch - 1 : ch, right != invert)\n  }\n  var partPos = getBidiPartAt(order, ch, sticky);\n  var other = bidiOther;\n  var val = getBidi(ch, partPos, sticky == \"before\");\n  if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\n  return val\n}\n\n// Used to cheaply estimate the coordinates for a position. Used for\n// intermediate scroll updates.\nfunction estimateCoords(cm, pos) {\n  var left = 0;\n  pos = clipPos(cm.doc, pos);\n  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\n  var lineObj = getLine(cm.doc, pos.line);\n  var top = heightAtLine(lineObj) + paddingTop(cm.display);\n  return {left: left, right: left, top: top, bottom: top + lineObj.height}\n}\n\n// Positions returned by coordsChar contain some extra information.\n// xRel is the relative x position of the input coordinates compared\n// to the found position (so xRel > 0 means the coordinates are to\n// the right of the character position, for example). When outside\n// is true, that means the coordinates lie outside the line's\n// vertical range.\nfunction PosWithInfo(line, ch, sticky, outside, xRel) {\n  var pos = Pos(line, ch, sticky);\n  pos.xRel = xRel;\n  if (outside) { pos.outside = true; }\n  return pos\n}\n\n// Compute the character position closest to the given coordinates.\n// Input must be lineSpace-local (\"div\" coordinate system).\nfunction coordsChar(cm, x, y) {\n  var doc = cm.doc;\n  y += cm.display.viewOffset;\n  if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }\n  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n  if (lineN > last)\n    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }\n  if (x < 0) { x = 0; }\n\n  var lineObj = getLine(doc, lineN);\n  for (;;) {\n    var found = coordsCharInner(cm, lineObj, lineN, x, y);\n    var merged = collapsedSpanAtEnd(lineObj);\n    var mergedPos = merged && merged.find(0, true);\n    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n      { lineN = lineNo(lineObj = mergedPos.to.line); }\n    else\n      { return found }\n  }\n}\n\nfunction wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n  var measure = function (ch) { return intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), \"line\"); };\n  var end = lineObj.text.length;\n  var begin = findFirst(function (ch) { return measure(ch - 1).bottom <= y; }, end, 0);\n  end = findFirst(function (ch) { return measure(ch).top > y; }, begin, end);\n  return {begin: begin, end: end}\n}\n\nfunction wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n  var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\n}\n\nfunction coordsCharInner(cm, lineObj, lineNo$$1, x, y) {\n  y -= heightAtLine(lineObj);\n  var begin = 0, end = lineObj.text.length;\n  var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n  var pos;\n  var order = getOrder(lineObj, cm.doc.direction);\n  if (order) {\n    if (cm.options.lineWrapping) {\n      var assign;\n      ((assign = wrappedLineExtent(cm, lineObj, preparedMeasure, y), begin = assign.begin, end = assign.end, assign));\n    }\n    pos = new Pos(lineNo$$1, Math.floor(begin + (end - begin) / 2));\n    var beginLeft = cursorCoords(cm, pos, \"line\", lineObj, preparedMeasure).left;\n    var dir = beginLeft < x ? 1 : -1;\n    var prevDiff, diff = beginLeft - x, prevPos;\n    var steps = Math.ceil((end - begin) / 4);\n    outer: do {\n      prevDiff = diff;\n      prevPos = pos;\n      var i = 0;\n      for (; i < steps; ++i) {\n        var prevPos$1 = pos;\n        pos = moveVisually(cm, lineObj, pos, dir);\n        if (pos == null || pos.ch < begin || end <= (pos.sticky == \"before\" ? pos.ch - 1 : pos.ch)) {\n          pos = prevPos$1;\n          break outer\n        }\n      }\n      diff = cursorCoords(cm, pos, \"line\", lineObj, preparedMeasure).left - x;\n      if (steps > 1) {\n        var diff_change_per_step = Math.abs(diff - prevDiff) / steps;\n        steps = Math.min(steps, Math.ceil(Math.abs(diff) / diff_change_per_step));\n        dir = diff < 0 ? 1 : -1;\n      }\n    } while (diff != 0 && (steps > 1 || ((dir < 0) != (diff < 0) && (Math.abs(diff) <= Math.abs(prevDiff)))))\n    if (Math.abs(diff) > Math.abs(prevDiff)) {\n      if ((diff < 0) == (prevDiff < 0)) { throw new Error(\"Broke out of infinite loop in coordsCharInner\") }\n      pos = prevPos;\n    }\n  } else {\n    var ch = findFirst(function (ch) {\n      var box = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), \"line\");\n      if (box.top > y) {\n        // For the cursor stickiness\n        end = Math.min(ch, end);\n        return true\n      }\n      else if (box.bottom <= y) { return false }\n      else if (box.left > x) { return true }\n      else if (box.right < x) { return false }\n      else { return (x - box.left < box.right - x) }\n    }, begin, end);\n    ch = skipExtendingChars(lineObj.text, ch, 1);\n    pos = new Pos(lineNo$$1, ch, ch == end ? \"before\" : \"after\");\n  }\n  var coords = cursorCoords(cm, pos, \"line\", lineObj, preparedMeasure);\n  if (y < coords.top || coords.bottom < y) { pos.outside = true; }\n  pos.xRel = x < coords.left ? -1 : (x > coords.right ? 1 : 0);\n  return pos\n}\n\nvar measureText;\n// Compute the default text height.\nfunction textHeight(display) {\n  if (display.cachedTextHeight != null) { return display.cachedTextHeight }\n  if (measureText == null) {\n    measureText = elt(\"pre\");\n    // Measure a bunch of lines, for browsers that compute\n    // fractional heights.\n    for (var i = 0; i < 49; ++i) {\n      measureText.appendChild(document.createTextNode(\"x\"));\n      measureText.appendChild(elt(\"br\"));\n    }\n    measureText.appendChild(document.createTextNode(\"x\"));\n  }\n  removeChildrenAndAdd(display.measure, measureText);\n  var height = measureText.offsetHeight / 50;\n  if (height > 3) { display.cachedTextHeight = height; }\n  removeChildren(display.measure);\n  return height || 1\n}\n\n// Compute the default character width.\nfunction charWidth(display) {\n  if (display.cachedCharWidth != null) { return display.cachedCharWidth }\n  var anchor = elt(\"span\", \"xxxxxxxxxx\");\n  var pre = elt(\"pre\", [anchor]);\n  removeChildrenAndAdd(display.measure, pre);\n  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n  if (width > 2) { display.cachedCharWidth = width; }\n  return width || 10\n}\n\n// Do a bulk-read of the DOM positions and sizes needed to draw the\n// view, so that we don't interleave reading and writing to the DOM.\nfunction getDimensions(cm) {\n  var d = cm.display, left = {}, width = {};\n  var gutterLeft = d.gutters.clientLeft;\n  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n    width[cm.options.gutters[i]] = n.clientWidth;\n  }\n  return {fixedPos: compensateForHScroll(d),\n          gutterTotalWidth: d.gutters.offsetWidth,\n          gutterLeft: left,\n          gutterWidth: width,\n          wrapperWidth: d.wrapper.clientWidth}\n}\n\n// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n// but using getBoundingClientRect to get a sub-pixel-accurate\n// result.\nfunction compensateForHScroll(display) {\n  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\n}\n\n// Returns a function that estimates the height of a line, to use as\n// first approximation until the line becomes visible (and is thus\n// properly measurable).\nfunction estimateHeight(cm) {\n  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n  return function (line) {\n    if (lineIsHidden(cm.doc, line)) { return 0 }\n\n    var widgetsHeight = 0;\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\n      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\n    } }\n\n    if (wrapping)\n      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\n    else\n      { return widgetsHeight + th }\n  }\n}\n\nfunction estimateLineHeights(cm) {\n  var doc = cm.doc, est = estimateHeight(cm);\n  doc.iter(function (line) {\n    var estHeight = est(line);\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n  });\n}\n\n// Given a mouse event, find the corresponding position. If liberal\n// is false, it checks whether a gutter or scrollbar was clicked,\n// and returns null if it was. forRect is used by rectangular\n// selections, and tries to estimate a character position even for\n// coordinates beyond the right of the text.\nfunction posFromMouse(cm, e, liberal, forRect) {\n  var display = cm.display;\n  if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\n\n  var x, y, space = display.lineSpace.getBoundingClientRect();\n  // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n  try { x = e.clientX - space.left; y = e.clientY - space.top; }\n  catch (e) { return null }\n  var coords = coordsChar(cm, x, y), line;\n  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n  }\n  return coords\n}\n\n// Find the view element corresponding to a given line. Return null\n// when the line isn't visible.\nfunction findViewIndex(cm, n) {\n  if (n >= cm.display.viewTo) { return null }\n  n -= cm.display.viewFrom;\n  if (n < 0) { return null }\n  var view = cm.display.view;\n  for (var i = 0; i < view.length; i++) {\n    n -= view[i].size;\n    if (n < 0) { return i }\n  }\n}\n\nfunction updateSelection(cm) {\n  cm.display.input.showSelection(cm.display.input.prepareSelection());\n}\n\nfunction prepareSelection(cm, primary) {\n  var doc = cm.doc, result = {};\n  var curFragment = result.cursors = document.createDocumentFragment();\n  var selFragment = result.selection = document.createDocumentFragment();\n\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\n    if (primary === false && i == doc.sel.primIndex) { continue }\n    var range$$1 = doc.sel.ranges[i];\n    if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }\n    var collapsed = range$$1.empty();\n    if (collapsed || cm.options.showCursorWhenSelecting)\n      { drawSelectionCursor(cm, range$$1.head, curFragment); }\n    if (!collapsed)\n      { drawSelectionRange(cm, range$$1, selFragment); }\n  }\n  return result\n}\n\n// Draws a cursor for the given range\nfunction drawSelectionCursor(cm, head, output) {\n  var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n  var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n  cursor.style.left = pos.left + \"px\";\n  cursor.style.top = pos.top + \"px\";\n  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n  if (pos.other) {\n    // Secondary cursor, shown when on a 'jump' in bi-directional text\n    var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n    otherCursor.style.display = \"\";\n    otherCursor.style.left = pos.other.left + \"px\";\n    otherCursor.style.top = pos.other.top + \"px\";\n    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n  }\n}\n\n// Draws the given range as a highlighted selection\nfunction drawSelectionRange(cm, range$$1, output) {\n  var display = cm.display, doc = cm.doc;\n  var fragment = document.createDocumentFragment();\n  var padding = paddingH(cm.display), leftSide = padding.left;\n  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n\n  function add(left, top, width, bottom) {\n    if (top < 0) { top = 0; }\n    top = Math.round(top);\n    bottom = Math.round(bottom);\n    fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\n  }\n\n  function drawForLine(line, fromArg, toArg) {\n    var lineObj = getLine(doc, line);\n    var lineLen = lineObj.text.length;\n    var start, end;\n    function coords(ch, bias) {\n      return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\n    }\n\n    iterateBidiSections(getOrder(lineObj, doc.direction), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {\n      var leftPos = coords(from, \"left\"), rightPos, left, right;\n      if (from == to) {\n        rightPos = leftPos;\n        left = right = leftPos.left;\n      } else {\n        rightPos = coords(to - 1, \"right\");\n        if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n        left = leftPos.left;\n        right = rightPos.right;\n      }\n      if (fromArg == null && from == 0) { left = leftSide; }\n      if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n        add(left, leftPos.top, null, leftPos.bottom);\n        left = leftSide;\n        if (leftPos.bottom < rightPos.top) { add(left, leftPos.bottom, null, rightPos.top); }\n      }\n      if (toArg == null && to == lineLen) { right = rightSide; }\n      if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n        { start = leftPos; }\n      if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n        { end = rightPos; }\n      if (left < leftSide + 1) { left = leftSide; }\n      add(left, rightPos.top, right - left, rightPos.bottom);\n    });\n    return {start: start, end: end}\n  }\n\n  var sFrom = range$$1.from(), sTo = range$$1.to();\n  if (sFrom.line == sTo.line) {\n    drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n  } else {\n    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n    var singleVLine = visualLine(fromLine) == visualLine(toLine);\n    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n    if (singleVLine) {\n      if (leftEnd.top < rightStart.top - 2) {\n        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n      } else {\n        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n      }\n    }\n    if (leftEnd.bottom < rightStart.top)\n      { add(leftSide, leftEnd.bottom, null, rightStart.top); }\n  }\n\n  output.appendChild(fragment);\n}\n\n// Cursor-blinking\nfunction restartBlink(cm) {\n  if (!cm.state.focused) { return }\n  var display = cm.display;\n  clearInterval(display.blinker);\n  var on = true;\n  display.cursorDiv.style.visibility = \"\";\n  if (cm.options.cursorBlinkRate > 0)\n    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\"; },\n      cm.options.cursorBlinkRate); }\n  else if (cm.options.cursorBlinkRate < 0)\n    { display.cursorDiv.style.visibility = \"hidden\"; }\n}\n\nfunction ensureFocus(cm) {\n  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n}\n\nfunction delayBlurEvent(cm) {\n  cm.state.delayingBlurEvent = true;\n  setTimeout(function () { if (cm.state.delayingBlurEvent) {\n    cm.state.delayingBlurEvent = false;\n    onBlur(cm);\n  } }, 100);\n}\n\nfunction onFocus(cm, e) {\n  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }\n\n  if (cm.options.readOnly == \"nocursor\") { return }\n  if (!cm.state.focused) {\n    signal(cm, \"focus\", cm, e);\n    cm.state.focused = true;\n    addClass(cm.display.wrapper, \"CodeMirror-focused\");\n    // This test prevents this from firing when a context\n    // menu is closed (since the input reset would kill the\n    // select-all detection hack)\n    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n      cm.display.input.reset();\n      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\n    }\n    cm.display.input.receivedFocus();\n  }\n  restartBlink(cm);\n}\nfunction onBlur(cm, e) {\n  if (cm.state.delayingBlurEvent) { return }\n\n  if (cm.state.focused) {\n    signal(cm, \"blur\", cm, e);\n    cm.state.focused = false;\n    rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n  }\n  clearInterval(cm.display.blinker);\n  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\n}\n\n// Read the actual heights of the rendered lines, and update their\n// stored heights to match.\nfunction updateHeightsInViewport(cm) {\n  var display = cm.display;\n  var prevBottom = display.lineDiv.offsetTop;\n  for (var i = 0; i < display.view.length; i++) {\n    var cur = display.view[i], height = (void 0);\n    if (cur.hidden) { continue }\n    if (ie && ie_version < 8) {\n      var bot = cur.node.offsetTop + cur.node.offsetHeight;\n      height = bot - prevBottom;\n      prevBottom = bot;\n    } else {\n      var box = cur.node.getBoundingClientRect();\n      height = box.bottom - box.top;\n    }\n    var diff = cur.line.height - height;\n    if (height < 2) { height = textHeight(display); }\n    if (diff > .005 || diff < -.005) {\n      updateLineHeight(cur.line, height);\n      updateWidgetHeight(cur.line);\n      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\n        { updateWidgetHeight(cur.rest[j]); } }\n    }\n  }\n}\n\n// Read and store the height of line widgets associated with the\n// given line.\nfunction updateWidgetHeight(line) {\n  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i)\n    { line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight; } }\n}\n\n// Compute the lines that are visible in a given viewport (defaults\n// the the current scroll position). viewport may contain top,\n// height, and ensure (see op.scrollToPos) properties.\nfunction visibleLines(display, doc, viewport) {\n  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n  top = Math.floor(top - paddingTop(display));\n  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n  // forces those lines into the viewport (if possible).\n  if (viewport && viewport.ensure) {\n    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n    if (ensureFrom < from) {\n      from = ensureFrom;\n      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n      to = ensureTo;\n    }\n  }\n  return {from: from, to: Math.max(to, from + 1)}\n}\n\n// Re-align line numbers and gutter marks to compensate for\n// horizontal scrolling.\nfunction alignHorizontally(cm) {\n  var display = cm.display, view = display.view;\n  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\n  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n  var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\n    if (cm.options.fixedGutter) {\n      if (view[i].gutter)\n        { view[i].gutter.style.left = left; }\n      if (view[i].gutterBackground)\n        { view[i].gutterBackground.style.left = left; }\n    }\n    var align = view[i].alignable;\n    if (align) { for (var j = 0; j < align.length; j++)\n      { align[j].style.left = left; } }\n  } }\n  if (cm.options.fixedGutter)\n    { display.gutters.style.left = (comp + gutterW) + \"px\"; }\n}\n\n// Used to ensure that the line number gutter is still the right\n// size for the current document size. Returns true when an update\n// is needed.\nfunction maybeUpdateLineNumberWidth(cm) {\n  if (!cm.options.lineNumbers) { return false }\n  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n  if (last.length != display.lineNumChars) {\n    var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                               \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n    display.lineGutter.style.width = \"\";\n    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n    display.lineNumWidth = display.lineNumInnerWidth + padding;\n    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n    display.lineGutter.style.width = display.lineNumWidth + \"px\";\n    updateGutterSpace(cm);\n    return true\n  }\n  return false\n}\n\n// SCROLLING THINGS INTO VIEW\n\n// If an editor sits on the top or bottom of the window, partially\n// scrolled out of view, this ensures that the cursor is visible.\nfunction maybeScrollWindow(cm, rect) {\n  if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\n\n  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n  if (rect.top + box.top < 0) { doScroll = true; }\n  else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\n  if (doScroll != null && !phantom) {\n    var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\n    cm.display.lineSpace.appendChild(scrollNode);\n    scrollNode.scrollIntoView(doScroll);\n    cm.display.lineSpace.removeChild(scrollNode);\n  }\n}\n\n// Scroll a given position into view (immediately), verifying that\n// it actually became visible (as line heights are accurately\n// measured, the position of something may 'drift' during drawing).\nfunction scrollPosIntoView(cm, pos, end, margin) {\n  if (margin == null) { margin = 0; }\n  var rect;\n  if (!cm.options.lineWrapping && pos == end) {\n    // Set pos and end to the cursor positions around the character pos sticks to\n    // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\n    // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\n    pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n    end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n  }\n  for (var limit = 0; limit < 5; limit++) {\n    var changed = false;\n    var coords = cursorCoords(cm, pos);\n    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n    rect = {left: Math.min(coords.left, endCoords.left),\n            top: Math.min(coords.top, endCoords.top) - margin,\n            right: Math.max(coords.left, endCoords.left),\n            bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\n    var scrollPos = calculateScrollPos(cm, rect);\n    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n    if (scrollPos.scrollTop != null) {\n      updateScrollTop(cm, scrollPos.scrollTop);\n      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\n    }\n    if (scrollPos.scrollLeft != null) {\n      setScrollLeft(cm, scrollPos.scrollLeft);\n      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\n    }\n    if (!changed) { break }\n  }\n  return rect\n}\n\n// Scroll a given set of coordinates into view (immediately).\nfunction scrollIntoView(cm, rect) {\n  var scrollPos = calculateScrollPos(cm, rect);\n  if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\n  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\n}\n\n// Calculate a new scroll position needed to scroll the given\n// rectangle into view. Returns an object with scrollTop and\n// scrollLeft properties. When these are undefined, the\n// vertical/horizontal position does not need to be adjusted.\nfunction calculateScrollPos(cm, rect) {\n  var display = cm.display, snapMargin = textHeight(cm.display);\n  if (rect.top < 0) { rect.top = 0; }\n  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n  var screen = displayHeight(cm), result = {};\n  if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\n  var docBottom = cm.doc.height + paddingVert(display);\n  var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n  if (rect.top < screentop) {\n    result.scrollTop = atTop ? 0 : rect.top;\n  } else if (rect.bottom > screentop + screen) {\n    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n    if (newTop != screentop) { result.scrollTop = newTop; }\n  }\n\n  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n  var tooWide = rect.right - rect.left > screenw;\n  if (tooWide) { rect.right = rect.left + screenw; }\n  if (rect.left < 10)\n    { result.scrollLeft = 0; }\n  else if (rect.left < screenleft)\n    { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }\n  else if (rect.right > screenw + screenleft - 3)\n    { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\n  return result\n}\n\n// Store a relative adjustment to the scroll position in the current\n// operation (to be applied when the operation finishes).\nfunction addToScrollTop(cm, top) {\n  if (top == null) { return }\n  resolveScrollToPos(cm);\n  cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n}\n\n// Make sure that at the end of the operation the current cursor is\n// shown.\nfunction ensureCursorVisible(cm) {\n  resolveScrollToPos(cm);\n  var cur = cm.getCursor();\n  cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};\n}\n\nfunction scrollToCoords(cm, x, y) {\n  if (x != null || y != null) { resolveScrollToPos(cm); }\n  if (x != null) { cm.curOp.scrollLeft = x; }\n  if (y != null) { cm.curOp.scrollTop = y; }\n}\n\nfunction scrollToRange(cm, range$$1) {\n  resolveScrollToPos(cm);\n  cm.curOp.scrollToPos = range$$1;\n}\n\n// When an operation has its scrollToPos property set, and another\n// scroll action is applied before the end of the operation, this\n// 'simulates' scrolling that position into view in a cheap way, so\n// that the effect of intermediate scroll commands is not ignored.\nfunction resolveScrollToPos(cm) {\n  var range$$1 = cm.curOp.scrollToPos;\n  if (range$$1) {\n    cm.curOp.scrollToPos = null;\n    var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);\n    scrollToCoordsRange(cm, from, to, range$$1.margin);\n  }\n}\n\nfunction scrollToCoordsRange(cm, from, to, margin) {\n  var sPos = calculateScrollPos(cm, {\n    left: Math.min(from.left, to.left),\n    top: Math.min(from.top, to.top) - margin,\n    right: Math.max(from.right, to.right),\n    bottom: Math.max(from.bottom, to.bottom) + margin\n  });\n  scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n}\n\n// Sync the scrollable area and scrollbars, ensure the viewport\n// covers the visible area.\nfunction updateScrollTop(cm, val) {\n  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\n  if (!gecko) { updateDisplaySimple(cm, {top: val}); }\n  setScrollTop(cm, val, true);\n  if (gecko) { updateDisplaySimple(cm); }\n  startWorker(cm, 100);\n}\n\nfunction setScrollTop(cm, val, forceScroll) {\n  val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);\n  if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\n  cm.doc.scrollTop = val;\n  cm.display.scrollbars.setScrollTop(val);\n  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\n}\n\n// Sync scroller and scrollbar, ensure the gutter elements are\n// aligned.\nfunction setScrollLeft(cm, val, isScroller, forceScroll) {\n  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n  if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\n  cm.doc.scrollLeft = val;\n  alignHorizontally(cm);\n  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\n  cm.display.scrollbars.setScrollLeft(val);\n}\n\n// SCROLLBARS\n\n// Prepare DOM reads needed to update the scrollbars. Done in one\n// shot to minimize update/measure roundtrips.\nfunction measureForScrollbars(cm) {\n  var d = cm.display, gutterW = d.gutters.offsetWidth;\n  var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n  return {\n    clientHeight: d.scroller.clientHeight,\n    viewHeight: d.wrapper.clientHeight,\n    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n    viewWidth: d.wrapper.clientWidth,\n    barLeft: cm.options.fixedGutter ? gutterW : 0,\n    docHeight: docH,\n    scrollHeight: docH + scrollGap(cm) + d.barHeight,\n    nativeBarWidth: d.nativeBarWidth,\n    gutterWidth: gutterW\n  }\n}\n\nvar NativeScrollbars = function(place, scroll, cm) {\n  this.cm = cm;\n  var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n  var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n  place(vert); place(horiz);\n\n  on(vert, \"scroll\", function () {\n    if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\n  });\n  on(horiz, \"scroll\", function () {\n    if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\n  });\n\n  this.checkedZeroWidth = false;\n  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\n};\n\nNativeScrollbars.prototype.update = function (measure) {\n  var needsH = measure.scrollWidth > measure.clientWidth + 1;\n  var needsV = measure.scrollHeight > measure.clientHeight + 1;\n  var sWidth = measure.nativeBarWidth;\n\n  if (needsV) {\n    this.vert.style.display = \"block\";\n    this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n    // A bug in IE8 can cause this value to be negative, so guard it.\n    this.vert.firstChild.style.height =\n      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n  } else {\n    this.vert.style.display = \"\";\n    this.vert.firstChild.style.height = \"0\";\n  }\n\n  if (needsH) {\n    this.horiz.style.display = \"block\";\n    this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n    this.horiz.style.left = measure.barLeft + \"px\";\n    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n    this.horiz.firstChild.style.width =\n      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n  } else {\n    this.horiz.style.display = \"\";\n    this.horiz.firstChild.style.width = \"0\";\n  }\n\n  if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n    if (sWidth == 0) { this.zeroWidthHack(); }\n    this.checkedZeroWidth = true;\n  }\n\n  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\n};\n\nNativeScrollbars.prototype.setScrollLeft = function (pos) {\n  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\n  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\n};\n\nNativeScrollbars.prototype.setScrollTop = function (pos) {\n  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\n  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\n};\n\nNativeScrollbars.prototype.zeroWidthHack = function () {\n  var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n  this.horiz.style.height = this.vert.style.width = w;\n  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n  this.disableHoriz = new Delayed;\n  this.disableVert = new Delayed;\n};\n\nNativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n  bar.style.pointerEvents = \"auto\";\n  function maybeDisable() {\n    // To find out whether the scrollbar is still visible, we\n    // check whether the element under the pixel in the bottom\n    // right corner of the scrollbar box is the scrollbar box\n    // itself (when the bar is still visible) or its filler child\n    // (when the bar is hidden). If it is still visible, we keep\n    // it enabled, if it's hidden, we disable pointer events.\n    var box = bar.getBoundingClientRect();\n    var elt$$1 = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\n        : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n    if (elt$$1 != bar) { bar.style.pointerEvents = \"none\"; }\n    else { delay.set(1000, maybeDisable); }\n  }\n  delay.set(1000, maybeDisable);\n};\n\nNativeScrollbars.prototype.clear = function () {\n  var parent = this.horiz.parentNode;\n  parent.removeChild(this.horiz);\n  parent.removeChild(this.vert);\n};\n\nvar NullScrollbars = function () {};\n\nNullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\nNullScrollbars.prototype.setScrollLeft = function () {};\nNullScrollbars.prototype.setScrollTop = function () {};\nNullScrollbars.prototype.clear = function () {};\n\nfunction updateScrollbars(cm, measure) {\n  if (!measure) { measure = measureForScrollbars(cm); }\n  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n  updateScrollbarsInner(cm, measure);\n  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n      { updateHeightsInViewport(cm); }\n    updateScrollbarsInner(cm, measureForScrollbars(cm));\n    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n  }\n}\n\n// Re-synchronize the fake scrollbars with the actual size of the\n// content.\nfunction updateScrollbarsInner(cm, measure) {\n  var d = cm.display;\n  var sizes = d.scrollbars.update(measure);\n\n  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n  d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n  if (sizes.right && sizes.bottom) {\n    d.scrollbarFiller.style.display = \"block\";\n    d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n    d.scrollbarFiller.style.width = sizes.right + \"px\";\n  } else { d.scrollbarFiller.style.display = \"\"; }\n  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n    d.gutterFiller.style.display = \"block\";\n    d.gutterFiller.style.height = sizes.bottom + \"px\";\n    d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n  } else { d.gutterFiller.style.display = \"\"; }\n}\n\nvar scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\nfunction initScrollbars(cm) {\n  if (cm.display.scrollbars) {\n    cm.display.scrollbars.clear();\n    if (cm.display.scrollbars.addClass)\n      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n  }\n\n  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n    // Prevent clicks in the scrollbars from killing focus\n    on(node, \"mousedown\", function () {\n      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\n    });\n    node.setAttribute(\"cm-not-content\", \"true\");\n  }, function (pos, axis) {\n    if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\n    else { updateScrollTop(cm, pos); }\n  }, cm);\n  if (cm.display.scrollbars.addClass)\n    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n}\n\n// Operations are used to wrap a series of changes to the editor\n// state in such a way that each change won't have to update the\n// cursor and display (which would be awkward, slow, and\n// error-prone). Instead, display updates are batched and then all\n// combined and executed at once.\n\nvar nextOpId = 0;\n// Start a new operation.\nfunction startOperation(cm) {\n  cm.curOp = {\n    cm: cm,\n    viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n    startHeight: cm.doc.height, // Used to detect need to update scrollbar\n    forceUpdate: false,      // Used to force a redraw\n    updateInput: null,       // Whether to reset the input textarea\n    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n    changeObjs: null,        // Accumulated changes, for firing change events\n    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n    selectionChanged: false, // Whether the selection needs to be redrawn\n    updateMaxLine: false,    // Set when the widest line needs to be determined anew\n    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n    scrollToPos: null,       // Used to scroll to a specific position\n    focus: false,\n    id: ++nextOpId           // Unique ID\n  };\n  pushOperation(cm.curOp);\n}\n\n// Finish an operation, updating the display and signalling delayed events\nfunction endOperation(cm) {\n  var op = cm.curOp;\n  finishOperation(op, function (group) {\n    for (var i = 0; i < group.ops.length; i++)\n      { group.ops[i].cm.curOp = null; }\n    endOperations(group);\n  });\n}\n\n// The DOM updates done when an operation finishes are batched so\n// that the minimum number of relayouts are required.\nfunction endOperations(group) {\n  var ops = group.ops;\n  for (var i = 0; i < ops.length; i++) // Read DOM\n    { endOperation_R1(ops[i]); }\n  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n    { endOperation_W1(ops[i$1]); }\n  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n    { endOperation_R2(ops[i$2]); }\n  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n    { endOperation_W2(ops[i$3]); }\n  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n    { endOperation_finish(ops[i$4]); }\n}\n\nfunction endOperation_R1(op) {\n  var cm = op.cm, display = cm.display;\n  maybeClipScrollbars(cm);\n  if (op.updateMaxLine) { findMaxLine(cm); }\n\n  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                       op.scrollToPos.to.line >= display.viewTo) ||\n    display.maxLineChanged && cm.options.lineWrapping;\n  op.update = op.mustUpdate &&\n    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n}\n\nfunction endOperation_W1(op) {\n  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n}\n\nfunction endOperation_R2(op) {\n  var cm = op.cm, display = cm.display;\n  if (op.updatedDisplay) { updateHeightsInViewport(cm); }\n\n  op.barMeasure = measureForScrollbars(cm);\n\n  // If the max line changed since it was last measured, measure it,\n  // and ensure the document's width matches it.\n  // updateDisplay_W2 will use these properties to do the actual resizing\n  if (display.maxLineChanged && !cm.options.lineWrapping) {\n    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n    cm.display.sizerWidth = op.adjustWidthTo;\n    op.barMeasure.scrollWidth =\n      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n  }\n\n  if (op.updatedDisplay || op.selectionChanged)\n    { op.preparedSelection = display.input.prepareSelection(op.focus); }\n}\n\nfunction endOperation_W2(op) {\n  var cm = op.cm;\n\n  if (op.adjustWidthTo != null) {\n    cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n    if (op.maxScrollLeft < cm.doc.scrollLeft)\n      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\n    cm.display.maxLineChanged = false;\n  }\n\n  var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus());\n  if (op.preparedSelection)\n    { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\n  if (op.updatedDisplay || op.startHeight != cm.doc.height)\n    { updateScrollbars(cm, op.barMeasure); }\n  if (op.updatedDisplay)\n    { setDocumentHeight(cm, op.barMeasure); }\n\n  if (op.selectionChanged) { restartBlink(cm); }\n\n  if (cm.state.focused && op.updateInput)\n    { cm.display.input.reset(op.typing); }\n  if (takeFocus) { ensureFocus(op.cm); }\n}\n\nfunction endOperation_finish(op) {\n  var cm = op.cm, display = cm.display, doc = cm.doc;\n\n  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\n\n  // Abort mouse wheel delta measurement, when scrolling explicitly\n  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n    { display.wheelStartX = display.wheelStartY = null; }\n\n  // Propagate the scroll position to the actual DOM scroller\n  if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\n\n  if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\n  // If we need to scroll a specific position into view, do so.\n  if (op.scrollToPos) {\n    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                 clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n    maybeScrollWindow(cm, rect);\n  }\n\n  // Fire events for markers that are hidden/unidden by editing or\n  // undoing\n  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n  if (hidden) { for (var i = 0; i < hidden.length; ++i)\n    { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\n  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\n    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\n\n  if (display.wrapper.offsetHeight)\n    { doc.scrollTop = cm.display.scroller.scrollTop; }\n\n  // Fire change events, and delayed event handlers\n  if (op.changeObjs)\n    { signal(cm, \"changes\", cm, op.changeObjs); }\n  if (op.update)\n    { op.update.finish(); }\n}\n\n// Run the given function in an operation\nfunction runInOp(cm, f) {\n  if (cm.curOp) { return f() }\n  startOperation(cm);\n  try { return f() }\n  finally { endOperation(cm); }\n}\n// Wraps a function in an operation. Returns the wrapped function.\nfunction operation(cm, f) {\n  return function() {\n    if (cm.curOp) { return f.apply(cm, arguments) }\n    startOperation(cm);\n    try { return f.apply(cm, arguments) }\n    finally { endOperation(cm); }\n  }\n}\n// Used to add methods to editor and doc instances, wrapping them in\n// operations.\nfunction methodOp(f) {\n  return function() {\n    if (this.curOp) { return f.apply(this, arguments) }\n    startOperation(this);\n    try { return f.apply(this, arguments) }\n    finally { endOperation(this); }\n  }\n}\nfunction docMethodOp(f) {\n  return function() {\n    var cm = this.cm;\n    if (!cm || cm.curOp) { return f.apply(this, arguments) }\n    startOperation(cm);\n    try { return f.apply(this, arguments) }\n    finally { endOperation(cm); }\n  }\n}\n\n// Updates the display.view data structure for a given change to the\n// document. From and to are in pre-change coordinates. Lendiff is\n// the amount of lines added or subtracted by the change. This is\n// used for changes that span multiple lines, or change the way\n// lines are divided into visual lines. regLineChange (below)\n// registers single-line changes.\nfunction regChange(cm, from, to, lendiff) {\n  if (from == null) { from = cm.doc.first; }\n  if (to == null) { to = cm.doc.first + cm.doc.size; }\n  if (!lendiff) { lendiff = 0; }\n\n  var display = cm.display;\n  if (lendiff && to < display.viewTo &&\n      (display.updateLineNumbers == null || display.updateLineNumbers > from))\n    { display.updateLineNumbers = from; }\n\n  cm.curOp.viewChanged = true;\n\n  if (from >= display.viewTo) { // Change after\n    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n      { resetView(cm); }\n  } else if (to <= display.viewFrom) { // Change before\n    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n      resetView(cm);\n    } else {\n      display.viewFrom += lendiff;\n      display.viewTo += lendiff;\n    }\n  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n    resetView(cm);\n  } else if (from <= display.viewFrom) { // Top overlap\n    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n    if (cut) {\n      display.view = display.view.slice(cut.index);\n      display.viewFrom = cut.lineN;\n      display.viewTo += lendiff;\n    } else {\n      resetView(cm);\n    }\n  } else if (to >= display.viewTo) { // Bottom overlap\n    var cut$1 = viewCuttingPoint(cm, from, from, -1);\n    if (cut$1) {\n      display.view = display.view.slice(0, cut$1.index);\n      display.viewTo = cut$1.lineN;\n    } else {\n      resetView(cm);\n    }\n  } else { // Gap in the middle\n    var cutTop = viewCuttingPoint(cm, from, from, -1);\n    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n    if (cutTop && cutBot) {\n      display.view = display.view.slice(0, cutTop.index)\n        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n        .concat(display.view.slice(cutBot.index));\n      display.viewTo += lendiff;\n    } else {\n      resetView(cm);\n    }\n  }\n\n  var ext = display.externalMeasured;\n  if (ext) {\n    if (to < ext.lineN)\n      { ext.lineN += lendiff; }\n    else if (from < ext.lineN + ext.size)\n      { display.externalMeasured = null; }\n  }\n}\n\n// Register a change to a single line. Type must be one of \"text\",\n// \"gutter\", \"class\", \"widget\"\nfunction regLineChange(cm, line, type) {\n  cm.curOp.viewChanged = true;\n  var display = cm.display, ext = cm.display.externalMeasured;\n  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n    { display.externalMeasured = null; }\n\n  if (line < display.viewFrom || line >= display.viewTo) { return }\n  var lineView = display.view[findViewIndex(cm, line)];\n  if (lineView.node == null) { return }\n  var arr = lineView.changes || (lineView.changes = []);\n  if (indexOf(arr, type) == -1) { arr.push(type); }\n}\n\n// Clear the view.\nfunction resetView(cm) {\n  cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n  cm.display.view = [];\n  cm.display.viewOffset = 0;\n}\n\nfunction viewCuttingPoint(cm, oldN, newN, dir) {\n  var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n    { return {index: index, lineN: newN} }\n  var n = cm.display.viewFrom;\n  for (var i = 0; i < index; i++)\n    { n += view[i].size; }\n  if (n != oldN) {\n    if (dir > 0) {\n      if (index == view.length - 1) { return null }\n      diff = (n + view[index].size) - oldN;\n      index++;\n    } else {\n      diff = n - oldN;\n    }\n    oldN += diff; newN += diff;\n  }\n  while (visualLineNo(cm.doc, newN) != newN) {\n    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\n    newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n    index += dir;\n  }\n  return {index: index, lineN: newN}\n}\n\n// Force the view to cover a given range, adding empty view element\n// or clipping off existing ones as needed.\nfunction adjustView(cm, from, to) {\n  var display = cm.display, view = display.view;\n  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n    display.view = buildViewArray(cm, from, to);\n    display.viewFrom = from;\n  } else {\n    if (display.viewFrom > from)\n      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\n    else if (display.viewFrom < from)\n      { display.view = display.view.slice(findViewIndex(cm, from)); }\n    display.viewFrom = from;\n    if (display.viewTo < to)\n      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\n    else if (display.viewTo > to)\n      { display.view = display.view.slice(0, findViewIndex(cm, to)); }\n  }\n  display.viewTo = to;\n}\n\n// Count the number of lines in the view whose DOM representation is\n// out of date (or nonexistent).\nfunction countDirtyView(cm) {\n  var view = cm.display.view, dirty = 0;\n  for (var i = 0; i < view.length; i++) {\n    var lineView = view[i];\n    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\n  }\n  return dirty\n}\n\n// HIGHLIGHT WORKER\n\nfunction startWorker(cm, time) {\n  if (cm.doc.highlightFrontier < cm.display.viewTo)\n    { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\n}\n\nfunction highlightWorker(cm) {\n  var doc = cm.doc;\n  if (doc.highlightFrontier >= cm.display.viewTo) { return }\n  var end = +new Date + cm.options.workTime;\n  var context = getContextBefore(cm, doc.highlightFrontier);\n  var changedLines = [];\n\n  doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n    if (context.line >= cm.display.viewFrom) { // Visible\n      var oldStyles = line.styles;\n      var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n      var highlighted = highlightLine(cm, line, context, true);\n      if (resetState) { context.state = resetState; }\n      line.styles = highlighted.styles;\n      var oldCls = line.styleClasses, newCls = highlighted.classes;\n      if (newCls) { line.styleClasses = newCls; }\n      else if (oldCls) { line.styleClasses = null; }\n      var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\n      if (ischange) { changedLines.push(context.line); }\n      line.stateAfter = context.save();\n      context.nextLine();\n    } else {\n      if (line.text.length <= cm.options.maxHighlightLength)\n        { processLine(cm, line.text, context); }\n      line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n      context.nextLine();\n    }\n    if (+new Date > end) {\n      startWorker(cm, cm.options.workDelay);\n      return true\n    }\n  });\n  doc.highlightFrontier = context.line;\n  doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n  if (changedLines.length) { runInOp(cm, function () {\n    for (var i = 0; i < changedLines.length; i++)\n      { regLineChange(cm, changedLines[i], \"text\"); }\n  }); }\n}\n\n// DISPLAY DRAWING\n\nvar DisplayUpdate = function(cm, viewport, force) {\n  var display = cm.display;\n\n  this.viewport = viewport;\n  // Store some values that we'll need later (but don't want to force a relayout for)\n  this.visible = visibleLines(display, cm.doc, viewport);\n  this.editorIsHidden = !display.wrapper.offsetWidth;\n  this.wrapperHeight = display.wrapper.clientHeight;\n  this.wrapperWidth = display.wrapper.clientWidth;\n  this.oldDisplayWidth = displayWidth(cm);\n  this.force = force;\n  this.dims = getDimensions(cm);\n  this.events = [];\n};\n\nDisplayUpdate.prototype.signal = function (emitter, type) {\n  if (hasHandler(emitter, type))\n    { this.events.push(arguments); }\n};\nDisplayUpdate.prototype.finish = function () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.events.length; i++)\n    { signal.apply(null, this$1.events[i]); }\n};\n\nfunction maybeClipScrollbars(cm) {\n  var display = cm.display;\n  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n    display.heightForcer.style.height = scrollGap(cm) + \"px\";\n    display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n    display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n    display.scrollbarsClipped = true;\n  }\n}\n\nfunction selectionSnapshot(cm) {\n  if (cm.hasFocus()) { return null }\n  var active = activeElt();\n  if (!active || !contains(cm.display.lineDiv, active)) { return null }\n  var result = {activeElt: active};\n  if (window.getSelection) {\n    var sel = window.getSelection();\n    if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n      result.anchorNode = sel.anchorNode;\n      result.anchorOffset = sel.anchorOffset;\n      result.focusNode = sel.focusNode;\n      result.focusOffset = sel.focusOffset;\n    }\n  }\n  return result\n}\n\nfunction restoreSelection(snapshot) {\n  if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\n  snapshot.activeElt.focus();\n  if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n    var sel = window.getSelection(), range$$1 = document.createRange();\n    range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n    range$$1.collapse(false);\n    sel.removeAllRanges();\n    sel.addRange(range$$1);\n    sel.extend(snapshot.focusNode, snapshot.focusOffset);\n  }\n}\n\n// Does the actual updating of the line display. Bails out\n// (returning false) when there is nothing to be done and forced is\n// false.\nfunction updateDisplayIfNeeded(cm, update) {\n  var display = cm.display, doc = cm.doc;\n\n  if (update.editorIsHidden) {\n    resetView(cm);\n    return false\n  }\n\n  // Bail out if the visible area is already rendered and nothing changed.\n  if (!update.force &&\n      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n      display.renderedView == display.view && countDirtyView(cm) == 0)\n    { return false }\n\n  if (maybeUpdateLineNumberWidth(cm)) {\n    resetView(cm);\n    update.dims = getDimensions(cm);\n  }\n\n  // Compute a suitable new viewport (from & to)\n  var end = doc.first + doc.size;\n  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n  var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\n  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\n  if (sawCollapsedSpans) {\n    from = visualLineNo(cm.doc, from);\n    to = visualLineEndNo(cm.doc, to);\n  }\n\n  var different = from != display.viewFrom || to != display.viewTo ||\n    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n  adjustView(cm, from, to);\n\n  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n  // Position the mover div to align with the current scroll position\n  cm.display.mover.style.top = display.viewOffset + \"px\";\n\n  var toUpdate = countDirtyView(cm);\n  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n    { return false }\n\n  // For big changes, we hide the enclosing element during the\n  // update, since that speeds up the operations on most browsers.\n  var selSnapshot = selectionSnapshot(cm);\n  if (toUpdate > 4) { display.lineDiv.style.display = \"none\"; }\n  patchDisplay(cm, display.updateLineNumbers, update.dims);\n  if (toUpdate > 4) { display.lineDiv.style.display = \"\"; }\n  display.renderedView = display.view;\n  // There might have been a widget with a focused element that got\n  // hidden or updated, if so re-focus it.\n  restoreSelection(selSnapshot);\n\n  // Prevent selection and cursors from interfering with the scroll\n  // width and height.\n  removeChildren(display.cursorDiv);\n  removeChildren(display.selectionDiv);\n  display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n  if (different) {\n    display.lastWrapHeight = update.wrapperHeight;\n    display.lastWrapWidth = update.wrapperWidth;\n    startWorker(cm, 400);\n  }\n\n  display.updateLineNumbers = null;\n\n  return true\n}\n\nfunction postUpdateDisplay(cm, update) {\n  var viewport = update.viewport;\n\n  for (var first = true;; first = false) {\n    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n      // Clip forced viewport to actual scrollable area.\n      if (viewport && viewport.top != null)\n        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\n      // Updated line heights might result in the drawn area not\n      // actually covering the viewport. Keep looping until it does.\n      update.visible = visibleLines(cm.display, cm.doc, viewport);\n      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n        { break }\n    }\n    if (!updateDisplayIfNeeded(cm, update)) { break }\n    updateHeightsInViewport(cm);\n    var barMeasure = measureForScrollbars(cm);\n    updateSelection(cm);\n    updateScrollbars(cm, barMeasure);\n    setDocumentHeight(cm, barMeasure);\n    update.force = false;\n  }\n\n  update.signal(cm, \"update\", cm);\n  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n    update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n  }\n}\n\nfunction updateDisplaySimple(cm, viewport) {\n  var update = new DisplayUpdate(cm, viewport);\n  if (updateDisplayIfNeeded(cm, update)) {\n    updateHeightsInViewport(cm);\n    postUpdateDisplay(cm, update);\n    var barMeasure = measureForScrollbars(cm);\n    updateSelection(cm);\n    updateScrollbars(cm, barMeasure);\n    setDocumentHeight(cm, barMeasure);\n    update.finish();\n  }\n}\n\n// Sync the actual display DOM structure with display.view, removing\n// nodes for lines that are no longer in view, and creating the ones\n// that are not there yet, and updating the ones that are out of\n// date.\nfunction patchDisplay(cm, updateNumbersFrom, dims) {\n  var display = cm.display, lineNumbers = cm.options.lineNumbers;\n  var container = display.lineDiv, cur = container.firstChild;\n\n  function rm(node) {\n    var next = node.nextSibling;\n    // Works around a throw-scroll bug in OS X Webkit\n    if (webkit && mac && cm.display.currentWheelTarget == node)\n      { node.style.display = \"none\"; }\n    else\n      { node.parentNode.removeChild(node); }\n    return next\n  }\n\n  var view = display.view, lineN = display.viewFrom;\n  // Loop over the elements in the view, syncing cur (the DOM nodes\n  // in display.lineDiv) with the view as we go.\n  for (var i = 0; i < view.length; i++) {\n    var lineView = view[i];\n    if (lineView.hidden) {\n    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n      var node = buildLineElement(cm, lineView, lineN, dims);\n      container.insertBefore(node, cur);\n    } else { // Already drawn\n      while (cur != lineView.node) { cur = rm(cur); }\n      var updateNumber = lineNumbers && updateNumbersFrom != null &&\n        updateNumbersFrom <= lineN && lineView.lineNumber;\n      if (lineView.changes) {\n        if (indexOf(lineView.changes, \"gutter\") > -1) { updateNumber = false; }\n        updateLineForChanges(cm, lineView, lineN, dims);\n      }\n      if (updateNumber) {\n        removeChildren(lineView.lineNumber);\n        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n      }\n      cur = lineView.node.nextSibling;\n    }\n    lineN += lineView.size;\n  }\n  while (cur) { cur = rm(cur); }\n}\n\nfunction updateGutterSpace(cm) {\n  var width = cm.display.gutters.offsetWidth;\n  cm.display.sizer.style.marginLeft = width + \"px\";\n}\n\nfunction setDocumentHeight(cm, measure) {\n  cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n  cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n}\n\n// Rebuild the gutter elements, ensure the margin to the left of the\n// code matches their width.\nfunction updateGutters(cm) {\n  var gutters = cm.display.gutters, specs = cm.options.gutters;\n  removeChildren(gutters);\n  var i = 0;\n  for (; i < specs.length; ++i) {\n    var gutterClass = specs[i];\n    var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n    if (gutterClass == \"CodeMirror-linenumbers\") {\n      cm.display.lineGutter = gElt;\n      gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n    }\n  }\n  gutters.style.display = i ? \"\" : \"none\";\n  updateGutterSpace(cm);\n}\n\n// Make sure the gutters options contains the element\n// \"CodeMirror-linenumbers\" when the lineNumbers option is true.\nfunction setGuttersForLineNumbers(options) {\n  var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n  if (found == -1 && options.lineNumbers) {\n    options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n  } else if (found > -1 && !options.lineNumbers) {\n    options.gutters = options.gutters.slice(0);\n    options.gutters.splice(found, 1);\n  }\n}\n\n// Since the delta values reported on mouse wheel events are\n// unstandardized between browsers and even browser versions, and\n// generally horribly unpredictable, this code starts by measuring\n// the scroll effect that the first few mouse wheel events have,\n// and, from that, detects the way it can convert deltas to pixel\n// offsets afterwards.\n//\n// The reason we want to know the amount a wheel event will scroll\n// is that it gives us a chance to update the display before the\n// actual scrolling happens, reducing flickering.\n\nvar wheelSamples = 0;\nvar wheelPixelsPerUnit = null;\n// Fill in a browser-detected starting value on browsers where we\n// know one. These don't have to be accurate -- the result of them\n// being wrong would just be a slight flicker on the first wheel\n// scroll (if it is large enough).\nif (ie) { wheelPixelsPerUnit = -.53; }\nelse if (gecko) { wheelPixelsPerUnit = 15; }\nelse if (chrome) { wheelPixelsPerUnit = -.7; }\nelse if (safari) { wheelPixelsPerUnit = -1/3; }\n\nfunction wheelEventDelta(e) {\n  var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\n  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\n  else if (dy == null) { dy = e.wheelDelta; }\n  return {x: dx, y: dy}\n}\nfunction wheelEventPixels(e) {\n  var delta = wheelEventDelta(e);\n  delta.x *= wheelPixelsPerUnit;\n  delta.y *= wheelPixelsPerUnit;\n  return delta\n}\n\nfunction onScrollWheel(cm, e) {\n  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n  var display = cm.display, scroll = display.scroller;\n  // Quit if there's nothing to scroll here\n  var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n  var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n  if (!(dx && canScrollX || dy && canScrollY)) { return }\n\n  // Webkit browsers on OS X abort momentum scrolls when the target\n  // of the scroll event is removed from the scrollable element.\n  // This hack (see related code in patchDisplay) makes sure the\n  // element is kept around.\n  if (dy && mac && webkit) {\n    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n      for (var i = 0; i < view.length; i++) {\n        if (view[i].node == cur) {\n          cm.display.currentWheelTarget = cur;\n          break outer\n        }\n      }\n    }\n  }\n\n  // On some browsers, horizontal scrolling will cause redraws to\n  // happen before the gutter has been realigned, causing it to\n  // wriggle around in a most unseemly way. When we have an\n  // estimated pixels/delta value, we just handle horizontal\n  // scrolling entirely here. It'll be slightly off from native, but\n  // better than glitching out.\n  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n    if (dy && canScrollY)\n      { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\n    setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\n    // Only prevent default scrolling if vertical scrolling is\n    // actually possible. Otherwise, it causes vertical scroll\n    // jitter on OSX trackpads when deltaX is small and deltaY\n    // is large (issue #3579)\n    if (!dy || (dy && canScrollY))\n      { e_preventDefault(e); }\n    display.wheelStartX = null; // Abort measurement, if in progress\n    return\n  }\n\n  // 'Project' the visible viewport to cover the area that is being\n  // scrolled into view (if we know enough to estimate it).\n  if (dy && wheelPixelsPerUnit != null) {\n    var pixels = dy * wheelPixelsPerUnit;\n    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n    if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\n    else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\n    updateDisplaySimple(cm, {top: top, bottom: bot});\n  }\n\n  if (wheelSamples < 20) {\n    if (display.wheelStartX == null) {\n      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n      display.wheelDX = dx; display.wheelDY = dy;\n      setTimeout(function () {\n        if (display.wheelStartX == null) { return }\n        var movedX = scroll.scrollLeft - display.wheelStartX;\n        var movedY = scroll.scrollTop - display.wheelStartY;\n        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n          (movedX && display.wheelDX && movedX / display.wheelDX);\n        display.wheelStartX = display.wheelStartY = null;\n        if (!sample) { return }\n        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n        ++wheelSamples;\n      }, 200);\n    } else {\n      display.wheelDX += dx; display.wheelDY += dy;\n    }\n  }\n}\n\n// Selection objects are immutable. A new one is created every time\n// the selection changes. A selection is one or more non-overlapping\n// (and non-touching) ranges, sorted, and an integer that indicates\n// which one is the primary selection (the one that's scrolled into\n// view, that getCursor returns, etc).\nvar Selection = function(ranges, primIndex) {\n  this.ranges = ranges;\n  this.primIndex = primIndex;\n};\n\nSelection.prototype.primary = function () { return this.ranges[this.primIndex] };\n\nSelection.prototype.equals = function (other) {\n    var this$1 = this;\n\n  if (other == this) { return true }\n  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\n  for (var i = 0; i < this.ranges.length; i++) {\n    var here = this$1.ranges[i], there = other.ranges[i];\n    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\n  }\n  return true\n};\n\nSelection.prototype.deepCopy = function () {\n    var this$1 = this;\n\n  var out = [];\n  for (var i = 0; i < this.ranges.length; i++)\n    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }\n  return new Selection(out, this.primIndex)\n};\n\nSelection.prototype.somethingSelected = function () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.ranges.length; i++)\n    { if (!this$1.ranges[i].empty()) { return true } }\n  return false\n};\n\nSelection.prototype.contains = function (pos, end) {\n    var this$1 = this;\n\n  if (!end) { end = pos; }\n  for (var i = 0; i < this.ranges.length; i++) {\n    var range = this$1.ranges[i];\n    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n      { return i }\n  }\n  return -1\n};\n\nvar Range = function(anchor, head) {\n  this.anchor = anchor; this.head = head;\n};\n\nRange.prototype.from = function () { return minPos(this.anchor, this.head) };\nRange.prototype.to = function () { return maxPos(this.anchor, this.head) };\nRange.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\n\n// Take an unsorted, potentially overlapping set of ranges, and\n// build a selection out of it. 'Consumes' ranges array (modifying\n// it).\nfunction normalizeSelection(ranges, primIndex) {\n  var prim = ranges[primIndex];\n  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\n  primIndex = indexOf(ranges, prim);\n  for (var i = 1; i < ranges.length; i++) {\n    var cur = ranges[i], prev = ranges[i - 1];\n    if (cmp(prev.to(), cur.from()) >= 0) {\n      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n      if (i <= primIndex) { --primIndex; }\n      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n    }\n  }\n  return new Selection(ranges, primIndex)\n}\n\nfunction simpleSelection(anchor, head) {\n  return new Selection([new Range(anchor, head || anchor)], 0)\n}\n\n// Compute the position of the end of a change (its 'to' property\n// refers to the pre-change end).\nfunction changeEnd(change) {\n  if (!change.text) { return change.to }\n  return Pos(change.from.line + change.text.length - 1,\n             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\n}\n\n// Adjust a position to refer to the post-change position of the\n// same text, or the end of the change if the change covers it.\nfunction adjustForChange(pos, change) {\n  if (cmp(pos, change.from) < 0) { return pos }\n  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\n\n  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\n  return Pos(line, ch)\n}\n\nfunction computeSelAfterChange(doc, change) {\n  var out = [];\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\n    var range = doc.sel.ranges[i];\n    out.push(new Range(adjustForChange(range.anchor, change),\n                       adjustForChange(range.head, change)));\n  }\n  return normalizeSelection(out, doc.sel.primIndex)\n}\n\nfunction offsetPos(pos, old, nw) {\n  if (pos.line == old.line)\n    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\n  else\n    { return Pos(nw.line + (pos.line - old.line), pos.ch) }\n}\n\n// Used by replaceSelections to allow moving the selection to the\n// start or around the replaced test. Hint may be \"start\" or \"around\".\nfunction computeReplacedSel(doc, changes, hint) {\n  var out = [];\n  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n    var from = offsetPos(change.from, oldPrev, newPrev);\n    var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n    oldPrev = change.to;\n    newPrev = to;\n    if (hint == \"around\") {\n      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n      out[i] = new Range(inv ? to : from, inv ? from : to);\n    } else {\n      out[i] = new Range(from, from);\n    }\n  }\n  return new Selection(out, doc.sel.primIndex)\n}\n\n// Used to get the editor into a consistent state again when options change.\n\nfunction loadMode(cm) {\n  cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n  resetModeState(cm);\n}\n\nfunction resetModeState(cm) {\n  cm.doc.iter(function (line) {\n    if (line.stateAfter) { line.stateAfter = null; }\n    if (line.styles) { line.styles = null; }\n  });\n  cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n  startWorker(cm, 100);\n  cm.state.modeGen++;\n  if (cm.curOp) { regChange(cm); }\n}\n\n// DOCUMENT DATA STRUCTURE\n\n// By default, updates that start and end at the beginning of a line\n// are treated specially, in order to make the association of line\n// widgets and marker elements with the text behave more intuitive.\nfunction isWholeLineUpdate(doc, change) {\n  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\n}\n\n// Perform a change on the document data structure.\nfunction updateDoc(doc, change, markedSpans, estimateHeight$$1) {\n  function spansFor(n) {return markedSpans ? markedSpans[n] : null}\n  function update(line, text, spans) {\n    updateLine(line, text, spans, estimateHeight$$1);\n    signalLater(line, \"change\", line, change);\n  }\n  function linesFor(start, end) {\n    var result = [];\n    for (var i = start; i < end; ++i)\n      { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }\n    return result\n  }\n\n  var from = change.from, to = change.to, text = change.text;\n  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n  // Adjust the line structure\n  if (change.full) {\n    doc.insert(0, linesFor(0, text.length));\n    doc.remove(text.length, doc.size - text.length);\n  } else if (isWholeLineUpdate(doc, change)) {\n    // This is a whole-line replace. Treated specially to make\n    // sure line objects move the way they are supposed to.\n    var added = linesFor(0, text.length - 1);\n    update(lastLine, lastLine.text, lastSpans);\n    if (nlines) { doc.remove(from.line, nlines); }\n    if (added.length) { doc.insert(from.line, added); }\n  } else if (firstLine == lastLine) {\n    if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n    } else {\n      var added$1 = linesFor(1, text.length - 1);\n      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      doc.insert(from.line + 1, added$1);\n    }\n  } else if (text.length == 1) {\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n    doc.remove(from.line + 1, nlines);\n  } else {\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n    var added$2 = linesFor(1, text.length - 1);\n    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\n    doc.insert(from.line + 1, added$2);\n  }\n\n  signalLater(doc, \"change\", doc, change);\n}\n\n// Call f for all linked documents.\nfunction linkedDocs(doc, f, sharedHistOnly) {\n  function propagate(doc, skip, sharedHist) {\n    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\n      var rel = doc.linked[i];\n      if (rel.doc == skip) { continue }\n      var shared = sharedHist && rel.sharedHist;\n      if (sharedHistOnly && !shared) { continue }\n      f(rel.doc, shared);\n      propagate(rel.doc, doc, shared);\n    } }\n  }\n  propagate(doc, null, true);\n}\n\n// Attach a document to an editor.\nfunction attachDoc(cm, doc) {\n  if (doc.cm) { throw new Error(\"This document is already in use.\") }\n  cm.doc = doc;\n  doc.cm = cm;\n  estimateLineHeights(cm);\n  loadMode(cm);\n  setDirectionClass(cm);\n  if (!cm.options.lineWrapping) { findMaxLine(cm); }\n  cm.options.mode = doc.modeOption;\n  regChange(cm);\n}\n\nfunction setDirectionClass(cm) {\n  (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n}\n\nfunction directionChanged(cm) {\n  runInOp(cm, function () {\n    setDirectionClass(cm);\n    regChange(cm);\n  });\n}\n\nfunction History(startGen) {\n  // Arrays of change events and selections. Doing something adds an\n  // event to done and clears undo. Undoing moves events from done\n  // to undone, redoing moves them in the other direction.\n  this.done = []; this.undone = [];\n  this.undoDepth = Infinity;\n  // Used to track when changes can be merged into a single undo\n  // event\n  this.lastModTime = this.lastSelTime = 0;\n  this.lastOp = this.lastSelOp = null;\n  this.lastOrigin = this.lastSelOrigin = null;\n  // Used by the isClean() method\n  this.generation = this.maxGeneration = startGen || 1;\n}\n\n// Create a history change event from an updateDoc-style change\n// object.\nfunction historyChangeFromChange(doc, change) {\n  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\n  return histChange\n}\n\n// Pop all selection events off the end of a history array. Stop at\n// a change event.\nfunction clearSelectionEvents(array) {\n  while (array.length) {\n    var last = lst(array);\n    if (last.ranges) { array.pop(); }\n    else { break }\n  }\n}\n\n// Find the top change event in the history. Pop off selection\n// events that are in the way.\nfunction lastChangeEvent(hist, force) {\n  if (force) {\n    clearSelectionEvents(hist.done);\n    return lst(hist.done)\n  } else if (hist.done.length && !lst(hist.done).ranges) {\n    return lst(hist.done)\n  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n    hist.done.pop();\n    return lst(hist.done)\n  }\n}\n\n// Register a change in the history. Merges changes that are within\n// a single operation, or are close together with an origin that\n// allows merging (starting with \"+\") into a single event.\nfunction addChangeToHistory(doc, change, selAfter, opId) {\n  var hist = doc.history;\n  hist.undone.length = 0;\n  var time = +new Date, cur;\n  var last;\n\n  if ((hist.lastOp == opId ||\n       hist.lastOrigin == change.origin && change.origin &&\n       ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n        change.origin.charAt(0) == \"*\")) &&\n      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n    // Merge this change into the last event\n    last = lst(cur.changes);\n    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n      // Optimized case for simple insertion -- don't want to add\n      // new changesets for every character typed\n      last.to = changeEnd(change);\n    } else {\n      // Add new sub-event\n      cur.changes.push(historyChangeFromChange(doc, change));\n    }\n  } else {\n    // Can not be merged, start a new event.\n    var before = lst(hist.done);\n    if (!before || !before.ranges)\n      { pushSelectionToHistory(doc.sel, hist.done); }\n    cur = {changes: [historyChangeFromChange(doc, change)],\n           generation: hist.generation};\n    hist.done.push(cur);\n    while (hist.done.length > hist.undoDepth) {\n      hist.done.shift();\n      if (!hist.done[0].ranges) { hist.done.shift(); }\n    }\n  }\n  hist.done.push(selAfter);\n  hist.generation = ++hist.maxGeneration;\n  hist.lastModTime = hist.lastSelTime = time;\n  hist.lastOp = hist.lastSelOp = opId;\n  hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n  if (!last) { signal(doc, \"historyAdded\"); }\n}\n\nfunction selectionEventCanBeMerged(doc, origin, prev, sel) {\n  var ch = origin.charAt(0);\n  return ch == \"*\" ||\n    ch == \"+\" &&\n    prev.ranges.length == sel.ranges.length &&\n    prev.somethingSelected() == sel.somethingSelected() &&\n    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\n}\n\n// Called whenever the selection changes, sets the new selection as\n// the pending selection in the history, and pushes the old pending\n// selection into the 'done' array when it was significantly\n// different (in number of selected ranges, emptiness, or time).\nfunction addSelectionToHistory(doc, sel, opId, options) {\n  var hist = doc.history, origin = options && options.origin;\n\n  // A new event is started when the previous origin does not match\n  // the current, or the origins don't allow matching. Origins\n  // starting with * are always merged, those starting with + are\n  // merged when similar and close together in time.\n  if (opId == hist.lastSelOp ||\n      (origin && hist.lastSelOrigin == origin &&\n       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n    { hist.done[hist.done.length - 1] = sel; }\n  else\n    { pushSelectionToHistory(sel, hist.done); }\n\n  hist.lastSelTime = +new Date;\n  hist.lastSelOrigin = origin;\n  hist.lastSelOp = opId;\n  if (options && options.clearRedo !== false)\n    { clearSelectionEvents(hist.undone); }\n}\n\nfunction pushSelectionToHistory(sel, dest) {\n  var top = lst(dest);\n  if (!(top && top.ranges && top.equals(sel)))\n    { dest.push(sel); }\n}\n\n// Used to store marked span information in the history.\nfunction attachLocalSpans(doc, change, from, to) {\n  var existing = change[\"spans_\" + doc.id], n = 0;\n  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n    if (line.markedSpans)\n      { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\n    ++n;\n  });\n}\n\n// When un/re-doing restores text containing marked spans, those\n// that have been explicitly cleared should not be restored.\nfunction removeClearedSpans(spans) {\n  if (!spans) { return null }\n  var out;\n  for (var i = 0; i < spans.length; ++i) {\n    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\n    else if (out) { out.push(spans[i]); }\n  }\n  return !out ? spans : out.length ? out : null\n}\n\n// Retrieve and filter the old marked spans stored in a change event.\nfunction getOldSpans(doc, change) {\n  var found = change[\"spans_\" + doc.id];\n  if (!found) { return null }\n  var nw = [];\n  for (var i = 0; i < change.text.length; ++i)\n    { nw.push(removeClearedSpans(found[i])); }\n  return nw\n}\n\n// Used for un/re-doing changes from the history. Combines the\n// result of computing the existing spans with the set of spans that\n// existed in the history (so that deleting around a span and then\n// undoing brings back the span).\nfunction mergeOldSpans(doc, change) {\n  var old = getOldSpans(doc, change);\n  var stretched = stretchSpansOverChange(doc, change);\n  if (!old) { return stretched }\n  if (!stretched) { return old }\n\n  for (var i = 0; i < old.length; ++i) {\n    var oldCur = old[i], stretchCur = stretched[i];\n    if (oldCur && stretchCur) {\n      spans: for (var j = 0; j < stretchCur.length; ++j) {\n        var span = stretchCur[j];\n        for (var k = 0; k < oldCur.length; ++k)\n          { if (oldCur[k].marker == span.marker) { continue spans } }\n        oldCur.push(span);\n      }\n    } else if (stretchCur) {\n      old[i] = stretchCur;\n    }\n  }\n  return old\n}\n\n// Used both to provide a JSON-safe object in .getHistory, and, when\n// detaching a document, to split the history in two\nfunction copyHistoryArray(events, newGroup, instantiateSel) {\n  var copy = [];\n  for (var i = 0; i < events.length; ++i) {\n    var event = events[i];\n    if (event.ranges) {\n      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n      continue\n    }\n    var changes = event.changes, newChanges = [];\n    copy.push({changes: newChanges});\n    for (var j = 0; j < changes.length; ++j) {\n      var change = changes[j], m = (void 0);\n      newChanges.push({from: change.from, to: change.to, text: change.text});\n      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\n        if (indexOf(newGroup, Number(m[1])) > -1) {\n          lst(newChanges)[prop] = change[prop];\n          delete change[prop];\n        }\n      } } }\n    }\n  }\n  return copy\n}\n\n// The 'scroll' parameter given to many of these indicated whether\n// the new cursor position should be scrolled into view after\n// modifying the selection.\n\n// If shift is held or the extend flag is set, extends a range to\n// include a given position (and optionally a second position).\n// Otherwise, simply returns the range between the given positions.\n// Used for cursor motion and such.\nfunction extendRange(range, head, other, extend) {\n  if (extend) {\n    var anchor = range.anchor;\n    if (other) {\n      var posBefore = cmp(head, anchor) < 0;\n      if (posBefore != (cmp(other, anchor) < 0)) {\n        anchor = head;\n        head = other;\n      } else if (posBefore != (cmp(head, other) < 0)) {\n        head = other;\n      }\n    }\n    return new Range(anchor, head)\n  } else {\n    return new Range(other || head, head)\n  }\n}\n\n// Extend the primary selection range, discard the rest.\nfunction extendSelection(doc, head, other, options, extend) {\n  if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }\n  setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n}\n\n// Extend all selections (pos is an array of selections with length\n// equal the number of selections)\nfunction extendSelections(doc, heads, options) {\n  var out = [];\n  var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n  for (var i = 0; i < doc.sel.ranges.length; i++)\n    { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }\n  var newSel = normalizeSelection(out, doc.sel.primIndex);\n  setSelection(doc, newSel, options);\n}\n\n// Updates a single range in the selection.\nfunction replaceOneSelection(doc, i, range, options) {\n  var ranges = doc.sel.ranges.slice(0);\n  ranges[i] = range;\n  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n}\n\n// Reset the selection to a single range.\nfunction setSimpleSelection(doc, anchor, head, options) {\n  setSelection(doc, simpleSelection(anchor, head), options);\n}\n\n// Give beforeSelectionChange handlers a change to influence a\n// selection update.\nfunction filterSelectionChange(doc, sel, options) {\n  var obj = {\n    ranges: sel.ranges,\n    update: function(ranges) {\n      var this$1 = this;\n\n      this.ranges = [];\n      for (var i = 0; i < ranges.length; i++)\n        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                   clipPos(doc, ranges[i].head)); }\n    },\n    origin: options && options.origin\n  };\n  signal(doc, \"beforeSelectionChange\", doc, obj);\n  if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\n  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }\n  else { return sel }\n}\n\nfunction setSelectionReplaceHistory(doc, sel, options) {\n  var done = doc.history.done, last = lst(done);\n  if (last && last.ranges) {\n    done[done.length - 1] = sel;\n    setSelectionNoUndo(doc, sel, options);\n  } else {\n    setSelection(doc, sel, options);\n  }\n}\n\n// Set a new selection.\nfunction setSelection(doc, sel, options) {\n  setSelectionNoUndo(doc, sel, options);\n  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n}\n\nfunction setSelectionNoUndo(doc, sel, options) {\n  if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n    { sel = filterSelectionChange(doc, sel, options); }\n\n  var bias = options && options.bias ||\n    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n  if (!(options && options.scroll === false) && doc.cm)\n    { ensureCursorVisible(doc.cm); }\n}\n\nfunction setSelectionInner(doc, sel) {\n  if (sel.equals(doc.sel)) { return }\n\n  doc.sel = sel;\n\n  if (doc.cm) {\n    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n    signalCursorActivity(doc.cm);\n  }\n  signalLater(doc, \"cursorActivity\", doc);\n}\n\n// Verify that the selection does not partially select any atomic\n// marked ranges.\nfunction reCheckSelection(doc) {\n  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n}\n\n// Return a selection that does not partially select any atomic\n// ranges.\nfunction skipAtomicInSelection(doc, sel, bias, mayClear) {\n  var out;\n  for (var i = 0; i < sel.ranges.length; i++) {\n    var range = sel.ranges[i];\n    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n    if (out || newAnchor != range.anchor || newHead != range.head) {\n      if (!out) { out = sel.ranges.slice(0, i); }\n      out[i] = new Range(newAnchor, newHead);\n    }\n  }\n  return out ? normalizeSelection(out, sel.primIndex) : sel\n}\n\nfunction skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n  var line = getLine(doc, pos.line);\n  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n    var sp = line.markedSpans[i], m = sp.marker;\n    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n      if (mayClear) {\n        signal(m, \"beforeCursorEnter\");\n        if (m.explicitlyCleared) {\n          if (!line.markedSpans) { break }\n          else {--i; continue}\n        }\n      }\n      if (!m.atomic) { continue }\n\n      if (oldPos) {\n        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\n        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\n          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\n        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n          { return skipAtomicInner(doc, near, pos, dir, mayClear) }\n      }\n\n      var far = m.find(dir < 0 ? -1 : 1);\n      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\n        { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\n      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\n    }\n  } }\n  return pos\n}\n\n// Ensure a given position is not inside an atomic range.\nfunction skipAtomic(doc, pos, oldPos, bias, mayClear) {\n  var dir = bias || 1;\n  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n  if (!found) {\n    doc.cantEdit = true;\n    return Pos(doc.first, 0)\n  }\n  return found\n}\n\nfunction movePos(doc, pos, dir, line) {\n  if (dir < 0 && pos.ch == 0) {\n    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\n    else { return null }\n  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\n    else { return null }\n  } else {\n    return new Pos(pos.line, pos.ch + dir)\n  }\n}\n\nfunction selectAll(cm) {\n  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n}\n\n// UPDATING\n\n// Allow \"beforeChange\" event handlers to influence a change\nfunction filterChange(doc, change, update) {\n  var obj = {\n    canceled: false,\n    from: change.from,\n    to: change.to,\n    text: change.text,\n    origin: change.origin,\n    cancel: function () { return obj.canceled = true; }\n  };\n  if (update) { obj.update = function (from, to, text, origin) {\n    if (from) { obj.from = clipPos(doc, from); }\n    if (to) { obj.to = clipPos(doc, to); }\n    if (text) { obj.text = text; }\n    if (origin !== undefined) { obj.origin = origin; }\n  }; }\n  signal(doc, \"beforeChange\", doc, obj);\n  if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\n\n  if (obj.canceled) { return null }\n  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\n}\n\n// Apply a change to a document, and add it to the document's\n// history, and propagating it to all linked documents.\nfunction makeChange(doc, change, ignoreReadOnly) {\n  if (doc.cm) {\n    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\n    if (doc.cm.state.suppressEdits) { return }\n  }\n\n  if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n    change = filterChange(doc, change, true);\n    if (!change) { return }\n  }\n\n  // Possibly split or suppress the update based on the presence\n  // of read-only spans in its range.\n  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n  if (split) {\n    for (var i = split.length - 1; i >= 0; --i)\n      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text}); }\n  } else {\n    makeChangeInner(doc, change);\n  }\n}\n\nfunction makeChangeInner(doc, change) {\n  if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) { return }\n  var selAfter = computeSelAfterChange(doc, change);\n  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n  var rebased = [];\n\n  linkedDocs(doc, function (doc, sharedHist) {\n    if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n      rebaseHist(doc.history, change);\n      rebased.push(doc.history);\n    }\n    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n  });\n}\n\n// Revert a change stored in a document's history.\nfunction makeChangeFromHistory(doc, type, allowSelectionOnly) {\n  if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }\n\n  var hist = doc.history, event, selAfter = doc.sel;\n  var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n  // Verify that there is a useable event (so that ctrl-z won't\n  // needlessly clear selection events)\n  var i = 0;\n  for (; i < source.length; i++) {\n    event = source[i];\n    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n      { break }\n  }\n  if (i == source.length) { return }\n  hist.lastOrigin = hist.lastSelOrigin = null;\n\n  for (;;) {\n    event = source.pop();\n    if (event.ranges) {\n      pushSelectionToHistory(event, dest);\n      if (allowSelectionOnly && !event.equals(doc.sel)) {\n        setSelection(doc, event, {clearRedo: false});\n        return\n      }\n      selAfter = event;\n    }\n    else { break }\n  }\n\n  // Build up a reverse change object to add to the opposite history\n  // stack (redo when undoing, and vice versa).\n  var antiChanges = [];\n  pushSelectionToHistory(selAfter, dest);\n  dest.push({changes: antiChanges, generation: hist.generation});\n  hist.generation = event.generation || ++hist.maxGeneration;\n\n  var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n  var loop = function ( i ) {\n    var change = event.changes[i];\n    change.origin = type;\n    if (filter && !filterChange(doc, change, false)) {\n      source.length = 0;\n      return {}\n    }\n\n    antiChanges.push(historyChangeFromChange(doc, change));\n\n    var after = i ? computeSelAfterChange(doc, change) : lst(source);\n    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\n    var rebased = [];\n\n    // Propagate to the linked documents\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n    });\n  };\n\n  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n    var returned = loop( i$1 );\n\n    if ( returned ) return returned.v;\n  }\n}\n\n// Sub-views need their line numbers shifted when text is added\n// above or below them in the parent document.\nfunction shiftDoc(doc, distance) {\n  if (distance == 0) { return }\n  doc.first += distance;\n  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\n    Pos(range.anchor.line + distance, range.anchor.ch),\n    Pos(range.head.line + distance, range.head.ch)\n  ); }), doc.sel.primIndex);\n  if (doc.cm) {\n    regChange(doc.cm, doc.first, doc.first - distance, distance);\n    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n      { regLineChange(doc.cm, l, \"gutter\"); }\n  }\n}\n\n// More lower-level change function, handling only a single document\n// (not linked ones).\nfunction makeChangeSingleDoc(doc, change, selAfter, spans) {\n  if (doc.cm && !doc.cm.curOp)\n    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\n\n  if (change.to.line < doc.first) {\n    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n    return\n  }\n  if (change.from.line > doc.lastLine()) { return }\n\n  // Clip the change to the size of this doc\n  if (change.from.line < doc.first) {\n    var shift = change.text.length - 1 - (doc.first - change.from.line);\n    shiftDoc(doc, shift);\n    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n              text: [lst(change.text)], origin: change.origin};\n  }\n  var last = doc.lastLine();\n  if (change.to.line > last) {\n    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n              text: [change.text[0]], origin: change.origin};\n  }\n\n  change.removed = getBetween(doc, change.from, change.to);\n\n  if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\n  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\n  else { updateDoc(doc, change, spans); }\n  setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n}\n\n// Handle the interaction of a change to a document with the editor\n// that this document is part of.\nfunction makeChangeSingleDocInEditor(cm, change, spans) {\n  var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n  var recomputeMaxLength = false, checkWidthStart = from.line;\n  if (!cm.options.lineWrapping) {\n    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n    doc.iter(checkWidthStart, to.line + 1, function (line) {\n      if (line == display.maxLine) {\n        recomputeMaxLength = true;\n        return true\n      }\n    });\n  }\n\n  if (doc.sel.contains(change.from, change.to) > -1)\n    { signalCursorActivity(cm); }\n\n  updateDoc(doc, change, spans, estimateHeight(cm));\n\n  if (!cm.options.lineWrapping) {\n    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n      var len = lineLength(line);\n      if (len > display.maxLineLength) {\n        display.maxLine = line;\n        display.maxLineLength = len;\n        display.maxLineChanged = true;\n        recomputeMaxLength = false;\n      }\n    });\n    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\n  }\n\n  retreatFrontier(doc, from.line);\n  startWorker(cm, 400);\n\n  var lendiff = change.text.length - (to.line - from.line) - 1;\n  // Remember that these lines changed, for updating the display\n  if (change.full)\n    { regChange(cm); }\n  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n    { regLineChange(cm, from.line, \"text\"); }\n  else\n    { regChange(cm, from.line, to.line + 1, lendiff); }\n\n  var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n  if (changeHandler || changesHandler) {\n    var obj = {\n      from: from, to: to,\n      text: change.text,\n      removed: change.removed,\n      origin: change.origin\n    };\n    if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\n    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\n  }\n  cm.display.selForContextMenu = null;\n}\n\nfunction replaceRange(doc, code, from, to, origin) {\n  if (!to) { to = from; }\n  if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\n  if (typeof code == \"string\") { code = doc.splitLines(code); }\n  makeChange(doc, {from: from, to: to, text: code, origin: origin});\n}\n\n// Rebasing/resetting history to deal with externally-sourced changes\n\nfunction rebaseHistSelSingle(pos, from, to, diff) {\n  if (to < pos.line) {\n    pos.line += diff;\n  } else if (from < pos.line) {\n    pos.line = from;\n    pos.ch = 0;\n  }\n}\n\n// Tries to rebase an array of history events given a change in the\n// document. If the change touches the same lines as the event, the\n// event, and everything 'behind' it, is discarded. If the change is\n// before the event, the event's positions are updated. Uses a\n// copy-on-write scheme for the positions, to avoid having to\n// reallocate them all on every rebase, but also avoid problems with\n// shared position objects being unsafely updated.\nfunction rebaseHistArray(array, from, to, diff) {\n  for (var i = 0; i < array.length; ++i) {\n    var sub = array[i], ok = true;\n    if (sub.ranges) {\n      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n      for (var j = 0; j < sub.ranges.length; j++) {\n        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n      }\n      continue\n    }\n    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n      var cur = sub.changes[j$1];\n      if (to < cur.from.line) {\n        cur.from = Pos(cur.from.line + diff, cur.from.ch);\n        cur.to = Pos(cur.to.line + diff, cur.to.ch);\n      } else if (from <= cur.to.line) {\n        ok = false;\n        break\n      }\n    }\n    if (!ok) {\n      array.splice(0, i + 1);\n      i = 0;\n    }\n  }\n}\n\nfunction rebaseHist(hist, change) {\n  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n  rebaseHistArray(hist.done, from, to, diff);\n  rebaseHistArray(hist.undone, from, to, diff);\n}\n\n// Utility for applying a change to a line by handle or number,\n// returning the number and optionally registering the line as\n// changed.\nfunction changeLine(doc, handle, changeType, op) {\n  var no = handle, line = handle;\n  if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\n  else { no = lineNo(handle); }\n  if (no == null) { return null }\n  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\n  return line\n}\n\n// The document is represented as a BTree consisting of leaves, with\n// chunk of lines in them, and branches, with up to ten leaves or\n// other branch nodes below them. The top node is always a branch\n// node, and is the document object itself (meaning it has\n// additional methods and properties).\n//\n// All nodes have parent links. The tree is used both to go from\n// line numbers to line objects, and to go from objects to numbers.\n// It also indexes by height, and is used to convert between height\n// and line object, and to find the total height of the document.\n//\n// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\nfunction LeafChunk(lines) {\n  var this$1 = this;\n\n  this.lines = lines;\n  this.parent = null;\n  var height = 0;\n  for (var i = 0; i < lines.length; ++i) {\n    lines[i].parent = this$1;\n    height += lines[i].height;\n  }\n  this.height = height;\n}\n\nLeafChunk.prototype = {\n  chunkSize: function chunkSize() { return this.lines.length },\n\n  // Remove the n lines at offset 'at'.\n  removeInner: function removeInner(at, n) {\n    var this$1 = this;\n\n    for (var i = at, e = at + n; i < e; ++i) {\n      var line = this$1.lines[i];\n      this$1.height -= line.height;\n      cleanUpLine(line);\n      signalLater(line, \"delete\");\n    }\n    this.lines.splice(at, n);\n  },\n\n  // Helper used to collapse a small branch into a single leaf.\n  collapse: function collapse(lines) {\n    lines.push.apply(lines, this.lines);\n  },\n\n  // Insert the given array of lines at offset 'at', count them as\n  // having the given height.\n  insertInner: function insertInner(at, lines, height) {\n    var this$1 = this;\n\n    this.height += height;\n    this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n    for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }\n  },\n\n  // Used to iterate over a part of the tree.\n  iterN: function iterN(at, n, op) {\n    var this$1 = this;\n\n    for (var e = at + n; at < e; ++at)\n      { if (op(this$1.lines[at])) { return true } }\n  }\n};\n\nfunction BranchChunk(children) {\n  var this$1 = this;\n\n  this.children = children;\n  var size = 0, height = 0;\n  for (var i = 0; i < children.length; ++i) {\n    var ch = children[i];\n    size += ch.chunkSize(); height += ch.height;\n    ch.parent = this$1;\n  }\n  this.size = size;\n  this.height = height;\n  this.parent = null;\n}\n\nBranchChunk.prototype = {\n  chunkSize: function chunkSize() { return this.size },\n\n  removeInner: function removeInner(at, n) {\n    var this$1 = this;\n\n    this.size -= n;\n    for (var i = 0; i < this.children.length; ++i) {\n      var child = this$1.children[i], sz = child.chunkSize();\n      if (at < sz) {\n        var rm = Math.min(n, sz - at), oldHeight = child.height;\n        child.removeInner(at, rm);\n        this$1.height -= oldHeight - child.height;\n        if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }\n        if ((n -= rm) == 0) { break }\n        at = 0;\n      } else { at -= sz; }\n    }\n    // If the result is smaller than 25 lines, ensure that it is a\n    // single leaf node.\n    if (this.size - n < 25 &&\n        (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n      var lines = [];\n      this.collapse(lines);\n      this.children = [new LeafChunk(lines)];\n      this.children[0].parent = this;\n    }\n  },\n\n  collapse: function collapse(lines) {\n    var this$1 = this;\n\n    for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }\n  },\n\n  insertInner: function insertInner(at, lines, height) {\n    var this$1 = this;\n\n    this.size += lines.length;\n    this.height += height;\n    for (var i = 0; i < this.children.length; ++i) {\n      var child = this$1.children[i], sz = child.chunkSize();\n      if (at <= sz) {\n        child.insertInner(at, lines, height);\n        if (child.lines && child.lines.length > 50) {\n          // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n          // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n          var remaining = child.lines.length % 25 + 25;\n          for (var pos = remaining; pos < child.lines.length;) {\n            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n            child.height -= leaf.height;\n            this$1.children.splice(++i, 0, leaf);\n            leaf.parent = this$1;\n          }\n          child.lines = child.lines.slice(0, remaining);\n          this$1.maybeSpill();\n        }\n        break\n      }\n      at -= sz;\n    }\n  },\n\n  // When a node has grown, check whether it should be split.\n  maybeSpill: function maybeSpill() {\n    if (this.children.length <= 10) { return }\n    var me = this;\n    do {\n      var spilled = me.children.splice(me.children.length - 5, 5);\n      var sibling = new BranchChunk(spilled);\n      if (!me.parent) { // Become the parent node\n        var copy = new BranchChunk(me.children);\n        copy.parent = me;\n        me.children = [copy, sibling];\n        me = copy;\n     } else {\n        me.size -= sibling.size;\n        me.height -= sibling.height;\n        var myIndex = indexOf(me.parent.children, me);\n        me.parent.children.splice(myIndex + 1, 0, sibling);\n      }\n      sibling.parent = me.parent;\n    } while (me.children.length > 10)\n    me.parent.maybeSpill();\n  },\n\n  iterN: function iterN(at, n, op) {\n    var this$1 = this;\n\n    for (var i = 0; i < this.children.length; ++i) {\n      var child = this$1.children[i], sz = child.chunkSize();\n      if (at < sz) {\n        var used = Math.min(n, sz - at);\n        if (child.iterN(at, used, op)) { return true }\n        if ((n -= used) == 0) { break }\n        at = 0;\n      } else { at -= sz; }\n    }\n  }\n};\n\n// Line widgets are block elements displayed above or below a line.\n\nvar LineWidget = function(doc, node, options) {\n  var this$1 = this;\n\n  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\n    { this$1[opt] = options[opt]; } } }\n  this.doc = doc;\n  this.node = node;\n};\n\nLineWidget.prototype.clear = function () {\n    var this$1 = this;\n\n  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n  if (no == null || !ws) { return }\n  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }\n  if (!ws.length) { line.widgets = null; }\n  var height = widgetHeight(this);\n  updateLineHeight(line, Math.max(0, line.height - height));\n  if (cm) {\n    runInOp(cm, function () {\n      adjustScrollWhenAboveVisible(cm, line, -height);\n      regLineChange(cm, no, \"widget\");\n    });\n    signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n  }\n};\n\nLineWidget.prototype.changed = function () {\n    var this$1 = this;\n\n  var oldH = this.height, cm = this.doc.cm, line = this.line;\n  this.height = null;\n  var diff = widgetHeight(this) - oldH;\n  if (!diff) { return }\n  updateLineHeight(line, line.height + diff);\n  if (cm) {\n    runInOp(cm, function () {\n      cm.curOp.forceUpdate = true;\n      adjustScrollWhenAboveVisible(cm, line, diff);\n      signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n    });\n  }\n};\neventMixin(LineWidget);\n\nfunction adjustScrollWhenAboveVisible(cm, line, diff) {\n  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n    { addToScrollTop(cm, diff); }\n}\n\nfunction addLineWidget(doc, handle, node, options) {\n  var widget = new LineWidget(doc, node, options);\n  var cm = doc.cm;\n  if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\n  changeLine(doc, handle, \"widget\", function (line) {\n    var widgets = line.widgets || (line.widgets = []);\n    if (widget.insertAt == null) { widgets.push(widget); }\n    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }\n    widget.line = line;\n    if (cm && !lineIsHidden(doc, line)) {\n      var aboveVisible = heightAtLine(line) < doc.scrollTop;\n      updateLineHeight(line, line.height + widgetHeight(widget));\n      if (aboveVisible) { addToScrollTop(cm, widget.height); }\n      cm.curOp.forceUpdate = true;\n    }\n    return true\n  });\n  signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle));\n  return widget\n}\n\n// TEXTMARKERS\n\n// Created with markText and setBookmark methods. A TextMarker is a\n// handle that can be used to clear or find a marked position in the\n// document. Line objects hold arrays (markedSpans) containing\n// {from, to, marker} object pointing to such marker objects, and\n// indicating that such a marker is present on that line. Multiple\n// lines may point to the same marker when it spans across lines.\n// The spans will have null for their from/to properties when the\n// marker continues beyond the start/end of the line. Markers have\n// links back to the lines they currently touch.\n\n// Collapsed markers have unique ids, in order to be able to order\n// them, which is needed for uniquely determining an outer marker\n// when they overlap (they may nest, but not partially overlap).\nvar nextMarkerId = 0;\n\nvar TextMarker = function(doc, type) {\n  this.lines = [];\n  this.type = type;\n  this.doc = doc;\n  this.id = ++nextMarkerId;\n};\n\n// Clear the marker.\nTextMarker.prototype.clear = function () {\n    var this$1 = this;\n\n  if (this.explicitlyCleared) { return }\n  var cm = this.doc.cm, withOp = cm && !cm.curOp;\n  if (withOp) { startOperation(cm); }\n  if (hasHandler(this, \"clear\")) {\n    var found = this.find();\n    if (found) { signalLater(this, \"clear\", found.from, found.to); }\n  }\n  var min = null, max = null;\n  for (var i = 0; i < this.lines.length; ++i) {\n    var line = this$1.lines[i];\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\n    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\n    else if (cm) {\n      if (span.to != null) { max = lineNo(line); }\n      if (span.from != null) { min = lineNo(line); }\n    }\n    line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)\n      { updateLineHeight(line, textHeight(cm.display)); }\n  }\n  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);\n    if (len > cm.display.maxLineLength) {\n      cm.display.maxLine = visual;\n      cm.display.maxLineLength = len;\n      cm.display.maxLineChanged = true;\n    }\n  } }\n\n  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\n  this.lines.length = 0;\n  this.explicitlyCleared = true;\n  if (this.atomic && this.doc.cantEdit) {\n    this.doc.cantEdit = false;\n    if (cm) { reCheckSelection(cm.doc); }\n  }\n  if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\n  if (withOp) { endOperation(cm); }\n  if (this.parent) { this.parent.clear(); }\n};\n\n// Find the position of the marker in the document. Returns a {from,\n// to} object by default. Side can be passed to get a specific side\n// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n// Pos objects returned contain a line object, rather than a line\n// number (used to prevent looking up the same line twice).\nTextMarker.prototype.find = function (side, lineObj) {\n    var this$1 = this;\n\n  if (side == null && this.type == \"bookmark\") { side = 1; }\n  var from, to;\n  for (var i = 0; i < this.lines.length; ++i) {\n    var line = this$1.lines[i];\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\n    if (span.from != null) {\n      from = Pos(lineObj ? line : lineNo(line), span.from);\n      if (side == -1) { return from }\n    }\n    if (span.to != null) {\n      to = Pos(lineObj ? line : lineNo(line), span.to);\n      if (side == 1) { return to }\n    }\n  }\n  return from && {from: from, to: to}\n};\n\n// Signals that the marker's widget changed, and surrounding layout\n// should be recomputed.\nTextMarker.prototype.changed = function () {\n    var this$1 = this;\n\n  var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n  if (!pos || !cm) { return }\n  runInOp(cm, function () {\n    var line = pos.line, lineN = lineNo(pos.line);\n    var view = findViewForLine(cm, lineN);\n    if (view) {\n      clearLineMeasurementCacheFor(view);\n      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n    }\n    cm.curOp.updateMaxLine = true;\n    if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n      var oldHeight = widget.height;\n      widget.height = null;\n      var dHeight = widgetHeight(widget) - oldHeight;\n      if (dHeight)\n        { updateLineHeight(line, line.height + dHeight); }\n    }\n    signalLater(cm, \"markerChanged\", cm, this$1);\n  });\n};\n\nTextMarker.prototype.attachLine = function (line) {\n  if (!this.lines.length && this.doc.cm) {\n    var op = this.doc.cm.curOp;\n    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\n  }\n  this.lines.push(line);\n};\n\nTextMarker.prototype.detachLine = function (line) {\n  this.lines.splice(indexOf(this.lines, line), 1);\n  if (!this.lines.length && this.doc.cm) {\n    var op = this.doc.cm.curOp;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n  }\n};\neventMixin(TextMarker);\n\n// Create a marker, wire it up to the right lines, and\nfunction markText(doc, from, to, options, type) {\n  // Shared markers (across linked documents) are handled separately\n  // (markTextShared will call out to this again, once per\n  // document).\n  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\n  // Ensure we are in an operation.\n  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\n\n  var marker = new TextMarker(doc, type), diff = cmp(from, to);\n  if (options) { copyObj(options, marker, false); }\n  // Don't connect empty markers unless clearWhenEmpty is false\n  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n    { return marker }\n  if (marker.replacedWith) {\n    // Showing up as a widget implies collapsed (widget replaces text)\n    marker.collapsed = true;\n    marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\n    if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\n  }\n  if (marker.collapsed) {\n    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n      { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\n    seeCollapsedSpans();\n  }\n\n  if (marker.addToHistory)\n    { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\n\n  var curLine = from.line, cm = doc.cm, updateMaxLine;\n  doc.iter(curLine, to.line + 1, function (line) {\n    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n      { updateMaxLine = true; }\n    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\n    addMarkedSpan(line, new MarkedSpan(marker,\n                                       curLine == from.line ? from.ch : null,\n                                       curLine == to.line ? to.ch : null));\n    ++curLine;\n  });\n  // lineIsHidden depends on the presence of the spans, so needs a second pass\n  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\n    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\n  }); }\n\n  if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\n\n  if (marker.readOnly) {\n    seeReadOnlySpans();\n    if (doc.history.done.length || doc.history.undone.length)\n      { doc.clearHistory(); }\n  }\n  if (marker.collapsed) {\n    marker.id = ++nextMarkerId;\n    marker.atomic = true;\n  }\n  if (cm) {\n    // Sync editor state\n    if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\n    if (marker.collapsed)\n      { regChange(cm, from.line, to.line + 1); }\n    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\n      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \"text\"); } }\n    if (marker.atomic) { reCheckSelection(cm.doc); }\n    signalLater(cm, \"markerAdded\", cm, marker);\n  }\n  return marker\n}\n\n// SHARED TEXTMARKERS\n\n// A shared marker spans multiple linked documents. It is\n// implemented as a meta-marker-object controlling multiple normal\n// markers.\nvar SharedTextMarker = function(markers, primary) {\n  var this$1 = this;\n\n  this.markers = markers;\n  this.primary = primary;\n  for (var i = 0; i < markers.length; ++i)\n    { markers[i].parent = this$1; }\n};\n\nSharedTextMarker.prototype.clear = function () {\n    var this$1 = this;\n\n  if (this.explicitlyCleared) { return }\n  this.explicitlyCleared = true;\n  for (var i = 0; i < this.markers.length; ++i)\n    { this$1.markers[i].clear(); }\n  signalLater(this, \"clear\");\n};\n\nSharedTextMarker.prototype.find = function (side, lineObj) {\n  return this.primary.find(side, lineObj)\n};\neventMixin(SharedTextMarker);\n\nfunction markTextShared(doc, from, to, options, type) {\n  options = copyObj(options);\n  options.shared = false;\n  var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n  var widget = options.widgetNode;\n  linkedDocs(doc, function (doc) {\n    if (widget) { options.widgetNode = widget.cloneNode(true); }\n    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n    for (var i = 0; i < doc.linked.length; ++i)\n      { if (doc.linked[i].isParent) { return } }\n    primary = lst(markers);\n  });\n  return new SharedTextMarker(markers, primary)\n}\n\nfunction findSharedMarkers(doc) {\n  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\n}\n\nfunction copySharedMarkers(doc, markers) {\n  for (var i = 0; i < markers.length; i++) {\n    var marker = markers[i], pos = marker.find();\n    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n    if (cmp(mFrom, mTo)) {\n      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n      marker.markers.push(subMark);\n      subMark.parent = marker;\n    }\n  }\n}\n\nfunction detachSharedMarkers(markers) {\n  var loop = function ( i ) {\n    var marker = markers[i], linked = [marker.primary.doc];\n    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\n    for (var j = 0; j < marker.markers.length; j++) {\n      var subMarker = marker.markers[j];\n      if (indexOf(linked, subMarker.doc) == -1) {\n        subMarker.parent = null;\n        marker.markers.splice(j--, 1);\n      }\n    }\n  };\n\n  for (var i = 0; i < markers.length; i++) loop( i );\n}\n\nvar nextDocId = 0;\nvar Doc = function(text, mode, firstLine, lineSep, direction) {\n  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\n  if (firstLine == null) { firstLine = 0; }\n\n  BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n  this.first = firstLine;\n  this.scrollTop = this.scrollLeft = 0;\n  this.cantEdit = false;\n  this.cleanGeneration = 1;\n  this.modeFrontier = this.highlightFrontier = firstLine;\n  var start = Pos(firstLine, 0);\n  this.sel = simpleSelection(start);\n  this.history = new History(null);\n  this.id = ++nextDocId;\n  this.modeOption = mode;\n  this.lineSep = lineSep;\n  this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\n  this.extend = false;\n\n  if (typeof text == \"string\") { text = this.splitLines(text); }\n  updateDoc(this, {from: start, to: start, text: text});\n  setSelection(this, simpleSelection(start), sel_dontScroll);\n};\n\nDoc.prototype = createObj(BranchChunk.prototype, {\n  constructor: Doc,\n  // Iterate over the document. Supports two forms -- with only one\n  // argument, it calls that for each line in the document. With\n  // three, it iterates over the range given by the first two (with\n  // the second being non-inclusive).\n  iter: function(from, to, op) {\n    if (op) { this.iterN(from - this.first, to - from, op); }\n    else { this.iterN(this.first, this.first + this.size, from); }\n  },\n\n  // Non-public interface for adding and removing lines.\n  insert: function(at, lines) {\n    var height = 0;\n    for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\n    this.insertInner(at - this.first, lines, height);\n  },\n  remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n  // From here, the methods are part of the public interface. Most\n  // are also available from CodeMirror (editor) instances.\n\n  getValue: function(lineSep) {\n    var lines = getLines(this, this.first, this.first + this.size);\n    if (lineSep === false) { return lines }\n    return lines.join(lineSep || this.lineSeparator())\n  },\n  setValue: docMethodOp(function(code) {\n    var top = Pos(this.first, 0), last = this.first + this.size - 1;\n    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                      text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n    if (this.cm) { scrollToCoords(this.cm, 0, 0); }\n    setSelection(this, simpleSelection(top), sel_dontScroll);\n  }),\n  replaceRange: function(code, from, to, origin) {\n    from = clipPos(this, from);\n    to = to ? clipPos(this, to) : from;\n    replaceRange(this, code, from, to, origin);\n  },\n  getRange: function(from, to, lineSep) {\n    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n    if (lineSep === false) { return lines }\n    return lines.join(lineSep || this.lineSeparator())\n  },\n\n  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\n\n  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\n  getLineNumber: function(line) {return lineNo(line)},\n\n  getLineHandleVisualStart: function(line) {\n    if (typeof line == \"number\") { line = getLine(this, line); }\n    return visualLine(line)\n  },\n\n  lineCount: function() {return this.size},\n  firstLine: function() {return this.first},\n  lastLine: function() {return this.first + this.size - 1},\n\n  clipPos: function(pos) {return clipPos(this, pos)},\n\n  getCursor: function(start) {\n    var range$$1 = this.sel.primary(), pos;\n    if (start == null || start == \"head\") { pos = range$$1.head; }\n    else if (start == \"anchor\") { pos = range$$1.anchor; }\n    else if (start == \"end\" || start == \"to\" || start === false) { pos = range$$1.to(); }\n    else { pos = range$$1.from(); }\n    return pos\n  },\n  listSelections: function() { return this.sel.ranges },\n  somethingSelected: function() {return this.sel.somethingSelected()},\n\n  setCursor: docMethodOp(function(line, ch, options) {\n    setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n  }),\n  setSelection: docMethodOp(function(anchor, head, options) {\n    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n  }),\n  extendSelection: docMethodOp(function(head, other, options) {\n    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n  }),\n  extendSelections: docMethodOp(function(heads, options) {\n    extendSelections(this, clipPosArray(this, heads), options);\n  }),\n  extendSelectionsBy: docMethodOp(function(f, options) {\n    var heads = map(this.sel.ranges, f);\n    extendSelections(this, clipPosArray(this, heads), options);\n  }),\n  setSelections: docMethodOp(function(ranges, primary, options) {\n    var this$1 = this;\n\n    if (!ranges.length) { return }\n    var out = [];\n    for (var i = 0; i < ranges.length; i++)\n      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),\n                         clipPos(this$1, ranges[i].head)); }\n    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\n    setSelection(this, normalizeSelection(out, primary), options);\n  }),\n  addSelection: docMethodOp(function(anchor, head, options) {\n    var ranges = this.sel.ranges.slice(0);\n    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n  }),\n\n  getSelection: function(lineSep) {\n    var this$1 = this;\n\n    var ranges = this.sel.ranges, lines;\n    for (var i = 0; i < ranges.length; i++) {\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n      lines = lines ? lines.concat(sel) : sel;\n    }\n    if (lineSep === false) { return lines }\n    else { return lines.join(lineSep || this.lineSeparator()) }\n  },\n  getSelections: function(lineSep) {\n    var this$1 = this;\n\n    var parts = [], ranges = this.sel.ranges;\n    for (var i = 0; i < ranges.length; i++) {\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }\n      parts[i] = sel;\n    }\n    return parts\n  },\n  replaceSelection: function(code, collapse, origin) {\n    var dup = [];\n    for (var i = 0; i < this.sel.ranges.length; i++)\n      { dup[i] = code; }\n    this.replaceSelections(dup, collapse, origin || \"+input\");\n  },\n  replaceSelections: docMethodOp(function(code, collapse, origin) {\n    var this$1 = this;\n\n    var changes = [], sel = this.sel;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range$$1 = sel.ranges[i];\n      changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};\n    }\n    var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\n      { makeChange(this$1, changes[i$1]); }\n    if (newSel) { setSelectionReplaceHistory(this, newSel); }\n    else if (this.cm) { ensureCursorVisible(this.cm); }\n  }),\n  undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n  redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n  setExtending: function(val) {this.extend = val;},\n  getExtending: function() {return this.extend},\n\n  historySize: function() {\n    var hist = this.history, done = 0, undone = 0;\n    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\n    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\n    return {undo: done, redo: undone}\n  },\n  clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\n  markClean: function() {\n    this.cleanGeneration = this.changeGeneration(true);\n  },\n  changeGeneration: function(forceSplit) {\n    if (forceSplit)\n      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\n    return this.history.generation\n  },\n  isClean: function (gen) {\n    return this.history.generation == (gen || this.cleanGeneration)\n  },\n\n  getHistory: function() {\n    return {done: copyHistoryArray(this.history.done),\n            undone: copyHistoryArray(this.history.undone)}\n  },\n  setHistory: function(histData) {\n    var hist = this.history = new History(this.history.maxGeneration);\n    hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n  },\n\n  setGutterMarker: docMethodOp(function(line, gutterID, value) {\n    return changeLine(this, line, \"gutter\", function (line) {\n      var markers = line.gutterMarkers || (line.gutterMarkers = {});\n      markers[gutterID] = value;\n      if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\n      return true\n    })\n  }),\n\n  clearGutter: docMethodOp(function(gutterID) {\n    var this$1 = this;\n\n    this.iter(function (line) {\n      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n        changeLine(this$1, line, \"gutter\", function () {\n          line.gutterMarkers[gutterID] = null;\n          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\n          return true\n        });\n      }\n    });\n  }),\n\n  lineInfo: function(line) {\n    var n;\n    if (typeof line == \"number\") {\n      if (!isLine(this, line)) { return null }\n      n = line;\n      line = getLine(this, line);\n      if (!line) { return null }\n    } else {\n      n = lineNo(line);\n      if (n == null) { return null }\n    }\n    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n            widgets: line.widgets}\n  },\n\n  addLineClass: docMethodOp(function(handle, where, cls) {\n    return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n      var prop = where == \"text\" ? \"textClass\"\n               : where == \"background\" ? \"bgClass\"\n               : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n      if (!line[prop]) { line[prop] = cls; }\n      else if (classTest(cls).test(line[prop])) { return false }\n      else { line[prop] += \" \" + cls; }\n      return true\n    })\n  }),\n  removeLineClass: docMethodOp(function(handle, where, cls) {\n    return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n      var prop = where == \"text\" ? \"textClass\"\n               : where == \"background\" ? \"bgClass\"\n               : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n      var cur = line[prop];\n      if (!cur) { return false }\n      else if (cls == null) { line[prop] = null; }\n      else {\n        var found = cur.match(classTest(cls));\n        if (!found) { return false }\n        var end = found.index + found[0].length;\n        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n      }\n      return true\n    })\n  }),\n\n  addLineWidget: docMethodOp(function(handle, node, options) {\n    return addLineWidget(this, handle, node, options)\n  }),\n  removeLineWidget: function(widget) { widget.clear(); },\n\n  markText: function(from, to, options) {\n    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\")\n  },\n  setBookmark: function(pos, options) {\n    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                    insertLeft: options && options.insertLeft,\n                    clearWhenEmpty: false, shared: options && options.shared,\n                    handleMouseEvents: options && options.handleMouseEvents};\n    pos = clipPos(this, pos);\n    return markText(this, pos, pos, realOpts, \"bookmark\")\n  },\n  findMarksAt: function(pos) {\n    pos = clipPos(this, pos);\n    var markers = [], spans = getLine(this, pos.line).markedSpans;\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if ((span.from == null || span.from <= pos.ch) &&\n          (span.to == null || span.to >= pos.ch))\n        { markers.push(span.marker.parent || span.marker); }\n    } }\n    return markers\n  },\n  findMarks: function(from, to, filter) {\n    from = clipPos(this, from); to = clipPos(this, to);\n    var found = [], lineNo$$1 = from.line;\n    this.iter(from.line, to.line + 1, function (line) {\n      var spans = line.markedSpans;\n      if (spans) { for (var i = 0; i < spans.length; i++) {\n        var span = spans[i];\n        if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||\n              span.from == null && lineNo$$1 != from.line ||\n              span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&\n            (!filter || filter(span.marker)))\n          { found.push(span.marker.parent || span.marker); }\n      } }\n      ++lineNo$$1;\n    });\n    return found\n  },\n  getAllMarks: function() {\n    var markers = [];\n    this.iter(function (line) {\n      var sps = line.markedSpans;\n      if (sps) { for (var i = 0; i < sps.length; ++i)\n        { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\n    });\n    return markers\n  },\n\n  posFromIndex: function(off) {\n    var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;\n    this.iter(function (line) {\n      var sz = line.text.length + sepSize;\n      if (sz > off) { ch = off; return true }\n      off -= sz;\n      ++lineNo$$1;\n    });\n    return clipPos(this, Pos(lineNo$$1, ch))\n  },\n  indexFromPos: function (coords) {\n    coords = clipPos(this, coords);\n    var index = coords.ch;\n    if (coords.line < this.first || coords.ch < 0) { return 0 }\n    var sepSize = this.lineSeparator().length;\n    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\n      index += line.text.length + sepSize;\n    });\n    return index\n  },\n\n  copy: function(copyHistory) {\n    var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                      this.modeOption, this.first, this.lineSep, this.direction);\n    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n    doc.sel = this.sel;\n    doc.extend = false;\n    if (copyHistory) {\n      doc.history.undoDepth = this.history.undoDepth;\n      doc.setHistory(this.getHistory());\n    }\n    return doc\n  },\n\n  linkedDoc: function(options) {\n    if (!options) { options = {}; }\n    var from = this.first, to = this.first + this.size;\n    if (options.from != null && options.from > from) { from = options.from; }\n    if (options.to != null && options.to < to) { to = options.to; }\n    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n    if (options.sharedHist) { copy.history = this.history\n    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n    copySharedMarkers(copy, findSharedMarkers(this));\n    return copy\n  },\n  unlinkDoc: function(other) {\n    var this$1 = this;\n\n    if (other instanceof CodeMirror$1) { other = other.doc; }\n    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\n      var link = this$1.linked[i];\n      if (link.doc != other) { continue }\n      this$1.linked.splice(i, 1);\n      other.unlinkDoc(this$1);\n      detachSharedMarkers(findSharedMarkers(this$1));\n      break\n    } }\n    // If the histories were shared, split them again\n    if (other.history == this.history) {\n      var splitIds = [other.id];\n      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\n      other.history = new History(null);\n      other.history.done = copyHistoryArray(this.history.done, splitIds);\n      other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n    }\n  },\n  iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n  getMode: function() {return this.mode},\n  getEditor: function() {return this.cm},\n\n  splitLines: function(str) {\n    if (this.lineSep) { return str.split(this.lineSep) }\n    return splitLinesAuto(str)\n  },\n  lineSeparator: function() { return this.lineSep || \"\\n\" },\n\n  setDirection: docMethodOp(function (dir) {\n    if (dir != \"rtl\") { dir = \"ltr\"; }\n    if (dir == this.direction) { return }\n    this.direction = dir;\n    this.iter(function (line) { return line.order = null; });\n    if (this.cm) { directionChanged(this.cm); }\n  })\n});\n\n// Public alias.\nDoc.prototype.eachLine = Doc.prototype.iter;\n\n// Kludge to work around strange IE behavior where it'll sometimes\n// re-fire a series of drag-related events right after the drop (#1551)\nvar lastDrop = 0;\n\nfunction onDrop(e) {\n  var cm = this;\n  clearDragCursor(cm);\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n    { return }\n  e_preventDefault(e);\n  if (ie) { lastDrop = +new Date; }\n  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n  if (!pos || cm.isReadOnly()) { return }\n  // Might be a file drop, in which case we simply extract the text\n  // and insert it.\n  if (files && files.length && window.FileReader && window.File) {\n    var n = files.length, text = Array(n), read = 0;\n    var loadFile = function (file, i) {\n      if (cm.options.allowDropFileTypes &&\n          indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n        { return }\n\n      var reader = new FileReader;\n      reader.onload = operation(cm, function () {\n        var content = reader.result;\n        if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) { content = \"\"; }\n        text[i] = content;\n        if (++read == n) {\n          pos = clipPos(cm.doc, pos);\n          var change = {from: pos, to: pos,\n                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n                        origin: \"paste\"};\n          makeChange(cm.doc, change);\n          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n        }\n      });\n      reader.readAsText(file);\n    };\n    for (var i = 0; i < n; ++i) { loadFile(files[i], i); }\n  } else { // Normal drop\n    // Don't do a replace if the drop happened inside of the selected text.\n    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n      cm.state.draggingText(e);\n      // Ensure the editor is re-focused\n      setTimeout(function () { return cm.display.input.focus(); }, 20);\n      return\n    }\n    try {\n      var text$1 = e.dataTransfer.getData(\"Text\");\n      if (text$1) {\n        var selected;\n        if (cm.state.draggingText && !cm.state.draggingText.copy)\n          { selected = cm.listSelections(); }\n        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\n          { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\n        cm.replaceSelection(text$1, \"around\", \"paste\");\n        cm.display.input.focus();\n      }\n    }\n    catch(e){}\n  }\n}\n\nfunction onDragStart(cm, e) {\n  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\n\n  e.dataTransfer.setData(\"Text\", cm.getSelection());\n  e.dataTransfer.effectAllowed = \"copyMove\";\n\n  // Use dummy image instead of default browsers image.\n  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n  if (e.dataTransfer.setDragImage && !safari) {\n    var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n    img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    if (presto) {\n      img.width = img.height = 1;\n      cm.display.wrapper.appendChild(img);\n      // Force a relayout, or Opera won't use our image for some obscure reason\n      img._top = img.offsetTop;\n    }\n    e.dataTransfer.setDragImage(img, 0, 0);\n    if (presto) { img.parentNode.removeChild(img); }\n  }\n}\n\nfunction onDragOver(cm, e) {\n  var pos = posFromMouse(cm, e);\n  if (!pos) { return }\n  var frag = document.createDocumentFragment();\n  drawSelectionCursor(cm, pos, frag);\n  if (!cm.display.dragCursor) {\n    cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n  }\n  removeChildrenAndAdd(cm.display.dragCursor, frag);\n}\n\nfunction clearDragCursor(cm) {\n  if (cm.display.dragCursor) {\n    cm.display.lineSpace.removeChild(cm.display.dragCursor);\n    cm.display.dragCursor = null;\n  }\n}\n\n// These must be handled carefully, because naively registering a\n// handler for each editor will cause the editors to never be\n// garbage collected.\n\nfunction forEachCodeMirror(f) {\n  if (!document.getElementsByClassName) { return }\n  var byClass = document.getElementsByClassName(\"CodeMirror\");\n  for (var i = 0; i < byClass.length; i++) {\n    var cm = byClass[i].CodeMirror;\n    if (cm) { f(cm); }\n  }\n}\n\nvar globalsRegistered = false;\nfunction ensureGlobalHandlers() {\n  if (globalsRegistered) { return }\n  registerGlobalHandlers();\n  globalsRegistered = true;\n}\nfunction registerGlobalHandlers() {\n  // When the window resizes, we need to refresh active editors.\n  var resizeTimer;\n  on(window, \"resize\", function () {\n    if (resizeTimer == null) { resizeTimer = setTimeout(function () {\n      resizeTimer = null;\n      forEachCodeMirror(onResize);\n    }, 100); }\n  });\n  // When the window loses focus, we want to show the editor as blurred\n  on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\n}\n// Called when the window resizes\nfunction onResize(cm) {\n  var d = cm.display;\n  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\n    { return }\n  // Might be a text scaling operation, clear size caches.\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n  d.scrollbarsClipped = false;\n  cm.setSize();\n}\n\nvar keyNames = {\n  3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n  19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n  36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n  46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n  106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\n  173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n  221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n  63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n};\n\n// Number keys\nfor (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\n// Alphabetic keys\nfor (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\n// Function keys\nfor (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\n\nvar keyMap = {};\n\nkeyMap.basic = {\n  \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n  \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n  \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n  \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n  \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n  \"Esc\": \"singleSelection\"\n};\n// Note that the save and find-related commands aren't defined by\n// default. User code or addons can define them. Unknown commands\n// are simply ignored.\nkeyMap.pcDefault = {\n  \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n  \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n  \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n  \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n  \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n  \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n  \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n  fallthrough: \"basic\"\n};\n// Very basic readline/emacs-style bindings, which are standard on Mac.\nkeyMap.emacsy = {\n  \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n  \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n  \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n  \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\n  \"Ctrl-O\": \"openLine\"\n};\nkeyMap.macDefault = {\n  \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n  \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n  \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n  \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n  \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n  \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n  \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n  fallthrough: [\"basic\", \"emacsy\"]\n};\nkeyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n// KEYMAP DISPATCH\n\nfunction normalizeKeyName(name) {\n  var parts = name.split(/-(?!$)/);\n  name = parts[parts.length - 1];\n  var alt, ctrl, shift, cmd;\n  for (var i = 0; i < parts.length - 1; i++) {\n    var mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\n    else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n    else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n    else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n  }\n  if (alt) { name = \"Alt-\" + name; }\n  if (ctrl) { name = \"Ctrl-\" + name; }\n  if (cmd) { name = \"Cmd-\" + name; }\n  if (shift) { name = \"Shift-\" + name; }\n  return name\n}\n\n// This is a kludge to keep keymaps mostly working as raw objects\n// (backwards compatibility) while at the same time support features\n// like normalization and multi-stroke key bindings. It compiles a\n// new normalized keymap, and then updates the old object to reflect\n// this.\nfunction normalizeKeyMap(keymap) {\n  var copy = {};\n  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\n    var value = keymap[keyname];\n    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\n    if (value == \"...\") { delete keymap[keyname]; continue }\n\n    var keys = map(keyname.split(\" \"), normalizeKeyName);\n    for (var i = 0; i < keys.length; i++) {\n      var val = (void 0), name = (void 0);\n      if (i == keys.length - 1) {\n        name = keys.join(\" \");\n        val = value;\n      } else {\n        name = keys.slice(0, i + 1).join(\" \");\n        val = \"...\";\n      }\n      var prev = copy[name];\n      if (!prev) { copy[name] = val; }\n      else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\n    }\n    delete keymap[keyname];\n  } }\n  for (var prop in copy) { keymap[prop] = copy[prop]; }\n  return keymap\n}\n\nfunction lookupKey(key, map$$1, handle, context) {\n  map$$1 = getKeyMap(map$$1);\n  var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];\n  if (found === false) { return \"nothing\" }\n  if (found === \"...\") { return \"multi\" }\n  if (found != null && handle(found)) { return \"handled\" }\n\n  if (map$$1.fallthrough) {\n    if (Object.prototype.toString.call(map$$1.fallthrough) != \"[object Array]\")\n      { return lookupKey(key, map$$1.fallthrough, handle, context) }\n    for (var i = 0; i < map$$1.fallthrough.length; i++) {\n      var result = lookupKey(key, map$$1.fallthrough[i], handle, context);\n      if (result) { return result }\n    }\n  }\n}\n\n// Modifier key presses don't count as 'real' key presses for the\n// purpose of keymap fallthrough.\nfunction isModifierKey(value) {\n  var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n  return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\n}\n\nfunction addModifierNames(name, event, noShift) {\n  var base = name;\n  if (event.altKey && base != \"Alt\") { name = \"Alt-\" + name; }\n  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") { name = \"Ctrl-\" + name; }\n  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") { name = \"Cmd-\" + name; }\n  if (!noShift && event.shiftKey && base != \"Shift\") { name = \"Shift-\" + name; }\n  return name\n}\n\n// Look up the name of a key as indicated by an event object.\nfunction keyName(event, noShift) {\n  if (presto && event.keyCode == 34 && event[\"char\"]) { return false }\n  var name = keyNames[event.keyCode];\n  if (name == null || event.altGraphKey) { return false }\n  return addModifierNames(name, event, noShift)\n}\n\nfunction getKeyMap(val) {\n  return typeof val == \"string\" ? keyMap[val] : val\n}\n\n// Helper for deleting text near the selection(s), used to implement\n// backspace, delete, and similar functionality.\nfunction deleteNearSelection(cm, compute) {\n  var ranges = cm.doc.sel.ranges, kill = [];\n  // Build up a set of ranges to kill first, merging overlapping\n  // ranges.\n  for (var i = 0; i < ranges.length; i++) {\n    var toKill = compute(ranges[i]);\n    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n      var replaced = kill.pop();\n      if (cmp(replaced.from, toKill.from) < 0) {\n        toKill.from = replaced.from;\n        break\n      }\n    }\n    kill.push(toKill);\n  }\n  // Next, remove those actual ranges.\n  runInOp(cm, function () {\n    for (var i = kill.length - 1; i >= 0; i--)\n      { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\n    ensureCursorVisible(cm);\n  });\n}\n\n// Commands are parameter-less actions that can be performed on an\n// editor, mostly used for keybindings.\nvar commands = {\n  selectAll: selectAll,\n  singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\n  killLine: function (cm) { return deleteNearSelection(cm, function (range) {\n    if (range.empty()) {\n      var len = getLine(cm.doc, range.head.line).text.length;\n      if (range.head.ch == len && range.head.line < cm.lastLine())\n        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\n      else\n        { return {from: range.head, to: Pos(range.head.line, len)} }\n    } else {\n      return {from: range.from(), to: range.to()}\n    }\n  }); },\n  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n    from: Pos(range.from().line, 0),\n    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n  }); }); },\n  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n    from: Pos(range.from().line, 0), to: range.from()\n  }); }); },\n  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n    return {from: leftPos, to: range.from()}\n  }); },\n  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n    return {from: range.from(), to: rightPos }\n  }); },\n  undo: function (cm) { return cm.undo(); },\n  redo: function (cm) { return cm.redo(); },\n  undoSelection: function (cm) { return cm.undoSelection(); },\n  redoSelection: function (cm) { return cm.redoSelection(); },\n  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\n  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\n  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\n    {origin: \"+move\", bias: 1}\n  ); },\n  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\n    {origin: \"+move\", bias: 1}\n  ); },\n  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\n    {origin: \"+move\", bias: -1}\n  ); },\n  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.cursorCoords(range.head, \"div\").top + 5;\n    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\n  }, sel_move); },\n  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.cursorCoords(range.head, \"div\").top + 5;\n    return cm.coordsChar({left: 0, top: top}, \"div\")\n  }, sel_move); },\n  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.cursorCoords(range.head, \"div\").top + 5;\n    var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n    if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\n    return pos\n  }, sel_move); },\n  goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\n  goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\n  goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\n  goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\n  goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\n  goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\n  goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\n  goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\n  goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\n  goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\n  goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\n  goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\n  delCharBefore: function (cm) { return cm.deleteH(-1, \"char\"); },\n  delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\n  delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\n  delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\n  delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\n  delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\n  indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\n  indentMore: function (cm) { return cm.indentSelection(\"add\"); },\n  indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\n  insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\n  insertSoftTab: function (cm) {\n    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n    for (var i = 0; i < ranges.length; i++) {\n      var pos = ranges[i].from();\n      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n      spaces.push(spaceStr(tabSize - col % tabSize));\n    }\n    cm.replaceSelections(spaces);\n  },\n  defaultTab: function (cm) {\n    if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\n    else { cm.execCommand(\"insertTab\"); }\n  },\n  // Swap the two chars left and right of each selection's head.\n  // Move cursor behind the two swapped characters afterwards.\n  //\n  // Doesn't consider line feeds a character.\n  // Doesn't scan more than one line above to find a character.\n  // Doesn't do anything on an empty line.\n  // Doesn't do anything with non-empty selections.\n  transposeChars: function (cm) { return runInOp(cm, function () {\n    var ranges = cm.listSelections(), newSel = [];\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) { continue }\n      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n      if (line) {\n        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\n        if (cur.ch > 0) {\n          cur = new Pos(cur.line, cur.ch + 1);\n          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                          Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n        } else if (cur.line > cm.doc.first) {\n          var prev = getLine(cm.doc, cur.line - 1).text;\n          if (prev) {\n            cur = new Pos(cur.line, 1);\n            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                            prev.charAt(prev.length - 1),\n                            Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n          }\n        }\n      }\n      newSel.push(new Range(cur, cur));\n    }\n    cm.setSelections(newSel);\n  }); },\n  newlineAndIndent: function (cm) { return runInOp(cm, function () {\n    var sels = cm.listSelections();\n    for (var i = sels.length - 1; i >= 0; i--)\n      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\n    sels = cm.listSelections();\n    for (var i$1 = 0; i$1 < sels.length; i$1++)\n      { cm.indentLine(sels[i$1].from().line, null, true); }\n    ensureCursorVisible(cm);\n  }); },\n  openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\n  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\n};\n\n\nfunction lineStart(cm, lineN) {\n  var line = getLine(cm.doc, lineN);\n  var visual = visualLine(line);\n  if (visual != line) { lineN = lineNo(visual); }\n  return endOfLine(true, cm, visual, lineN, 1)\n}\nfunction lineEnd(cm, lineN) {\n  var line = getLine(cm.doc, lineN);\n  var visual = visualLineEnd(line);\n  if (visual != line) { lineN = lineNo(visual); }\n  return endOfLine(true, cm, line, lineN, -1)\n}\nfunction lineStartSmart(cm, pos) {\n  var start = lineStart(cm, pos.line);\n  var line = getLine(cm.doc, start.line);\n  var order = getOrder(line, cm.doc.direction);\n  if (!order || order[0].level == 0) {\n    var firstNonWS = Math.max(0, line.text.search(/\\S/));\n    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\n  }\n  return start\n}\n\n// Run a handler that was bound to a key.\nfunction doHandleBinding(cm, bound, dropShift) {\n  if (typeof bound == \"string\") {\n    bound = commands[bound];\n    if (!bound) { return false }\n  }\n  // Ensure previous input has been read, so that the handler sees a\n  // consistent view of the document\n  cm.display.input.ensurePolled();\n  var prevShift = cm.display.shift, done = false;\n  try {\n    if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n    if (dropShift) { cm.display.shift = false; }\n    done = bound(cm) != Pass;\n  } finally {\n    cm.display.shift = prevShift;\n    cm.state.suppressEdits = false;\n  }\n  return done\n}\n\nfunction lookupKeyForEditor(cm, name, handle) {\n  for (var i = 0; i < cm.state.keyMaps.length; i++) {\n    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n    if (result) { return result }\n  }\n  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n    || lookupKey(name, cm.options.keyMap, handle, cm)\n}\n\n// Note that, despite the name, this function is also used to check\n// for bound mouse clicks.\n\nvar stopSeq = new Delayed;\nfunction dispatchKey(cm, name, e, handle) {\n  var seq = cm.state.keySeq;\n  if (seq) {\n    if (isModifierKey(name)) { return \"handled\" }\n    stopSeq.set(50, function () {\n      if (cm.state.keySeq == seq) {\n        cm.state.keySeq = null;\n        cm.display.input.reset();\n      }\n    });\n    name = seq + \" \" + name;\n  }\n  var result = lookupKeyForEditor(cm, name, handle);\n\n  if (result == \"multi\")\n    { cm.state.keySeq = name; }\n  if (result == \"handled\")\n    { signalLater(cm, \"keyHandled\", cm, name, e); }\n\n  if (result == \"handled\" || result == \"multi\") {\n    e_preventDefault(e);\n    restartBlink(cm);\n  }\n\n  if (seq && !result && /\\'$/.test(name)) {\n    e_preventDefault(e);\n    return true\n  }\n  return !!result\n}\n\n// Handle a key from the keydown event.\nfunction handleKeyBinding(cm, e) {\n  var name = keyName(e, true);\n  if (!name) { return false }\n\n  if (e.shiftKey && !cm.state.keySeq) {\n    // First try to resolve full name (including 'Shift-'). Failing\n    // that, see if there is a cursor-motion command (starting with\n    // 'go') bound to the keyname without 'Shift-'.\n    return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\n        || dispatchKey(cm, name, e, function (b) {\n             if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n               { return doHandleBinding(cm, b) }\n           })\n  } else {\n    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\n  }\n}\n\n// Handle a key from the keypress event\nfunction handleCharBinding(cm, e, ch) {\n  return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\n}\n\nvar lastStoppedKey = null;\nfunction onKeyDown(e) {\n  var cm = this;\n  cm.curOp.focus = activeElt();\n  if (signalDOMEvent(cm, e)) { return }\n  // IE does strange things with escape.\n  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\n  var code = e.keyCode;\n  cm.display.shift = code == 16 || e.shiftKey;\n  var handled = handleKeyBinding(cm, e);\n  if (presto) {\n    lastStoppedKey = handled ? code : null;\n    // Opera has no cut event... we try to at least catch the key combo\n    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n      { cm.replaceSelection(\"\", null, \"cut\"); }\n  }\n\n  // Turn mouse into crosshair when Alt is held on Mac.\n  if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n    { showCrossHair(cm); }\n}\n\nfunction showCrossHair(cm) {\n  var lineDiv = cm.display.lineDiv;\n  addClass(lineDiv, \"CodeMirror-crosshair\");\n\n  function up(e) {\n    if (e.keyCode == 18 || !e.altKey) {\n      rmClass(lineDiv, \"CodeMirror-crosshair\");\n      off(document, \"keyup\", up);\n      off(document, \"mouseover\", up);\n    }\n  }\n  on(document, \"keyup\", up);\n  on(document, \"mouseover\", up);\n}\n\nfunction onKeyUp(e) {\n  if (e.keyCode == 16) { this.doc.sel.shift = false; }\n  signalDOMEvent(this, e);\n}\n\nfunction onKeyPress(e) {\n  var cm = this;\n  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\n  var keyCode = e.keyCode, charCode = e.charCode;\n  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\n  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\n  var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n  // Some browsers fire keypress events for backspace\n  if (ch == \"\\x08\") { return }\n  if (handleCharBinding(cm, e, ch)) { return }\n  cm.display.input.onKeyPress(e);\n}\n\nvar DOUBLECLICK_DELAY = 400;\n\nvar PastClick = function(time, pos, button) {\n  this.time = time;\n  this.pos = pos;\n  this.button = button;\n};\n\nPastClick.prototype.compare = function (time, pos, button) {\n  return this.time + DOUBLECLICK_DELAY > time &&\n    cmp(pos, this.pos) == 0 && button == this.button\n};\n\nvar lastClick;\nvar lastDoubleClick;\nfunction clickRepeat(pos, button) {\n  var now = +new Date;\n  if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n    lastClick = lastDoubleClick = null;\n    return \"triple\"\n  } else if (lastClick && lastClick.compare(now, pos, button)) {\n    lastDoubleClick = new PastClick(now, pos, button);\n    lastClick = null;\n    return \"double\"\n  } else {\n    lastClick = new PastClick(now, pos, button);\n    lastDoubleClick = null;\n    return \"single\"\n  }\n}\n\n// A mouse down can be a single click, double click, triple click,\n// start of selection drag, start of text drag, new cursor\n// (ctrl-click), rectangle drag (alt-drag), or xwin\n// middle-click-paste. Or it might be a click on something we should\n// not interfere with, such as a scrollbar or widget.\nfunction onMouseDown(e) {\n  var cm = this, display = cm.display;\n  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\n  display.input.ensurePolled();\n  display.shift = e.shiftKey;\n\n  if (eventInWidget(display, e)) {\n    if (!webkit) {\n      // Briefly turn off draggability, to allow widgets to do\n      // normal dragging things.\n      display.scroller.draggable = false;\n      setTimeout(function () { return display.scroller.draggable = true; }, 100);\n    }\n    return\n  }\n  if (clickInGutter(cm, e)) { return }\n  var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : \"single\";\n  window.focus();\n\n  // #3261: make sure, that we're not starting a second selection\n  if (button == 1 && cm.state.selectingText)\n    { cm.state.selectingText(e); }\n\n  if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }\n\n  if (button == 1) {\n    if (pos) { leftButtonDown(cm, pos, repeat, e); }\n    else if (e_target(e) == display.scroller) { e_preventDefault(e); }\n  } else if (button == 2) {\n    if (pos) { extendSelection(cm.doc, pos); }\n    setTimeout(function () { return display.input.focus(); }, 20);\n  } else if (button == 3) {\n    if (captureRightClick) { onContextMenu(cm, e); }\n    else { delayBlurEvent(cm); }\n  }\n}\n\nfunction handleMappedButton(cm, button, pos, repeat, event) {\n  var name = \"Click\";\n  if (repeat == \"double\") { name = \"Double\" + name; }\n  else if (repeat == \"triple\") { name = \"Triple\" + name; }\n  name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\n\n  return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {\n    if (typeof bound == \"string\") { bound = commands[bound]; }\n    if (!bound) { return false }\n    var done = false;\n    try {\n      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n      done = bound(cm, pos) != Pass;\n    } finally {\n      cm.state.suppressEdits = false;\n    }\n    return done\n  })\n}\n\nfunction configureMouse(cm, repeat, event) {\n  var option = cm.getOption(\"configureMouse\");\n  var value = option ? option(cm, repeat, event) : {};\n  if (value.unit == null) {\n    var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n    value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n  }\n  if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }\n  if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }\n  if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }\n  return value\n}\n\nfunction leftButtonDown(cm, pos, repeat, event) {\n  if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\n  else { cm.curOp.focus = activeElt(); }\n\n  var behavior = configureMouse(cm, repeat, event);\n\n  var sel = cm.doc.sel, contained;\n  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n      repeat == \"single\" && (contained = sel.contains(pos)) > -1 &&\n      (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&\n      (cmp(contained.to(), pos) > 0 || pos.xRel < 0))\n    { leftButtonStartDrag(cm, event, pos, behavior); }\n  else\n    { leftButtonSelect(cm, event, pos, behavior); }\n}\n\n// Start a text drag. When it ends, see if any dragging actually\n// happen, and treat as a click if it didn't.\nfunction leftButtonStartDrag(cm, event, pos, behavior) {\n  var display = cm.display, moved = false;\n  var dragEnd = operation(cm, function (e) {\n    if (webkit) { display.scroller.draggable = false; }\n    cm.state.draggingText = false;\n    off(document, \"mouseup\", dragEnd);\n    off(document, \"mousemove\", mouseMove);\n    off(display.scroller, \"dragstart\", dragStart);\n    off(display.scroller, \"drop\", dragEnd);\n    if (!moved) {\n      e_preventDefault(e);\n      if (!behavior.addNew)\n        { extendSelection(cm.doc, pos, null, null, behavior.extend); }\n      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n      if (webkit || ie && ie_version == 9)\n        { setTimeout(function () {document.body.focus(); display.input.focus();}, 20); }\n      else\n        { display.input.focus(); }\n    }\n  });\n  var mouseMove = function(e2) {\n    moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n  };\n  var dragStart = function () { return moved = true; };\n  // Let the drag handler handle this.\n  if (webkit) { display.scroller.draggable = true; }\n  cm.state.draggingText = dragEnd;\n  dragEnd.copy = !behavior.moveOnDrag;\n  // IE's approach to draggable\n  if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\n  on(document, \"mouseup\", dragEnd);\n  on(document, \"mousemove\", mouseMove);\n  on(display.scroller, \"dragstart\", dragStart);\n  on(display.scroller, \"drop\", dragEnd);\n\n  delayBlurEvent(cm);\n  setTimeout(function () { return display.input.focus(); }, 20);\n}\n\nfunction rangeForUnit(cm, pos, unit) {\n  if (unit == \"char\") { return new Range(pos, pos) }\n  if (unit == \"word\") { return cm.findWordAt(pos) }\n  if (unit == \"line\") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\n  var result = unit(cm, pos);\n  return new Range(result.from, result.to)\n}\n\n// Normal selection, as opposed to text dragging.\nfunction leftButtonSelect(cm, event, start, behavior) {\n  var display = cm.display, doc = cm.doc;\n  e_preventDefault(event);\n\n  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n  if (behavior.addNew && !behavior.extend) {\n    ourIndex = doc.sel.contains(start);\n    if (ourIndex > -1)\n      { ourRange = ranges[ourIndex]; }\n    else\n      { ourRange = new Range(start, start); }\n  } else {\n    ourRange = doc.sel.primary();\n    ourIndex = doc.sel.primIndex;\n  }\n\n  if (behavior.unit == \"rectangle\") {\n    if (!behavior.addNew) { ourRange = new Range(start, start); }\n    start = posFromMouse(cm, event, true, true);\n    ourIndex = -1;\n  } else {\n    var range$$1 = rangeForUnit(cm, start, behavior.unit);\n    if (behavior.extend)\n      { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }\n    else\n      { ourRange = range$$1; }\n  }\n\n  if (!behavior.addNew) {\n    ourIndex = 0;\n    setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n    startSel = doc.sel;\n  } else if (ourIndex == -1) {\n    ourIndex = ranges.length;\n    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\n                 {scroll: false, origin: \"*mouse\"});\n  } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\n    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                 {scroll: false, origin: \"*mouse\"});\n    startSel = doc.sel;\n  } else {\n    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n  }\n\n  var lastPos = start;\n  function extendTo(pos) {\n    if (cmp(lastPos, pos) == 0) { return }\n    lastPos = pos;\n\n    if (behavior.unit == \"rectangle\") {\n      var ranges = [], tabSize = cm.options.tabSize;\n      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n           line <= end; line++) {\n        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n        if (left == right)\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\n        else if (text.length > leftPos)\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\n      }\n      if (!ranges.length) { ranges.push(new Range(start, start)); }\n      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                   {origin: \"*mouse\", scroll: false});\n      cm.scrollIntoView(pos);\n    } else {\n      var oldRange = ourRange;\n      var range$$1 = rangeForUnit(cm, pos, behavior.unit);\n      var anchor = oldRange.anchor, head;\n      if (cmp(range$$1.anchor, anchor) > 0) {\n        head = range$$1.head;\n        anchor = minPos(oldRange.from(), range$$1.anchor);\n      } else {\n        head = range$$1.anchor;\n        anchor = maxPos(oldRange.to(), range$$1.head);\n      }\n      var ranges$1 = startSel.ranges.slice(0);\n      ranges$1[ourIndex] = new Range(clipPos(doc, anchor), head);\n      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);\n    }\n  }\n\n  var editorSize = display.wrapper.getBoundingClientRect();\n  // Used to ensure timeout re-tries don't fire when another extend\n  // happened in the meantime (clearTimeout isn't reliable -- at\n  // least on Chrome, the timeouts still happen even when cleared,\n  // if the clear happens after their scheduled firing time).\n  var counter = 0;\n\n  function extend(e) {\n    var curCount = ++counter;\n    var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n    if (!cur) { return }\n    if (cmp(cur, lastPos) != 0) {\n      cm.curOp.focus = activeElt();\n      extendTo(cur);\n      var visible = visibleLines(display, doc);\n      if (cur.line >= visible.to || cur.line < visible.from)\n        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\n    } else {\n      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n      if (outside) { setTimeout(operation(cm, function () {\n        if (counter != curCount) { return }\n        display.scroller.scrollTop += outside;\n        extend(e);\n      }), 50); }\n    }\n  }\n\n  function done(e) {\n    cm.state.selectingText = false;\n    counter = Infinity;\n    e_preventDefault(e);\n    display.input.focus();\n    off(document, \"mousemove\", move);\n    off(document, \"mouseup\", up);\n    doc.history.lastSelOrigin = null;\n  }\n\n  var move = operation(cm, function (e) {\n    if (!e_button(e)) { done(e); }\n    else { extend(e); }\n  });\n  var up = operation(cm, done);\n  cm.state.selectingText = up;\n  on(document, \"mousemove\", move);\n  on(document, \"mouseup\", up);\n}\n\n\n// Determines whether an event happened in the gutter, and fires the\n// handlers for the corresponding event.\nfunction gutterEvent(cm, e, type, prevent) {\n  var mX, mY;\n  try { mX = e.clientX; mY = e.clientY; }\n  catch(e) { return false }\n  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\n  if (prevent) { e_preventDefault(e); }\n\n  var display = cm.display;\n  var lineBox = display.lineDiv.getBoundingClientRect();\n\n  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\n  mY -= lineBox.top - display.viewOffset;\n\n  for (var i = 0; i < cm.options.gutters.length; ++i) {\n    var g = display.gutters.childNodes[i];\n    if (g && g.getBoundingClientRect().right >= mX) {\n      var line = lineAtHeight(cm.doc, mY);\n      var gutter = cm.options.gutters[i];\n      signal(cm, type, cm, line, gutter, e);\n      return e_defaultPrevented(e)\n    }\n  }\n}\n\nfunction clickInGutter(cm, e) {\n  return gutterEvent(cm, e, \"gutterClick\", true)\n}\n\n// CONTEXT MENU HANDLING\n\n// To make the context menu work, we need to briefly unhide the\n// textarea (making it as unobtrusive as possible) to let the\n// right-click take effect on it.\nfunction onContextMenu(cm, e) {\n  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\n  if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\n  cm.display.input.onContextMenu(e);\n}\n\nfunction contextMenuInGutter(cm, e) {\n  if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\n  return gutterEvent(cm, e, \"gutterContextMenu\", false)\n}\n\nfunction themeChanged(cm) {\n  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n    cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n  clearCaches(cm);\n}\n\nvar Init = {toString: function(){return \"CodeMirror.Init\"}};\n\nvar defaults = {};\nvar optionHandlers = {};\n\nfunction defineOptions(CodeMirror) {\n  var optionHandlers = CodeMirror.optionHandlers;\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) { optionHandlers[name] =\n      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\n  }\n\n  CodeMirror.defineOption = option;\n\n  // Passed to option handlers when there is no old value.\n  CodeMirror.Init = Init;\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\n  option(\"mode\", null, function (cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option(\"indentUnit\", 2, loadMode, true);\n  option(\"indentWithTabs\", false);\n  option(\"smartIndent\", true);\n  option(\"tabSize\", 4, function (cm) {\n    resetModeState(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option(\"lineSeparator\", null, function (cm, val) {\n    cm.doc.lineSep = val;\n    if (!val) { return }\n    var newBreaks = [], lineNo = cm.doc.first;\n    cm.doc.iter(function (line) {\n      for (var pos = 0;;) {\n        var found = line.text.indexOf(val, pos);\n        if (found == -1) { break }\n        pos = found + val.length;\n        newBreaks.push(Pos(lineNo, found));\n      }\n      lineNo++;\n    });\n    for (var i = newBreaks.length - 1; i >= 0; i--)\n      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\n  });\n  option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function (cm, val, old) {\n    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n    if (old != Init) { cm.refresh(); }\n  });\n  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\n  option(\"electricChars\", true);\n  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n    throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\n  }, true);\n  option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\n  option(\"rtlMoveVisually\", !windows);\n  option(\"wholeLineUpdateBefore\", true);\n\n  option(\"theme\", \"default\", function (cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option(\"keyMap\", \"default\", function (cm, val, old) {\n    var next = getKeyMap(val);\n    var prev = old != Init && getKeyMap(old);\n    if (prev && prev.detach) { prev.detach(cm, next); }\n    if (next.attach) { next.attach(cm, prev || null); }\n  });\n  option(\"extraKeys\", null);\n  option(\"configureMouse\", null);\n\n  option(\"lineWrapping\", false, wrappingChanged, true);\n  option(\"gutters\", [], function (cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"fixedGutter\", true, function (cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n    cm.refresh();\n  }, true);\n  option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\n  option(\"scrollbarStyle\", \"native\", function (cm) {\n    initScrollbars(cm);\n    updateScrollbars(cm);\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n  }, true);\n  option(\"lineNumbers\", false, function (cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"firstLineNumber\", 1, guttersChanged, true);\n  option(\"lineNumberFormatter\", function (integer) { return integer; }, guttersChanged, true);\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n  option(\"resetSelectionOnContextMenu\", true);\n  option(\"lineWiseCopyCut\", true);\n  option(\"pasteLinesPerSelection\", true);\n\n  option(\"readOnly\", false, function (cm, val) {\n    if (val == \"nocursor\") {\n      onBlur(cm);\n      cm.display.input.blur();\n    }\n    cm.display.input.readOnlyChanged(val);\n  });\n  option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\n  option(\"dragDrop\", true, dragDropChanged);\n  option(\"allowDropFileTypes\", null);\n\n  option(\"cursorBlinkRate\", 530);\n  option(\"cursorScrollMargin\", 0);\n  option(\"cursorHeight\", 1, updateSelection, true);\n  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n  option(\"workTime\", 100);\n  option(\"workDelay\", 100);\n  option(\"flattenSpans\", true, resetModeState, true);\n  option(\"addModeClass\", false, resetModeState, true);\n  option(\"pollInterval\", 100);\n  option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\n  option(\"historyEventDelay\", 1250);\n  option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\n  option(\"maxHighlightLength\", 10000, resetModeState, true);\n  option(\"moveInputWithCursor\", true, function (cm, val) {\n    if (!val) { cm.display.input.resetPosition(); }\n  });\n\n  option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\n  option(\"autofocus\", null);\n  option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\n}\n\nfunction guttersChanged(cm) {\n  updateGutters(cm);\n  regChange(cm);\n  alignHorizontally(cm);\n}\n\nfunction dragDropChanged(cm, value, old) {\n  var wasOn = old && old != Init;\n  if (!value != !wasOn) {\n    var funcs = cm.display.dragFunctions;\n    var toggle = value ? on : off;\n    toggle(cm.display.scroller, \"dragstart\", funcs.start);\n    toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n    toggle(cm.display.scroller, \"dragover\", funcs.over);\n    toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n    toggle(cm.display.scroller, \"drop\", funcs.drop);\n  }\n}\n\nfunction wrappingChanged(cm) {\n  if (cm.options.lineWrapping) {\n    addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n    cm.display.sizer.style.minWidth = \"\";\n    cm.display.sizerWidth = null;\n  } else {\n    rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n    findMaxLine(cm);\n  }\n  estimateLineHeights(cm);\n  regChange(cm);\n  clearCaches(cm);\n  setTimeout(function () { return updateScrollbars(cm); }, 100);\n}\n\n// A CodeMirror instance represents an editor. This is the object\n// that user code is usually dealing with.\n\nfunction CodeMirror$1(place, options) {\n  var this$1 = this;\n\n  if (!(this instanceof CodeMirror$1)) { return new CodeMirror$1(place, options) }\n\n  this.options = options = options ? copyObj(options) : {};\n  // Determine effective options based on given values and defaults.\n  copyObj(defaults, options, false);\n  setGuttersForLineNumbers(options);\n\n  var doc = options.value;\n  if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\n  this.doc = doc;\n\n  var input = new CodeMirror$1.inputStyles[options.inputStyle](this);\n  var display = this.display = new Display(place, doc, input);\n  display.wrapper.CodeMirror = this;\n  updateGutters(this);\n  themeChanged(this);\n  if (options.lineWrapping)\n    { this.display.wrapper.className += \" CodeMirror-wrap\"; }\n  initScrollbars(this);\n\n  this.state = {\n    keyMaps: [],  // stores maps added by addKeyMap\n    overlays: [], // highlighting overlays, as added by addOverlay\n    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n    overwrite: false,\n    delayingBlurEvent: false,\n    focused: false,\n    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\n    selectingText: false,\n    draggingText: false,\n    highlight: new Delayed(), // stores highlight worker timeout\n    keySeq: null,  // Unfinished key sequence\n    specialChars: null\n  };\n\n  if (options.autofocus && !mobile) { display.input.focus(); }\n\n  // Override magic textarea content restore that IE sometimes does\n  // on our hidden textarea on reload\n  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\n\n  registerEventHandlers(this);\n  ensureGlobalHandlers();\n\n  startOperation(this);\n  this.curOp.forceUpdate = true;\n  attachDoc(this, doc);\n\n  if ((options.autofocus && !mobile) || this.hasFocus())\n    { setTimeout(bind(onFocus, this), 20); }\n  else\n    { onBlur(this); }\n\n  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\n    { optionHandlers[opt](this$1, options[opt], Init); } }\n  maybeUpdateLineNumberWidth(this);\n  if (options.finishInit) { options.finishInit(this); }\n  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }\n  endOperation(this);\n  // Suppress optimizelegibility in Webkit, since it breaks text\n  // measuring on line wrapping boundaries.\n  if (webkit && options.lineWrapping &&\n      getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n    { display.lineDiv.style.textRendering = \"auto\"; }\n}\n\n// The default configuration options.\nCodeMirror$1.defaults = defaults;\n// Functions to run when options are changed.\nCodeMirror$1.optionHandlers = optionHandlers;\n\n// Attach the necessary event handlers when initializing the editor\nfunction registerEventHandlers(cm) {\n  var d = cm.display;\n  on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n  // Older IE's will not fire a second mousedown for a double click\n  if (ie && ie_version < 11)\n    { on(d.scroller, \"dblclick\", operation(cm, function (e) {\n      if (signalDOMEvent(cm, e)) { return }\n      var pos = posFromMouse(cm, e);\n      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\n      e_preventDefault(e);\n      var word = cm.findWordAt(pos);\n      extendSelection(cm.doc, word.anchor, word.head);\n    })); }\n  else\n    { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\n  // Some browsers fire contextmenu *after* opening the menu, at\n  // which point we can't mess with it anymore. Context menu is\n  // handled in onMouseDown for these browsers.\n  if (!captureRightClick) { on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); }); }\n\n  // Used to suppress mouse event handling when a touch happens\n  var touchFinished, prevTouch = {end: 0};\n  function finishTouch() {\n    if (d.activeTouch) {\n      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\n      prevTouch = d.activeTouch;\n      prevTouch.end = +new Date;\n    }\n  }\n  function isMouseLikeTouchEvent(e) {\n    if (e.touches.length != 1) { return false }\n    var touch = e.touches[0];\n    return touch.radiusX <= 1 && touch.radiusY <= 1\n  }\n  function farAway(touch, other) {\n    if (other.left == null) { return true }\n    var dx = other.left - touch.left, dy = other.top - touch.top;\n    return dx * dx + dy * dy > 20 * 20\n  }\n  on(d.scroller, \"touchstart\", function (e) {\n    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {\n      d.input.ensurePolled();\n      clearTimeout(touchFinished);\n      var now = +new Date;\n      d.activeTouch = {start: now, moved: false,\n                       prev: now - prevTouch.end <= 300 ? prevTouch : null};\n      if (e.touches.length == 1) {\n        d.activeTouch.left = e.touches[0].pageX;\n        d.activeTouch.top = e.touches[0].pageY;\n      }\n    }\n  });\n  on(d.scroller, \"touchmove\", function () {\n    if (d.activeTouch) { d.activeTouch.moved = true; }\n  });\n  on(d.scroller, \"touchend\", function (e) {\n    var touch = d.activeTouch;\n    if (touch && !eventInWidget(d, e) && touch.left != null &&\n        !touch.moved && new Date - touch.start < 300) {\n      var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n      if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n        { range = new Range(pos, pos); }\n      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n        { range = cm.findWordAt(pos); }\n      else // Triple tap\n        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\n      cm.setSelection(range.anchor, range.head);\n      cm.focus();\n      e_preventDefault(e);\n    }\n    finishTouch();\n  });\n  on(d.scroller, \"touchcancel\", finishTouch);\n\n  // Sync scrolling between fake scrollbars and real scrollable\n  // area, ensure viewport is updated when scrolling.\n  on(d.scroller, \"scroll\", function () {\n    if (d.scroller.clientHeight) {\n      updateScrollTop(cm, d.scroller.scrollTop);\n      setScrollLeft(cm, d.scroller.scrollLeft, true);\n      signal(cm, \"scroll\", cm);\n    }\n  });\n\n  // Listen to wheel events in order to try and update the viewport on time.\n  on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\n  on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\n\n  // Prevent wrapper from ever scrolling\n  on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n  d.dragFunctions = {\n    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\n    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n    start: function (e) { return onDragStart(cm, e); },\n    drop: operation(cm, onDrop),\n    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n  };\n\n  var inp = d.input.getField();\n  on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\n  on(inp, \"keydown\", operation(cm, onKeyDown));\n  on(inp, \"keypress\", operation(cm, onKeyPress));\n  on(inp, \"focus\", function (e) { return onFocus(cm, e); });\n  on(inp, \"blur\", function (e) { return onBlur(cm, e); });\n}\n\nvar initHooks = [];\nCodeMirror$1.defineInitHook = function (f) { return initHooks.push(f); };\n\n// Indent the given line. The how parameter can be \"smart\",\n// \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n// (typically set to true for forced single-line indents), empty\n// lines are not indented, and places where the mode returns Pass\n// are left alone.\nfunction indentLine(cm, n, how, aggressive) {\n  var doc = cm.doc, state;\n  if (how == null) { how = \"add\"; }\n  if (how == \"smart\") {\n    // Fall back to \"prev\" when the mode doesn't have an indentation\n    // method.\n    if (!doc.mode.indent) { how = \"prev\"; }\n    else { state = getContextBefore(cm, n).state; }\n  }\n\n  var tabSize = cm.options.tabSize;\n  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n  if (line.stateAfter) { line.stateAfter = null; }\n  var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n  if (!aggressive && !/\\S/.test(line.text)) {\n    indentation = 0;\n    how = \"not\";\n  } else if (how == \"smart\") {\n    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n    if (indentation == Pass || indentation > 150) {\n      if (!aggressive) { return }\n      how = \"prev\";\n    }\n  }\n  if (how == \"prev\") {\n    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\n    else { indentation = 0; }\n  } else if (how == \"add\") {\n    indentation = curSpace + cm.options.indentUnit;\n  } else if (how == \"subtract\") {\n    indentation = curSpace - cm.options.indentUnit;\n  } else if (typeof how == \"number\") {\n    indentation = curSpace + how;\n  }\n  indentation = Math.max(0, indentation);\n\n  var indentString = \"\", pos = 0;\n  if (cm.options.indentWithTabs)\n    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\n  if (pos < indentation) { indentString += spaceStr(indentation - pos); }\n\n  if (indentString != curSpaceString) {\n    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n    line.stateAfter = null;\n    return true\n  } else {\n    // Ensure that, if the cursor was in the whitespace at the start\n    // of the line, it is moved to the end of that space.\n    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n      var range = doc.sel.ranges[i$1];\n      if (range.head.line == n && range.head.ch < curSpaceString.length) {\n        var pos$1 = Pos(n, curSpaceString.length);\n        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n        break\n      }\n    }\n  }\n}\n\n// This will be set to a {lineWise: bool, text: [string]} object, so\n// that, when pasting, we know what kind of selections the copied\n// text was made out of.\nvar lastCopied = null;\n\nfunction setLastCopied(newLastCopied) {\n  lastCopied = newLastCopied;\n}\n\nfunction applyTextInput(cm, inserted, deleted, sel, origin) {\n  var doc = cm.doc;\n  cm.display.shift = false;\n  if (!sel) { sel = doc.sel; }\n\n  var paste = cm.state.pasteIncoming || origin == \"paste\";\n  var textLines = splitLinesAuto(inserted), multiPaste = null;\n  // When pasing N lines into N selections, insert one line per selection\n  if (paste && sel.ranges.length > 1) {\n    if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n      if (sel.ranges.length % lastCopied.text.length == 0) {\n        multiPaste = [];\n        for (var i = 0; i < lastCopied.text.length; i++)\n          { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\n      }\n    } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n      multiPaste = map(textLines, function (l) { return [l]; });\n    }\n  }\n\n  var updateInput;\n  // Normal behavior is to insert the new text into every selection\n  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n    var range$$1 = sel.ranges[i$1];\n    var from = range$$1.from(), to = range$$1.to();\n    if (range$$1.empty()) {\n      if (deleted && deleted > 0) // Handle deletion\n        { from = Pos(from.line, from.ch - deleted); }\n      else if (cm.state.overwrite && !paste) // Handle overwrite\n        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\n      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == inserted)\n        { from = to = Pos(from.line, 0); }\n    }\n    updateInput = cm.curOp.updateInput;\n    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                       origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\n    makeChange(cm.doc, changeEvent);\n    signalLater(cm, \"inputRead\", cm, changeEvent);\n  }\n  if (inserted && !paste)\n    { triggerElectric(cm, inserted); }\n\n  ensureCursorVisible(cm);\n  cm.curOp.updateInput = updateInput;\n  cm.curOp.typing = true;\n  cm.state.pasteIncoming = cm.state.cutIncoming = false;\n}\n\nfunction handlePaste(e, cm) {\n  var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n  if (pasted) {\n    e.preventDefault();\n    if (!cm.isReadOnly() && !cm.options.disableInput)\n      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\n    return true\n  }\n}\n\nfunction triggerElectric(cm, inserted) {\n  // When an 'electric' character is inserted, immediately trigger a reindent\n  if (!cm.options.electricChars || !cm.options.smartIndent) { return }\n  var sel = cm.doc.sel;\n\n  for (var i = sel.ranges.length - 1; i >= 0; i--) {\n    var range$$1 = sel.ranges[i];\n    if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }\n    var mode = cm.getModeAt(range$$1.head);\n    var indented = false;\n    if (mode.electricChars) {\n      for (var j = 0; j < mode.electricChars.length; j++)\n        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n          indented = indentLine(cm, range$$1.head.line, \"smart\");\n          break\n        } }\n    } else if (mode.electricInput) {\n      if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))\n        { indented = indentLine(cm, range$$1.head.line, \"smart\"); }\n    }\n    if (indented) { signalLater(cm, \"electricInput\", cm, range$$1.head.line); }\n  }\n}\n\nfunction copyableRanges(cm) {\n  var text = [], ranges = [];\n  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n    var line = cm.doc.sel.ranges[i].head.line;\n    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n    ranges.push(lineRange);\n    text.push(cm.getRange(lineRange.anchor, lineRange.head));\n  }\n  return {text: text, ranges: ranges}\n}\n\nfunction disableBrowserMagic(field, spellcheck) {\n  field.setAttribute(\"autocorrect\", \"off\");\n  field.setAttribute(\"autocapitalize\", \"off\");\n  field.setAttribute(\"spellcheck\", !!spellcheck);\n}\n\nfunction hiddenTextarea() {\n  var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n  var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n  // The textarea is kept positioned near the cursor to prevent the\n  // fact that it'll be scrolled into view on input from scrolling\n  // our fake cursor out of view. On webkit, when wrap=off, paste is\n  // very slow. So make the area wide instead.\n  if (webkit) { te.style.width = \"1000px\"; }\n  else { te.setAttribute(\"wrap\", \"off\"); }\n  // If border: 0; -- iOS fails to open keyboard (issue #1287)\n  if (ios) { te.style.border = \"1px solid black\"; }\n  disableBrowserMagic(te);\n  return div\n}\n\n// The publicly visible API. Note that methodOp(f) means\n// 'wrap f in an operation, performed on its `this` parameter'.\n\n// This is not the complete set of editor methods. Most of the\n// methods defined on the Doc type are also injected into\n// CodeMirror.prototype, for backwards compatibility and\n// convenience.\n\nvar addEditorMethods = function(CodeMirror) {\n  var optionHandlers = CodeMirror.optionHandlers;\n\n  var helpers = CodeMirror.helpers = {};\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function(){window.focus(); this.display.input.focus();},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != \"mode\") { return }\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        { operation(this, optionHandlers[option])(this, value, old); }\n      signal(this, \"optionChange\", this, option);\n    },\n\n    getOption: function(option) {return this.options[option]},\n    getDoc: function() {return this.doc},\n\n    addKeyMap: function(map$$1, bottom) {\n      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map$$1));\n    },\n    removeKeyMap: function(map$$1) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        { if (maps[i] == map$$1 || maps[i].name == map$$1) {\n          maps.splice(i, 1);\n          return true\n        } }\n    },\n\n    addOverlay: methodOp(function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\n      insertSorted(this.state.overlays,\n                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,\n                    priority: (options && options.priority) || 0},\n                   function (overlay) { return overlay.priority; });\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: methodOp(function(spec) {\n      var this$1 = this;\n\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this$1.state.modeGen++;\n          regChange(this$1);\n          return\n        }\n      }\n    }),\n\n    indentLine: methodOp(function(n, dir, aggressive) {\n      if (typeof dir != \"string\" && typeof dir != \"number\") {\n        if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\n        else { dir = dir ? \"add\" : \"subtract\"; }\n      }\n      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\n    }),\n    indentSelection: methodOp(function(how) {\n      var this$1 = this;\n\n      var ranges = this.doc.sel.ranges, end = -1;\n      for (var i = 0; i < ranges.length; i++) {\n        var range$$1 = ranges[i];\n        if (!range$$1.empty()) {\n          var from = range$$1.from(), to = range$$1.to();\n          var start = Math.max(end, from.line);\n          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n          for (var j = start; j < end; ++j)\n            { indentLine(this$1, j, how); }\n          var newRanges = this$1.doc.sel.ranges;\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\n        } else if (range$$1.head.line > end) {\n          indentLine(this$1, range$$1.head.line, how, true);\n          end = range$$1.head.line;\n          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }\n        }\n      }\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos, precise) {\n      return takeToken(this, pos, precise)\n    },\n\n    getLineTokens: function(line, precise) {\n      return takeToken(this, Pos(line), precise, true)\n    },\n\n    getTokenTypeAt: function(pos) {\n      pos = clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n      var type;\n      if (ch == 0) { type = styles[2]; }\n      else { for (;;) {\n        var mid = (before + after) >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\n        else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\n        else { type = styles[mid * 2 + 2]; break }\n      } }\n      var cut = type ? type.indexOf(\"overlay \") : -1;\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\n    },\n\n    getModeAt: function(pos) {\n      var mode = this.doc.mode;\n      if (!mode.innerMode) { return mode }\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\n    },\n\n    getHelper: function(pos, type) {\n      return this.getHelpers(pos, type)[0]\n    },\n\n    getHelpers: function(pos, type) {\n      var this$1 = this;\n\n      var found = [];\n      if (!helpers.hasOwnProperty(type)) { return found }\n      var help = helpers[type], mode = this.getModeAt(pos);\n      if (typeof mode[type] == \"string\") {\n        if (help[mode[type]]) { found.push(help[mode[type]]); }\n      } else if (mode[type]) {\n        for (var i = 0; i < mode[type].length; i++) {\n          var val = help[mode[type][i]];\n          if (val) { found.push(val); }\n        }\n      } else if (mode.helperType && help[mode.helperType]) {\n        found.push(help[mode.helperType]);\n      } else if (help[mode.name]) {\n        found.push(help[mode.name]);\n      }\n      for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n        var cur = help._global[i$1];\n        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)\n          { found.push(cur.val); }\n      }\n      return found\n    },\n\n    getStateAfter: function(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getContextBefore(this, line + 1, precise).state\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, range$$1 = this.doc.sel.primary();\n      if (start == null) { pos = range$$1.head; }\n      else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\n      else { pos = start ? range$$1.from() : range$$1.to(); }\n      return cursorCoords(this, pos, mode || \"page\")\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\n    },\n\n    coordsChar: function(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || \"page\");\n      return coordsChar(this, coords.left, coords.top)\n    },\n\n    lineAtHeight: function(height, mode) {\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n      return lineAtHeight(this.doc, height + this.display.viewOffset)\n    },\n    heightAtLine: function(line, mode, includeWidgets) {\n      var end = false, lineObj;\n      if (typeof line == \"number\") {\n        var last = this.doc.first + this.doc.size - 1;\n        if (line < this.doc.first) { line = this.doc.first; }\n        else if (line > last) { line = last; end = true; }\n        lineObj = getLine(this.doc, line);\n      } else {\n        lineObj = line;\n      }\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\n        (end ? this.doc.height - heightAtLine(lineObj) : 0)\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display) },\n    defaultCharWidth: function() { return charWidth(this.display) },\n\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = \"absolute\";\n      node.setAttribute(\"cm-ignore-events\", \"true\");\n      this.display.input.setUneditable(node);\n      display.sizer.appendChild(node);\n      if (vert == \"over\") {\n        top = pos.top;\n      } else if (vert == \"above\" || vert == \"near\") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          { top = pos.top - node.offsetHeight; }\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          { top = pos.bottom; }\n        if (left + node.offsetWidth > hspace)\n          { left = hspace - node.offsetWidth; }\n      }\n      node.style.top = top + \"px\";\n      node.style.left = node.style.right = \"\";\n      if (horiz == \"right\") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = \"0px\";\n      } else {\n        if (horiz == \"left\") { left = 0; }\n        else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\n        node.style.left = left + \"px\";\n      }\n      if (scroll)\n        { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\n    },\n\n    triggerOnKeyDown: methodOp(onKeyDown),\n    triggerOnKeyPress: methodOp(onKeyPress),\n    triggerOnKeyUp: onKeyUp,\n    triggerOnMouseDown: methodOp(onMouseDown),\n\n    execCommand: function(cmd) {\n      if (commands.hasOwnProperty(cmd))\n        { return commands[cmd].call(null, this) }\n    },\n\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n    findPosH: function(from, amount, unit, visually) {\n      var this$1 = this;\n\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      var cur = clipPos(this.doc, from);\n      for (var i = 0; i < amount; ++i) {\n        cur = findPosH(this$1.doc, cur, dir, unit, visually);\n        if (cur.hitSide) { break }\n      }\n      return cur\n    },\n\n    moveH: methodOp(function(dir, unit) {\n      var this$1 = this;\n\n      this.extendSelectionsBy(function (range$$1) {\n        if (this$1.display.shift || this$1.doc.extend || range$$1.empty())\n          { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }\n        else\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\n      }, sel_move);\n    }),\n\n    deleteH: methodOp(function(dir, unit) {\n      var sel = this.doc.sel, doc = this.doc;\n      if (sel.somethingSelected())\n        { doc.replaceSelection(\"\", null, \"+delete\"); }\n      else\n        { deleteNearSelection(this, function (range$$1) {\n          var other = findPosH(doc, range$$1.head, dir, unit, false);\n          return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}\n        }); }\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var this$1 = this;\n\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      var cur = clipPos(this.doc, from);\n      for (var i = 0; i < amount; ++i) {\n        var coords = cursorCoords(this$1, cur, \"div\");\n        if (x == null) { x = coords.left; }\n        else { coords.left = x; }\n        cur = findPosV(this$1, coords, dir, unit);\n        if (cur.hitSide) { break }\n      }\n      return cur\n    },\n\n    moveV: methodOp(function(dir, unit) {\n      var this$1 = this;\n\n      var doc = this.doc, goals = [];\n      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n      doc.extendSelectionsBy(function (range$$1) {\n        if (collapse)\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\n        var headPos = cursorCoords(this$1, range$$1.head, \"div\");\n        if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }\n        goals.push(headPos.left);\n        var pos = findPosV(this$1, headPos, dir, unit);\n        if (unit == \"page\" && range$$1 == doc.sel.primary())\n          { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\n        return pos\n      }, sel_move);\n      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\n        { doc.sel.ranges[i].goalColumn = goals[i]; } }\n    }),\n\n    // Find the word at the given position (as returned by coordsChar).\n    findWordAt: function(pos) {\n      var doc = this.doc, line = getLine(doc, pos.line).text;\n      var start = pos.ch, end = pos.ch;\n      if (line) {\n        var helper = this.getHelper(pos, \"wordChars\");\n        if ((pos.sticky == \"before\" || end == line.length) && start) { --start; } else { ++end; }\n        var startChar = line.charAt(start);\n        var check = isWordChar(startChar, helper)\n          ? function (ch) { return isWordChar(ch, helper); }\n          : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\n          : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\n        while (start > 0 && check(line.charAt(start - 1))) { --start; }\n        while (end < line.length && check(line.charAt(end))) { ++end; }\n      }\n      return new Range(Pos(pos.line, start), Pos(pos.line, end))\n    },\n\n    toggleOverwrite: function(value) {\n      if (value != null && value == this.state.overwrite) { return }\n      if (this.state.overwrite = !this.state.overwrite)\n        { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n      else\n        { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n\n      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n    },\n    hasFocus: function() { return this.display.input.getField() == activeElt() },\n    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\n\n    scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\n    },\n\n    scrollIntoView: methodOp(function(range$$1, margin) {\n      if (range$$1 == null) {\n        range$$1 = {from: this.doc.sel.primary().head, to: null};\n        if (margin == null) { margin = this.options.cursorScrollMargin; }\n      } else if (typeof range$$1 == \"number\") {\n        range$$1 = {from: Pos(range$$1, 0), to: null};\n      } else if (range$$1.from == null) {\n        range$$1 = {from: range$$1, to: null};\n      }\n      if (!range$$1.to) { range$$1.to = range$$1.from; }\n      range$$1.margin = margin || 0;\n\n      if (range$$1.from.line != null) {\n        scrollToRange(this, range$$1);\n      } else {\n        scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);\n      }\n    }),\n\n    setSize: methodOp(function(width, height) {\n      var this$1 = this;\n\n      var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\n      if (width != null) { this.display.wrapper.style.width = interpret(width); }\n      if (height != null) { this.display.wrapper.style.height = interpret(height); }\n      if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\n      var lineNo$$1 = this.display.viewFrom;\n      this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {\n        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\n          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, \"widget\"); break } } }\n        ++lineNo$$1;\n      });\n      this.curOp.forceUpdate = true;\n      signal(this, \"refresh\", this);\n    }),\n\n    operation: function(f){return runInOp(this, f)},\n    startOperation: function(){return startOperation(this)},\n    endOperation: function(){return endOperation(this)},\n\n    refresh: methodOp(function() {\n      var oldHeight = this.display.cachedTextHeight;\n      regChange(this);\n      this.curOp.forceUpdate = true;\n      clearCaches(this);\n      scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n      updateGutterSpace(this);\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n        { estimateLineHeights(this); }\n      signal(this, \"refresh\", this);\n    }),\n\n    swapDoc: methodOp(function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      this.display.input.reset();\n      scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n      this.curOp.forceScroll = true;\n      signalLater(this, \"swapDoc\", this, old);\n      return old\n    }),\n\n    getInputField: function(){return this.display.input.getField()},\n    getWrapperElement: function(){return this.display.wrapper},\n    getScrollerElement: function(){return this.display.scroller},\n    getGutterElement: function(){return this.display.gutters}\n  };\n  eventMixin(CodeMirror);\n\n  CodeMirror.registerHelper = function(type, name, value) {\n    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\n    helpers[type][name] = value;\n  };\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n    CodeMirror.registerHelper(type, name, value);\n    helpers[type]._global.push({pred: predicate, val: value});\n  };\n};\n\n// Used for horizontal relative motion. Dir is -1 or 1 (left or\n// right), unit can be \"char\", \"column\" (like char, but doesn't\n// cross line boundaries), \"word\" (across next word), or \"group\" (to\n// the start of next group of word or non-word-non-whitespace\n// chars). The visually param controls whether, in right-to-left\n// text, direction 1 means to move towards the next index in the\n// string, or towards the character to the right of the current\n// position. The resulting position will have a hitSide=true\n// property if it reached the end of the document.\nfunction findPosH(doc, pos, dir, unit, visually) {\n  var oldPos = pos;\n  var origDir = dir;\n  var lineObj = getLine(doc, pos.line);\n  function findNextLine() {\n    var l = pos.line + dir;\n    if (l < doc.first || l >= doc.first + doc.size) { return false }\n    pos = new Pos(l, pos.ch, pos.sticky);\n    return lineObj = getLine(doc, l)\n  }\n  function moveOnce(boundToLine) {\n    var next;\n    if (visually) {\n      next = moveVisually(doc.cm, lineObj, pos, dir);\n    } else {\n      next = moveLogically(lineObj, pos, dir);\n    }\n    if (next == null) {\n      if (!boundToLine && findNextLine())\n        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }\n      else\n        { return false }\n    } else {\n      pos = next;\n    }\n    return true\n  }\n\n  if (unit == \"char\") {\n    moveOnce();\n  } else if (unit == \"column\") {\n    moveOnce(true);\n  } else if (unit == \"word\" || unit == \"group\") {\n    var sawType = null, group = unit == \"group\";\n    var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n    for (var first = true;; first = false) {\n      if (dir < 0 && !moveOnce(!first)) { break }\n      var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n      var type = isWordChar(cur, helper) ? \"w\"\n        : group && cur == \"\\n\" ? \"n\"\n        : !group || /\\s/.test(cur) ? null\n        : \"p\";\n      if (group && !first && !type) { type = \"s\"; }\n      if (sawType && sawType != type) {\n        if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\n        break\n      }\n\n      if (type) { sawType = type; }\n      if (dir > 0 && !moveOnce(!first)) { break }\n    }\n  }\n  var result = skipAtomic(doc, pos, oldPos, origDir, true);\n  if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\n  return result\n}\n\n// For relative vertical movement. Dir may be -1 or 1. Unit can be\n// \"page\" or \"line\". The resulting position will have a hitSide=true\n// property if it reached the end of the document.\nfunction findPosV(cm, pos, dir, unit) {\n  var doc = cm.doc, x = pos.left, y;\n  if (unit == \"page\") {\n    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n\n  } else if (unit == \"line\") {\n    y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n  }\n  var target;\n  for (;;) {\n    target = coordsChar(cm, x, y);\n    if (!target.outside) { break }\n    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\n    y += dir * 5;\n  }\n  return target\n}\n\n// CONTENTEDITABLE INPUT STYLE\n\nvar ContentEditableInput = function(cm) {\n  this.cm = cm;\n  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n  this.polling = new Delayed();\n  this.composing = null;\n  this.gracePeriod = false;\n  this.readDOMTimeout = null;\n};\n\nContentEditableInput.prototype.init = function (display) {\n    var this$1 = this;\n\n  var input = this, cm = input.cm;\n  var div = input.div = display.lineDiv;\n  disableBrowserMagic(div, cm.options.spellcheck);\n\n  on(div, \"paste\", function (e) {\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n    // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n    if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\n  });\n\n  on(div, \"compositionstart\", function (e) {\n    this$1.composing = {data: e.data, done: false};\n  });\n  on(div, \"compositionupdate\", function (e) {\n    if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\n  });\n  on(div, \"compositionend\", function (e) {\n    if (this$1.composing) {\n      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\n      this$1.composing.done = true;\n    }\n  });\n\n  on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\n\n  on(div, \"input\", function () {\n    if (!this$1.composing) { this$1.readFromDOMSoon(); }\n  });\n\n  function onCopyCut(e) {\n    if (signalDOMEvent(cm, e)) { return }\n    if (cm.somethingSelected()) {\n      setLastCopied({lineWise: false, text: cm.getSelections()});\n      if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\n    } else if (!cm.options.lineWiseCopyCut) {\n      return\n    } else {\n      var ranges = copyableRanges(cm);\n      setLastCopied({lineWise: true, text: ranges.text});\n      if (e.type == \"cut\") {\n        cm.operation(function () {\n          cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n          cm.replaceSelection(\"\", null, \"cut\");\n        });\n      }\n    }\n    if (e.clipboardData) {\n      e.clipboardData.clearData();\n      var content = lastCopied.text.join(\"\\n\");\n      // iOS exposes the clipboard API, but seems to discard content inserted into it\n      e.clipboardData.setData(\"Text\", content);\n      if (e.clipboardData.getData(\"Text\") == content) {\n        e.preventDefault();\n        return\n      }\n    }\n    // Old-fashioned briefly-focus-a-textarea hack\n    var kludge = hiddenTextarea(), te = kludge.firstChild;\n    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n    te.value = lastCopied.text.join(\"\\n\");\n    var hadFocus = document.activeElement;\n    selectInput(te);\n    setTimeout(function () {\n      cm.display.lineSpace.removeChild(kludge);\n      hadFocus.focus();\n      if (hadFocus == div) { input.showPrimarySelection(); }\n    }, 50);\n  }\n  on(div, \"copy\", onCopyCut);\n  on(div, \"cut\", onCopyCut);\n};\n\nContentEditableInput.prototype.prepareSelection = function () {\n  var result = prepareSelection(this.cm, false);\n  result.focus = this.cm.state.focused;\n  return result\n};\n\nContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n  if (!info || !this.cm.display.view.length) { return }\n  if (info.focus || takeFocus) { this.showPrimarySelection(); }\n  this.showMultipleSelections(info);\n};\n\nContentEditableInput.prototype.showPrimarySelection = function () {\n  var sel = window.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n  var from = prim.from(), to = prim.to();\n\n  if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n    sel.removeAllRanges();\n    return\n  }\n\n  var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n  var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n      cmp(minPos(curAnchor, curFocus), from) == 0 &&\n      cmp(maxPos(curAnchor, curFocus), to) == 0)\n    { return }\n\n  var view = cm.display.view;\n  var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\n      {node: view[0].measure.map[2], offset: 0};\n  var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n  if (!end) {\n    var measure = view[view.length - 1].measure;\n    var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n    end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};\n  }\n\n  if (!start || !end) {\n    sel.removeAllRanges();\n    return\n  }\n\n  var old = sel.rangeCount && sel.getRangeAt(0), rng;\n  try { rng = range(start.node, start.offset, end.offset, end.node); }\n  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n  if (rng) {\n    if (!gecko && cm.state.focused) {\n      sel.collapse(start.node, start.offset);\n      if (!rng.collapsed) {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n    } else {\n      sel.removeAllRanges();\n      sel.addRange(rng);\n    }\n    if (old && sel.anchorNode == null) { sel.addRange(old); }\n    else if (gecko) { this.startGracePeriod(); }\n  }\n  this.rememberSelection();\n};\n\nContentEditableInput.prototype.startGracePeriod = function () {\n    var this$1 = this;\n\n  clearTimeout(this.gracePeriod);\n  this.gracePeriod = setTimeout(function () {\n    this$1.gracePeriod = false;\n    if (this$1.selectionChanged())\n      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\n  }, 20);\n};\n\nContentEditableInput.prototype.showMultipleSelections = function (info) {\n  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n};\n\nContentEditableInput.prototype.rememberSelection = function () {\n  var sel = window.getSelection();\n  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n};\n\nContentEditableInput.prototype.selectionInEditor = function () {\n  var sel = window.getSelection();\n  if (!sel.rangeCount) { return false }\n  var node = sel.getRangeAt(0).commonAncestorContainer;\n  return contains(this.div, node)\n};\n\nContentEditableInput.prototype.focus = function () {\n  if (this.cm.options.readOnly != \"nocursor\") {\n    if (!this.selectionInEditor())\n      { this.showSelection(this.prepareSelection(), true); }\n    this.div.focus();\n  }\n};\nContentEditableInput.prototype.blur = function () { this.div.blur(); };\nContentEditableInput.prototype.getField = function () { return this.div };\n\nContentEditableInput.prototype.supportsTouch = function () { return true };\n\nContentEditableInput.prototype.receivedFocus = function () {\n  var input = this;\n  if (this.selectionInEditor())\n    { this.pollSelection(); }\n  else\n    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\n\n  function poll() {\n    if (input.cm.state.focused) {\n      input.pollSelection();\n      input.polling.set(input.cm.options.pollInterval, poll);\n    }\n  }\n  this.polling.set(this.cm.options.pollInterval, poll);\n};\n\nContentEditableInput.prototype.selectionChanged = function () {\n  var sel = window.getSelection();\n  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\n};\n\nContentEditableInput.prototype.pollSelection = function () {\n  if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\n  var sel = window.getSelection(), cm = this.cm;\n  // On Android Chrome (version 56, at least), backspacing into an\n  // uneditable block element will put the cursor in that element,\n  // and then, because it's not editable, hide the virtual keyboard.\n  // Because Android doesn't allow us to actually detect backspace\n  // presses in a sane way, this code checks for when that happens\n  // and simulates a backspace press in this case.\n  if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {\n    this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\n    this.blur();\n    this.focus();\n    return\n  }\n  if (this.composing) { return }\n  this.rememberSelection();\n  var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n  var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n  if (anchor && head) { runInOp(cm, function () {\n    setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n    if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\n  }); }\n};\n\nContentEditableInput.prototype.pollContent = function () {\n  if (this.readDOMTimeout != null) {\n    clearTimeout(this.readDOMTimeout);\n    this.readDOMTimeout = null;\n  }\n\n  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n  var from = sel.from(), to = sel.to();\n  if (from.ch == 0 && from.line > cm.firstLine())\n    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\n  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n    { to = Pos(to.line + 1, 0); }\n  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\n\n  var fromIndex, fromLine, fromNode;\n  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n    fromLine = lineNo(display.view[0].line);\n    fromNode = display.view[0].node;\n  } else {\n    fromLine = lineNo(display.view[fromIndex].line);\n    fromNode = display.view[fromIndex - 1].node.nextSibling;\n  }\n  var toIndex = findViewIndex(cm, to.line);\n  var toLine, toNode;\n  if (toIndex == display.view.length - 1) {\n    toLine = display.viewTo - 1;\n    toNode = display.lineDiv.lastChild;\n  } else {\n    toLine = lineNo(display.view[toIndex + 1].line) - 1;\n    toNode = display.view[toIndex + 1].node.previousSibling;\n  }\n\n  if (!fromNode) { return false }\n  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n  while (newText.length > 1 && oldText.length > 1) {\n    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n    else { break }\n  }\n\n  var cutFront = 0, cutEnd = 0;\n  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n    { ++cutFront; }\n  var newBot = lst(newText), oldBot = lst(oldText);\n  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                           oldBot.length - (oldText.length == 1 ? cutFront : 0));\n  while (cutEnd < maxCutEnd &&\n         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n    { ++cutEnd; }\n  // Try to move start of change to start of selection if ambiguous\n  if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n    while (cutFront && cutFront > from.ch &&\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n      cutFront--;\n      cutEnd++;\n    }\n  }\n\n  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n  newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n\n  var chFrom = Pos(fromLine, cutFront);\n  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n    replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n    return true\n  }\n};\n\nContentEditableInput.prototype.ensurePolled = function () {\n  this.forceCompositionEnd();\n};\nContentEditableInput.prototype.reset = function () {\n  this.forceCompositionEnd();\n};\nContentEditableInput.prototype.forceCompositionEnd = function () {\n  if (!this.composing) { return }\n  clearTimeout(this.readDOMTimeout);\n  this.composing = null;\n  this.updateFromDOM();\n  this.div.blur();\n  this.div.focus();\n};\nContentEditableInput.prototype.readFromDOMSoon = function () {\n    var this$1 = this;\n\n  if (this.readDOMTimeout != null) { return }\n  this.readDOMTimeout = setTimeout(function () {\n    this$1.readDOMTimeout = null;\n    if (this$1.composing) {\n      if (this$1.composing.done) { this$1.composing = null; }\n      else { return }\n    }\n    this$1.updateFromDOM();\n  }, 80);\n};\n\nContentEditableInput.prototype.updateFromDOM = function () {\n    var this$1 = this;\n\n  if (this.cm.isReadOnly() || !this.pollContent())\n    { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\n};\n\nContentEditableInput.prototype.setUneditable = function (node) {\n  node.contentEditable = \"false\";\n};\n\nContentEditableInput.prototype.onKeyPress = function (e) {\n  if (e.charCode == 0) { return }\n  e.preventDefault();\n  if (!this.cm.isReadOnly())\n    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\n};\n\nContentEditableInput.prototype.readOnlyChanged = function (val) {\n  this.div.contentEditable = String(val != \"nocursor\");\n};\n\nContentEditableInput.prototype.onContextMenu = function () {};\nContentEditableInput.prototype.resetPosition = function () {};\n\nContentEditableInput.prototype.needsContentAttribute = true;\n\nfunction posToDOM(cm, pos) {\n  var view = findViewForLine(cm, pos.line);\n  if (!view || view.hidden) { return null }\n  var line = getLine(cm.doc, pos.line);\n  var info = mapFromLineView(view, line, pos.line);\n\n  var order = getOrder(line, cm.doc.direction), side = \"left\";\n  if (order) {\n    var partPos = getBidiPartAt(order, pos.ch);\n    side = partPos % 2 ? \"right\" : \"left\";\n  }\n  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n  result.offset = result.collapse == \"right\" ? result.end : result.start;\n  return result\n}\n\nfunction isInGutter(node) {\n  for (var scan = node; scan; scan = scan.parentNode)\n    { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\n  return false\n}\n\nfunction badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\n\nfunction domTextBetween(cm, from, to, fromLine, toLine) {\n  var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\n  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\n  function close() {\n    if (closing) {\n      text += lineSep;\n      closing = false;\n    }\n  }\n  function addText(str) {\n    if (str) {\n      close();\n      text += str;\n    }\n  }\n  function walk(node) {\n    if (node.nodeType == 1) {\n      var cmText = node.getAttribute(\"cm-text\");\n      if (cmText != null) {\n        addText(cmText || node.textContent.replace(/\\u200b/g, \"\"));\n        return\n      }\n      var markerID = node.getAttribute(\"cm-marker\"), range$$1;\n      if (markerID) {\n        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n        if (found.length && (range$$1 = found[0].find()))\n          { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }\n        return\n      }\n      if (node.getAttribute(\"contenteditable\") == \"false\") { return }\n      var isBlock = /^(pre|div|p)$/i.test(node.nodeName);\n      if (isBlock) { close(); }\n      for (var i = 0; i < node.childNodes.length; i++)\n        { walk(node.childNodes[i]); }\n      if (isBlock) { closing = true; }\n    } else if (node.nodeType == 3) {\n      addText(node.nodeValue);\n    }\n  }\n  for (;;) {\n    walk(from);\n    if (from == to) { break }\n    from = from.nextSibling;\n  }\n  return text\n}\n\nfunction domToPos(cm, node, offset) {\n  var lineNode;\n  if (node == cm.display.lineDiv) {\n    lineNode = cm.display.lineDiv.childNodes[offset];\n    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\n    node = null; offset = 0;\n  } else {\n    for (lineNode = node;; lineNode = lineNode.parentNode) {\n      if (!lineNode || lineNode == cm.display.lineDiv) { return null }\n      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\n    }\n  }\n  for (var i = 0; i < cm.display.view.length; i++) {\n    var lineView = cm.display.view[i];\n    if (lineView.node == lineNode)\n      { return locateNodeInLineView(lineView, node, offset) }\n  }\n}\n\nfunction locateNodeInLineView(lineView, node, offset) {\n  var wrapper = lineView.text.firstChild, bad = false;\n  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\n  if (node == wrapper) {\n    bad = true;\n    node = wrapper.childNodes[offset];\n    offset = 0;\n    if (!node) {\n      var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n      return badPos(Pos(lineNo(line), line.text.length), bad)\n    }\n  }\n\n  var textNode = node.nodeType == 3 ? node : null, topNode = node;\n  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n    textNode = node.firstChild;\n    if (offset) { offset = textNode.nodeValue.length; }\n  }\n  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\n  var measure = lineView.measure, maps = measure.maps;\n\n  function find(textNode, topNode, offset) {\n    for (var i = -1; i < (maps ? maps.length : 0); i++) {\n      var map$$1 = i < 0 ? measure.map : maps[i];\n      for (var j = 0; j < map$$1.length; j += 3) {\n        var curNode = map$$1[j + 2];\n        if (curNode == textNode || curNode == topNode) {\n          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n          var ch = map$$1[j] + offset;\n          if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }\n          return Pos(line, ch)\n        }\n      }\n    }\n  }\n  var found = find(textNode, topNode, offset);\n  if (found) { return badPos(found, bad) }\n\n  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n    found = find(after, after.firstChild, 0);\n    if (found)\n      { return badPos(Pos(found.line, found.ch - dist), bad) }\n    else\n      { dist += after.textContent.length; }\n  }\n  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n    found = find(before, before.firstChild, -1);\n    if (found)\n      { return badPos(Pos(found.line, found.ch + dist$1), bad) }\n    else\n      { dist$1 += before.textContent.length; }\n  }\n}\n\n// TEXTAREA INPUT STYLE\n\nvar TextareaInput = function(cm) {\n  this.cm = cm;\n  // See input.poll and input.reset\n  this.prevInput = \"\";\n\n  // Flag that indicates whether we expect input to appear real soon\n  // now (after some event like 'keypress' or 'input') and are\n  // polling intensively.\n  this.pollingFast = false;\n  // Self-resetting timeout for the poller\n  this.polling = new Delayed();\n  // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n  this.hasSelection = false;\n  this.composing = null;\n};\n\nTextareaInput.prototype.init = function (display) {\n    var this$1 = this;\n\n  var input = this, cm = this.cm;\n\n  // Wraps and hides input textarea\n  var div = this.wrapper = hiddenTextarea();\n  // The semihidden textarea that is focused when the editor is\n  // focused, and receives input.\n  var te = this.textarea = div.firstChild;\n  display.wrapper.insertBefore(div, display.wrapper.firstChild);\n\n  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n  if (ios) { te.style.width = \"0px\"; }\n\n  on(te, \"input\", function () {\n    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\n    input.poll();\n  });\n\n  on(te, \"paste\", function (e) {\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n\n    cm.state.pasteIncoming = true;\n    input.fastPoll();\n  });\n\n  function prepareCopyCut(e) {\n    if (signalDOMEvent(cm, e)) { return }\n    if (cm.somethingSelected()) {\n      setLastCopied({lineWise: false, text: cm.getSelections()});\n    } else if (!cm.options.lineWiseCopyCut) {\n      return\n    } else {\n      var ranges = copyableRanges(cm);\n      setLastCopied({lineWise: true, text: ranges.text});\n      if (e.type == \"cut\") {\n        cm.setSelections(ranges.ranges, null, sel_dontScroll);\n      } else {\n        input.prevInput = \"\";\n        te.value = ranges.text.join(\"\\n\");\n        selectInput(te);\n      }\n    }\n    if (e.type == \"cut\") { cm.state.cutIncoming = true; }\n  }\n  on(te, \"cut\", prepareCopyCut);\n  on(te, \"copy\", prepareCopyCut);\n\n  on(display.scroller, \"paste\", function (e) {\n    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\n    cm.state.pasteIncoming = true;\n    input.focus();\n  });\n\n  // Prevent normal selection in the editor (we handle our own)\n  on(display.lineSpace, \"selectstart\", function (e) {\n    if (!eventInWidget(display, e)) { e_preventDefault(e); }\n  });\n\n  on(te, \"compositionstart\", function () {\n    var start = cm.getCursor(\"from\");\n    if (input.composing) { input.composing.range.clear(); }\n    input.composing = {\n      start: start,\n      range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n    };\n  });\n  on(te, \"compositionend\", function () {\n    if (input.composing) {\n      input.poll();\n      input.composing.range.clear();\n      input.composing = null;\n    }\n  });\n};\n\nTextareaInput.prototype.prepareSelection = function () {\n  // Redraw the selection and/or cursor\n  var cm = this.cm, display = cm.display, doc = cm.doc;\n  var result = prepareSelection(cm);\n\n  // Move the hidden textarea near the cursor to prevent scrolling artifacts\n  if (cm.options.moveInputWithCursor) {\n    var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                        headPos.top + lineOff.top - wrapOff.top));\n    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                         headPos.left + lineOff.left - wrapOff.left));\n  }\n\n  return result\n};\n\nTextareaInput.prototype.showSelection = function (drawn) {\n  var cm = this.cm, display = cm.display;\n  removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n  removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n  if (drawn.teTop != null) {\n    this.wrapper.style.top = drawn.teTop + \"px\";\n    this.wrapper.style.left = drawn.teLeft + \"px\";\n  }\n};\n\n// Reset the input to correspond to the selection (or to be empty,\n// when not typing and nothing is selected)\nTextareaInput.prototype.reset = function (typing) {\n  if (this.contextMenuPending || this.composing) { return }\n  var cm = this.cm;\n  if (cm.somethingSelected()) {\n    this.prevInput = \"\";\n    var content = cm.getSelection();\n    this.textarea.value = content;\n    if (cm.state.focused) { selectInput(this.textarea); }\n    if (ie && ie_version >= 9) { this.hasSelection = content; }\n  } else if (!typing) {\n    this.prevInput = this.textarea.value = \"\";\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\n  }\n};\n\nTextareaInput.prototype.getField = function () { return this.textarea };\n\nTextareaInput.prototype.supportsTouch = function () { return false };\n\nTextareaInput.prototype.focus = function () {\n  if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n    try { this.textarea.focus(); }\n    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n  }\n};\n\nTextareaInput.prototype.blur = function () { this.textarea.blur(); };\n\nTextareaInput.prototype.resetPosition = function () {\n  this.wrapper.style.top = this.wrapper.style.left = 0;\n};\n\nTextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\n\n// Poll for input changes, using the normal rate of polling. This\n// runs as long as the editor is focused.\nTextareaInput.prototype.slowPoll = function () {\n    var this$1 = this;\n\n  if (this.pollingFast) { return }\n  this.polling.set(this.cm.options.pollInterval, function () {\n    this$1.poll();\n    if (this$1.cm.state.focused) { this$1.slowPoll(); }\n  });\n};\n\n// When an event has just come in that is likely to add or change\n// something in the input textarea, we poll faster, to ensure that\n// the change appears on the screen quickly.\nTextareaInput.prototype.fastPoll = function () {\n  var missed = false, input = this;\n  input.pollingFast = true;\n  function p() {\n    var changed = input.poll();\n    if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n    else {input.pollingFast = false; input.slowPoll();}\n  }\n  input.polling.set(20, p);\n};\n\n// Read input from the textarea, and update the document to match.\n// When something is selected, it is present in the textarea, and\n// selected (unless it is huge, in which case a placeholder is\n// used). When nothing is selected, the cursor sits after previously\n// seen text (can be empty), which is stored in prevInput (we must\n// not reset the textarea when typing, because that breaks IME).\nTextareaInput.prototype.poll = function () {\n    var this$1 = this;\n\n  var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n  // Since this is called a *lot*, try to bail out as cheaply as\n  // possible when it is clear that nothing happened. hasSelection\n  // will be the case when there is a lot of text in the textarea,\n  // in which case reading its value would be expensive.\n  if (this.contextMenuPending || !cm.state.focused ||\n      (hasSelection(input) && !prevInput && !this.composing) ||\n      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n    { return false }\n\n  var text = input.value;\n  // If nothing changed, bail.\n  if (text == prevInput && !cm.somethingSelected()) { return false }\n  // Work around nonsensical selection resetting in IE9/10, and\n  // inexplicable appearance of private area unicode characters on\n  // some key combos in Mac (#2689).\n  if (ie && ie_version >= 9 && this.hasSelection === text ||\n      mac && /[\\uf700-\\uf7ff]/.test(text)) {\n    cm.display.input.reset();\n    return false\n  }\n\n  if (cm.doc.sel == cm.display.selForContextMenu) {\n    var first = text.charCodeAt(0);\n    if (first == 0x200b && !prevInput) { prevInput = \"\\u200b\"; }\n    if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\n  }\n  // Find the part of the input that is actually new\n  var same = 0, l = Math.min(prevInput.length, text.length);\n  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\n\n  runInOp(cm, function () {\n    applyTextInput(cm, text.slice(same), prevInput.length - same,\n                   null, this$1.composing ? \"*compose\" : null);\n\n    // Don't leave long text in the textarea, since it makes further polling slow\n    if (text.length > 1000 || text.indexOf(\"\\n\") > -1) { input.value = this$1.prevInput = \"\"; }\n    else { this$1.prevInput = text; }\n\n    if (this$1.composing) {\n      this$1.composing.range.clear();\n      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\n                                         {className: \"CodeMirror-composing\"});\n    }\n  });\n  return true\n};\n\nTextareaInput.prototype.ensurePolled = function () {\n  if (this.pollingFast && this.poll()) { this.pollingFast = false; }\n};\n\nTextareaInput.prototype.onKeyPress = function () {\n  if (ie && ie_version >= 9) { this.hasSelection = null; }\n  this.fastPoll();\n};\n\nTextareaInput.prototype.onContextMenu = function (e) {\n  var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n  if (!pos || presto) { return } // Opera is difficult.\n\n  // Reset the current text selection only if the click is done outside of the selection\n  // and 'resetSelectionOnContextMenu' option is true.\n  var reset = cm.options.resetSelectionOnContextMenu;\n  if (reset && cm.doc.sel.contains(pos) == -1)\n    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\n\n  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n  input.wrapper.style.cssText = \"position: absolute\";\n  var wrapperBox = input.wrapper.getBoundingClientRect();\n  te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n  var oldScrollY;\n  if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\n  display.input.focus();\n  if (webkit) { window.scrollTo(null, oldScrollY); }\n  display.input.reset();\n  // Adds \"Select all\" to context menu in FF\n  if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\n  input.contextMenuPending = true;\n  display.selForContextMenu = cm.doc.sel;\n  clearTimeout(display.detectingSelectAll);\n\n  // Select-all will be greyed out if there's nothing to select, so\n  // this adds a zero-width space so that we can later check whether\n  // it got selected.\n  function prepareSelectAllHack() {\n    if (te.selectionStart != null) {\n      var selected = cm.somethingSelected();\n      var extval = \"\\u200b\" + (selected ? te.value : \"\");\n      te.value = \"\\u21da\"; // Used to catch context-menu undo\n      te.value = extval;\n      input.prevInput = selected ? \"\" : \"\\u200b\";\n      te.selectionStart = 1; te.selectionEnd = extval.length;\n      // Re-set this, in case some other handler touched the\n      // selection in the meantime.\n      display.selForContextMenu = cm.doc.sel;\n    }\n  }\n  function rehide() {\n    input.contextMenuPending = false;\n    input.wrapper.style.cssText = oldWrapperCSS;\n    te.style.cssText = oldCSS;\n    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\n\n    // Try to detect the user choosing select-all\n    if (te.selectionStart != null) {\n      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\n      var i = 0, poll = function () {\n        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n            te.selectionEnd > 0 && input.prevInput == \"\\u200b\") {\n          operation(cm, selectAll)(cm);\n        } else if (i++ < 10) {\n          display.detectingSelectAll = setTimeout(poll, 500);\n        } else {\n          display.selForContextMenu = null;\n          display.input.reset();\n        }\n      };\n      display.detectingSelectAll = setTimeout(poll, 200);\n    }\n  }\n\n  if (ie && ie_version >= 9) { prepareSelectAllHack(); }\n  if (captureRightClick) {\n    e_stop(e);\n    var mouseup = function () {\n      off(window, \"mouseup\", mouseup);\n      setTimeout(rehide, 20);\n    };\n    on(window, \"mouseup\", mouseup);\n  } else {\n    setTimeout(rehide, 50);\n  }\n};\n\nTextareaInput.prototype.readOnlyChanged = function (val) {\n  if (!val) { this.reset(); }\n  this.textarea.disabled = val == \"nocursor\";\n};\n\nTextareaInput.prototype.setUneditable = function () {};\n\nTextareaInput.prototype.needsContentAttribute = false;\n\nfunction fromTextArea(textarea, options) {\n  options = options ? copyObj(options) : {};\n  options.value = textarea.value;\n  if (!options.tabindex && textarea.tabIndex)\n    { options.tabindex = textarea.tabIndex; }\n  if (!options.placeholder && textarea.placeholder)\n    { options.placeholder = textarea.placeholder; }\n  // Set autofocus to true if this textarea is focused, or if it has\n  // autofocus and no other element is focused.\n  if (options.autofocus == null) {\n    var hasFocus = activeElt();\n    options.autofocus = hasFocus == textarea ||\n      textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n  }\n\n  function save() {textarea.value = cm.getValue();}\n\n  var realSubmit;\n  if (textarea.form) {\n    on(textarea.form, \"submit\", save);\n    // Deplorable hack to make the submit method do the right thing.\n    if (!options.leaveSubmitMethodAlone) {\n      var form = textarea.form;\n      realSubmit = form.submit;\n      try {\n        var wrappedSubmit = form.submit = function () {\n          save();\n          form.submit = realSubmit;\n          form.submit();\n          form.submit = wrappedSubmit;\n        };\n      } catch(e) {}\n    }\n  }\n\n  options.finishInit = function (cm) {\n    cm.save = save;\n    cm.getTextArea = function () { return textarea; };\n    cm.toTextArea = function () {\n      cm.toTextArea = isNaN; // Prevent this from being ran twice\n      save();\n      textarea.parentNode.removeChild(cm.getWrapperElement());\n      textarea.style.display = \"\";\n      if (textarea.form) {\n        off(textarea.form, \"submit\", save);\n        if (typeof textarea.form.submit == \"function\")\n          { textarea.form.submit = realSubmit; }\n      }\n    };\n  };\n\n  textarea.style.display = \"none\";\n  var cm = CodeMirror$1(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\n    options);\n  return cm\n}\n\nfunction addLegacyProps(CodeMirror) {\n  CodeMirror.off = off;\n  CodeMirror.on = on;\n  CodeMirror.wheelEventPixels = wheelEventPixels;\n  CodeMirror.Doc = Doc;\n  CodeMirror.splitLines = splitLinesAuto;\n  CodeMirror.countColumn = countColumn;\n  CodeMirror.findColumn = findColumn;\n  CodeMirror.isWordChar = isWordCharBasic;\n  CodeMirror.Pass = Pass;\n  CodeMirror.signal = signal;\n  CodeMirror.Line = Line;\n  CodeMirror.changeEnd = changeEnd;\n  CodeMirror.scrollbarModel = scrollbarModel;\n  CodeMirror.Pos = Pos;\n  CodeMirror.cmpPos = cmp;\n  CodeMirror.modes = modes;\n  CodeMirror.mimeModes = mimeModes;\n  CodeMirror.resolveMode = resolveMode;\n  CodeMirror.getMode = getMode;\n  CodeMirror.modeExtensions = modeExtensions;\n  CodeMirror.extendMode = extendMode;\n  CodeMirror.copyState = copyState;\n  CodeMirror.startState = startState;\n  CodeMirror.innerMode = innerMode;\n  CodeMirror.commands = commands;\n  CodeMirror.keyMap = keyMap;\n  CodeMirror.keyName = keyName;\n  CodeMirror.isModifierKey = isModifierKey;\n  CodeMirror.lookupKey = lookupKey;\n  CodeMirror.normalizeKeyMap = normalizeKeyMap;\n  CodeMirror.StringStream = StringStream;\n  CodeMirror.SharedTextMarker = SharedTextMarker;\n  CodeMirror.TextMarker = TextMarker;\n  CodeMirror.LineWidget = LineWidget;\n  CodeMirror.e_preventDefault = e_preventDefault;\n  CodeMirror.e_stopPropagation = e_stopPropagation;\n  CodeMirror.e_stop = e_stop;\n  CodeMirror.addClass = addClass;\n  CodeMirror.contains = contains;\n  CodeMirror.rmClass = rmClass;\n  CodeMirror.keyNames = keyNames;\n}\n\n// EDITOR CONSTRUCTOR\n\ndefineOptions(CodeMirror$1);\n\naddEditorMethods(CodeMirror$1);\n\n// Set up methods on CodeMirror's prototype to redirect to the editor's document.\nvar dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\nfor (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n  { CodeMirror$1.prototype[prop] = (function(method) {\n    return function() {return method.apply(this.doc, arguments)}\n  })(Doc.prototype[prop]); } }\n\neventMixin(Doc);\n\n// INPUT HANDLING\n\nCodeMirror$1.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n// MODE DEFINITION AND QUERYING\n\n// Extra arguments are stored as the mode's dependencies, which is\n// used by (legacy) mechanisms like loadmode.js to automatically\n// load a mode. (Preferred mechanism is the require/define calls.)\nCodeMirror$1.defineMode = function(name/*, mode, …*/) {\n  if (!CodeMirror$1.defaults.mode && name != \"null\") { CodeMirror$1.defaults.mode = name; }\n  defineMode.apply(this, arguments);\n};\n\nCodeMirror$1.defineMIME = defineMIME;\n\n// Minimal default mode.\nCodeMirror$1.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\nCodeMirror$1.defineMIME(\"text/plain\", \"null\");\n\n// EXTENSIONS\n\nCodeMirror$1.defineExtension = function (name, func) {\n  CodeMirror$1.prototype[name] = func;\n};\nCodeMirror$1.defineDocExtension = function (name, func) {\n  Doc.prototype[name] = func;\n};\n\nCodeMirror$1.fromTextArea = fromTextArea;\n\naddLegacyProps(CodeMirror$1);\n\nCodeMirror$1.version = \"5.28.0\";\n\nreturn CodeMirror$1;\n\n})));\n\n\n/***/ }),\n\n/***/ 179:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Super simple wysiwyg editor v0.8.1\n * http://summernote.org/\n *\n * summernote.js\n * Copyright 2013-2015 Alan Hong. and other contributors\n * summernote may be freely distributed under the MIT license./\n *\n * Date: 2016-05-26T08:13Z\n */\n(function (factory) {\n  /* global define */\n  if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(142)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof module === 'object' && module.exports) {\n    // Node/CommonJS\n    module.exports = factory(require('jquery'));\n  } else {\n    // Browser globals\n    factory(window.jQuery);\n  }\n}(function ($) {\n  'use strict';\n\n  /**\n   * @class core.func\n   *\n   * func utils (for high-order func's arg)\n   *\n   * @singleton\n   * @alternateClassName func\n   */\n  var func = (function () {\n    var eq = function (itemA) {\n      return function (itemB) {\n        return itemA === itemB;\n      };\n    };\n\n    var eq2 = function (itemA, itemB) {\n      return itemA === itemB;\n    };\n\n    var peq2 = function (propName) {\n      return function (itemA, itemB) {\n        return itemA[propName] === itemB[propName];\n      };\n    };\n\n    var ok = function () {\n      return true;\n    };\n\n    var fail = function () {\n      return false;\n    };\n\n    var not = function (f) {\n      return function () {\n        return !f.apply(f, arguments);\n      };\n    };\n\n    var and = function (fA, fB) {\n      return function (item) {\n        return fA(item) && fB(item);\n      };\n    };\n\n    var self = function (a) {\n      return a;\n    };\n\n    var invoke = function (obj, method) {\n      return function () {\n        return obj[method].apply(obj, arguments);\n      };\n    };\n\n    var idCounter = 0;\n\n    /**\n     * generate a globally-unique id\n     *\n     * @param {String} [prefix]\n     */\n    var uniqueId = function (prefix) {\n      var id = ++idCounter + '';\n      return prefix ? prefix + id : id;\n    };\n\n    /**\n     * returns bnd (bounds) from rect\n     *\n     * - IE Compatibility Issue: http://goo.gl/sRLOAo\n     * - Scroll Issue: http://goo.gl/sNjUc\n     *\n     * @param {Rect} rect\n     * @return {Object} bounds\n     * @return {Number} bounds.top\n     * @return {Number} bounds.left\n     * @return {Number} bounds.width\n     * @return {Number} bounds.height\n     */\n    var rect2bnd = function (rect) {\n      var $document = $(document);\n      return {\n        top: rect.top + $document.scrollTop(),\n        left: rect.left + $document.scrollLeft(),\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top\n      };\n    };\n\n    /**\n     * returns a copy of the object where the keys have become the values and the values the keys.\n     * @param {Object} obj\n     * @return {Object}\n     */\n    var invertObject = function (obj) {\n      var inverted = {};\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          inverted[obj[key]] = key;\n        }\n      }\n      return inverted;\n    };\n\n    /**\n     * @param {String} namespace\n     * @param {String} [prefix]\n     * @return {String}\n     */\n    var namespaceToCamel = function (namespace, prefix) {\n      prefix = prefix || '';\n      return prefix + namespace.split('.').map(function (name) {\n        return name.substring(0, 1).toUpperCase() + name.substring(1);\n      }).join('');\n    };\n\n    return {\n      eq: eq,\n      eq2: eq2,\n      peq2: peq2,\n      ok: ok,\n      fail: fail,\n      self: self,\n      not: not,\n      and: and,\n      invoke: invoke,\n      uniqueId: uniqueId,\n      rect2bnd: rect2bnd,\n      invertObject: invertObject,\n      namespaceToCamel: namespaceToCamel\n    };\n  })();\n\n  /**\n   * @class core.list\n   *\n   * list utils\n   *\n   * @singleton\n   * @alternateClassName list\n   */\n  var list = (function () {\n    /**\n     * returns the first item of an array.\n     *\n     * @param {Array} array\n     */\n    var head = function (array) {\n      return array[0];\n    };\n\n    /**\n     * returns the last item of an array.\n     *\n     * @param {Array} array\n     */\n    var last = function (array) {\n      return array[array.length - 1];\n    };\n\n    /**\n     * returns everything but the last entry of the array.\n     *\n     * @param {Array} array\n     */\n    var initial = function (array) {\n      return array.slice(0, array.length - 1);\n    };\n\n    /**\n     * returns the rest of the items in an array.\n     *\n     * @param {Array} array\n     */\n    var tail = function (array) {\n      return array.slice(1);\n    };\n\n    /**\n     * returns item of array\n     */\n    var find = function (array, pred) {\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        var item = array[idx];\n        if (pred(item)) {\n          return item;\n        }\n      }\n    };\n\n    /**\n     * returns true if all of the values in the array pass the predicate truth test.\n     */\n    var all = function (array, pred) {\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (!pred(array[idx])) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    /**\n     * returns index of item\n     */\n    var indexOf = function (array, item) {\n      return $.inArray(item, array);\n    };\n\n    /**\n     * returns true if the value is present in the list.\n     */\n    var contains = function (array, item) {\n      return indexOf(array, item) !== -1;\n    };\n\n    /**\n     * get sum from a list\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - iterator\n     */\n    var sum = function (array, fn) {\n      fn = fn || func.self;\n      return array.reduce(function (memo, v) {\n        return memo + fn(v);\n      }, 0);\n    };\n  \n    /**\n     * returns a copy of the collection with array type.\n     * @param {Collection} collection - collection eg) node.childNodes, ...\n     */\n    var from = function (collection) {\n      var result = [], idx = -1, length = collection.length;\n      while (++idx < length) {\n        result[idx] = collection[idx];\n      }\n      return result;\n    };\n\n    /**\n     * returns whether list is empty or not\n     */\n    var isEmpty = function (array) {\n      return !array || !array.length;\n    };\n  \n    /**\n     * cluster elements by predicate function.\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - predicate function for cluster rule\n     * @param {Array[]}\n     */\n    var clusterBy = function (array, fn) {\n      if (!array.length) { return []; }\n      var aTail = tail(array);\n      return aTail.reduce(function (memo, v) {\n        var aLast = last(memo);\n        if (fn(last(aLast), v)) {\n          aLast[aLast.length] = v;\n        } else {\n          memo[memo.length] = [v];\n        }\n        return memo;\n      }, [[head(array)]]);\n    };\n  \n    /**\n     * returns a copy of the array with all falsy values removed\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - predicate function for cluster rule\n     */\n    var compact = function (array) {\n      var aResult = [];\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (array[idx]) { aResult.push(array[idx]); }\n      }\n      return aResult;\n    };\n\n    /**\n     * produces a duplicate-free version of the array\n     *\n     * @param {Array} array\n     */\n    var unique = function (array) {\n      var results = [];\n\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (!contains(results, array[idx])) {\n          results.push(array[idx]);\n        }\n      }\n\n      return results;\n    };\n\n    /**\n     * returns next item.\n     * @param {Array} array\n     */\n    var next = function (array, item) {\n      var idx = indexOf(array, item);\n      if (idx === -1) { return null; }\n\n      return array[idx + 1];\n    };\n\n    /**\n     * returns prev item.\n     * @param {Array} array\n     */\n    var prev = function (array, item) {\n      var idx = indexOf(array, item);\n      if (idx === -1) { return null; }\n\n      return array[idx - 1];\n    };\n\n    return { head: head, last: last, initial: initial, tail: tail,\n             prev: prev, next: next, find: find, contains: contains,\n             all: all, sum: sum, from: from, isEmpty: isEmpty,\n             clusterBy: clusterBy, compact: compact, unique: unique };\n  })();\n\n  var isSupportAmd = \"function\" === 'function' && __webpack_require__(180);\n\n  /**\n   * returns whether font is installed or not.\n   *\n   * @param {String} fontName\n   * @return {Boolean}\n   */\n  var isFontInstalled = function (fontName) {\n    var testFontName = fontName === 'Comic Sans MS' ? 'Courier New' : 'Comic Sans MS';\n    var $tester = $('<div>').css({\n      position: 'absolute',\n      left: '-9999px',\n      top: '-9999px',\n      fontSize: '200px'\n    }).text('mmmmmmmmmwwwwwww').appendTo(document.body);\n\n    var originalWidth = $tester.css('fontFamily', testFontName).width();\n    var width = $tester.css('fontFamily', fontName + ',' + testFontName).width();\n\n    $tester.remove();\n\n    return originalWidth !== width;\n  };\n\n  var userAgent = navigator.userAgent;\n  var isMSIE = /MSIE|Trident/i.test(userAgent);\n  var browserVersion;\n  if (isMSIE) {\n    var matches = /MSIE (\\d+[.]\\d+)/.exec(userAgent);\n    if (matches) {\n      browserVersion = parseFloat(matches[1]);\n    }\n    matches = /Trident\\/.*rv:([0-9]{1,}[\\.0-9]{0,})/.exec(userAgent);\n    if (matches) {\n      browserVersion = parseFloat(matches[1]);\n    }\n  }\n\n  var isEdge = /Edge\\/\\d+/.test(userAgent);\n\n  var hasCodeMirror = !!window.CodeMirror;\n  if (!hasCodeMirror && isSupportAmd) {\n    try {\n      // If CodeMirror can't be resolved, `require.resolve` will throw an\n      // exception and `hasCodeMirror` won't be set to `true`.\n      /*require.resolve*/(144);\n      hasCodeMirror = true;\n    } catch (e) {\n      hasCodeMirror = false;\n    }\n  }\n\n  /**\n   * @class core.agent\n   *\n   * Object which check platform and agent\n   *\n   * @singleton\n   * @alternateClassName agent\n   */\n  var agent = {\n    isMac: navigator.appVersion.indexOf('Mac') > -1,\n    isMSIE: isMSIE,\n    isEdge: isEdge,\n    isFF: !isEdge && /firefox/i.test(userAgent),\n    isPhantom: /PhantomJS/i.test(userAgent),\n    isWebkit: !isEdge && /webkit/i.test(userAgent),\n    isChrome: !isEdge && /chrome/i.test(userAgent),\n    isSafari: !isEdge && /safari/i.test(userAgent),\n    browserVersion: browserVersion,\n    jqueryVersion: parseFloat($.fn.jquery),\n    isSupportAmd: isSupportAmd,\n    hasCodeMirror: hasCodeMirror,\n    isFontInstalled: isFontInstalled,\n    isW3CRangeSupport: !!document.createRange\n  };\n\n\n  var NBSP_CHAR = String.fromCharCode(160);\n  var ZERO_WIDTH_NBSP_CHAR = '\\ufeff';\n\n  /**\n   * @class core.dom\n   *\n   * Dom functions\n   *\n   * @singleton\n   * @alternateClassName dom\n   */\n  var dom = (function () {\n    /**\n     * @method isEditable\n     *\n     * returns whether node is `note-editable` or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isEditable = function (node) {\n      return node && $(node).hasClass('note-editable');\n    };\n\n    /**\n     * @method isControlSizing\n     *\n     * returns whether node is `note-control-sizing` or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isControlSizing = function (node) {\n      return node && $(node).hasClass('note-control-sizing');\n    };\n\n    /**\n     * @method makePredByNodeName\n     *\n     * returns predicate which judge whether nodeName is same\n     *\n     * @param {String} nodeName\n     * @return {Function}\n     */\n    var makePredByNodeName = function (nodeName) {\n      nodeName = nodeName.toUpperCase();\n      return function (node) {\n        return node && node.nodeName.toUpperCase() === nodeName;\n      };\n    };\n\n    /**\n     * @method isText\n     *\n     *\n     *\n     * @param {Node} node\n     * @return {Boolean} true if node's type is text(3)\n     */\n    var isText = function (node) {\n      return node && node.nodeType === 3;\n    };\n\n    /**\n     * @method isElement\n     *\n     *\n     *\n     * @param {Node} node\n     * @return {Boolean} true if node's type is element(1)\n     */\n    var isElement = function (node) {\n      return node && node.nodeType === 1;\n    };\n\n    /**\n     * ex) br, col, embed, hr, img, input, ...\n     * @see http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\n     */\n    var isVoid = function (node) {\n      return node && /^BR|^IMG|^HR|^IFRAME|^BUTTON/.test(node.nodeName.toUpperCase());\n    };\n\n    var isPara = function (node) {\n      if (isEditable(node)) {\n        return false;\n      }\n\n      // Chrome(v31.0), FF(v25.0.1) use DIV for paragraph\n      return node && /^DIV|^P|^LI|^H[1-7]/.test(node.nodeName.toUpperCase());\n    };\n\n    var isHeading = function (node) {\n      return node && /^H[1-7]/.test(node.nodeName.toUpperCase());\n    };\n\n    var isPre = makePredByNodeName('PRE');\n\n    var isLi = makePredByNodeName('LI');\n\n    var isPurePara = function (node) {\n      return isPara(node) && !isLi(node);\n    };\n\n    var isTable = makePredByNodeName('TABLE');\n\n    var isInline = function (node) {\n      return !isBodyContainer(node) &&\n             !isList(node) &&\n             !isHr(node) &&\n             !isPara(node) &&\n             !isTable(node) &&\n             !isBlockquote(node);\n    };\n\n    var isList = function (node) {\n      return node && /^UL|^OL/.test(node.nodeName.toUpperCase());\n    };\n\n    var isHr = makePredByNodeName('HR');\n\n    var isCell = function (node) {\n      return node && /^TD|^TH/.test(node.nodeName.toUpperCase());\n    };\n\n    var isBlockquote = makePredByNodeName('BLOCKQUOTE');\n\n    var isBodyContainer = function (node) {\n      return isCell(node) || isBlockquote(node) || isEditable(node);\n    };\n\n    var isAnchor = makePredByNodeName('A');\n\n    var isParaInline = function (node) {\n      return isInline(node) && !!ancestor(node, isPara);\n    };\n\n    var isBodyInline = function (node) {\n      return isInline(node) && !ancestor(node, isPara);\n    };\n\n    var isBody = makePredByNodeName('BODY');\n\n    /**\n     * returns whether nodeB is closest sibling of nodeA\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     * @return {Boolean}\n     */\n    var isClosestSibling = function (nodeA, nodeB) {\n      return nodeA.nextSibling === nodeB ||\n             nodeA.previousSibling === nodeB;\n    };\n\n    /**\n     * returns array of closest siblings with node\n     *\n     * @param {Node} node\n     * @param {function} [pred] - predicate function\n     * @return {Node[]}\n     */\n    var withClosestSiblings = function (node, pred) {\n      pred = pred || func.ok;\n\n      var siblings = [];\n      if (node.previousSibling && pred(node.previousSibling)) {\n        siblings.push(node.previousSibling);\n      }\n      siblings.push(node);\n      if (node.nextSibling && pred(node.nextSibling)) {\n        siblings.push(node.nextSibling);\n      }\n      return siblings;\n    };\n\n    /**\n     * blank HTML for cursor position\n     * - [workaround] old IE only works with &nbsp;\n     * - [workaround] IE11 and other browser works with bogus br\n     */\n    var blankHTML = agent.isMSIE && agent.browserVersion < 11 ? '&nbsp;' : '<br>';\n\n    /**\n     * @method nodeLength\n     *\n     * returns #text's text size or element's childNodes size\n     *\n     * @param {Node} node\n     */\n    var nodeLength = function (node) {\n      if (isText(node)) {\n        return node.nodeValue.length;\n      }\n\n      return node.childNodes.length;\n    };\n\n    /**\n     * returns whether node is empty or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isEmpty = function (node) {\n      var len = nodeLength(node);\n\n      if (len === 0) {\n        return true;\n      } else if (!isText(node) && len === 1 && node.innerHTML === blankHTML) {\n        // ex) <p><br></p>, <span><br></span>\n        return true;\n      } else if (list.all(node.childNodes, isText) && node.innerHTML === '') {\n        // ex) <p></p>, <span></span>\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * padding blankHTML if node is empty (for cursor position)\n     */\n    var paddingBlankHTML = function (node) {\n      if (!isVoid(node) && !nodeLength(node)) {\n        node.innerHTML = blankHTML;\n      }\n    };\n\n    /**\n     * find nearest ancestor predicate hit\n     *\n     * @param {Node} node\n     * @param {Function} pred - predicate function\n     */\n    var ancestor = function (node, pred) {\n      while (node) {\n        if (pred(node)) { return node; }\n        if (isEditable(node)) { break; }\n\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    /**\n     * find nearest ancestor only single child blood line and predicate hit\n     *\n     * @param {Node} node\n     * @param {Function} pred - predicate function\n     */\n    var singleChildAncestor = function (node, pred) {\n      node = node.parentNode;\n\n      while (node) {\n        if (nodeLength(node) !== 1) { break; }\n        if (pred(node)) { return node; }\n        if (isEditable(node)) { break; }\n\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    /**\n     * returns new array of ancestor nodes (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [optional] pred - predicate function\n     */\n    var listAncestor = function (node, pred) {\n      pred = pred || func.fail;\n\n      var ancestors = [];\n      ancestor(node, function (el) {\n        if (!isEditable(el)) {\n          ancestors.push(el);\n        }\n\n        return pred(el);\n      });\n      return ancestors;\n    };\n\n    /**\n     * find farthest ancestor predicate hit\n     */\n    var lastAncestor = function (node, pred) {\n      var ancestors = listAncestor(node);\n      return list.last(ancestors.filter(pred));\n    };\n\n    /**\n     * returns common ancestor node between two nodes.\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     */\n    var commonAncestor = function (nodeA, nodeB) {\n      var ancestors = listAncestor(nodeA);\n      for (var n = nodeB; n; n = n.parentNode) {\n        if ($.inArray(n, ancestors) > -1) { return n; }\n      }\n      return null; // difference document area\n    };\n\n    /**\n     * listing all previous siblings (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [optional] pred - predicate function\n     */\n    var listPrev = function (node, pred) {\n      pred = pred || func.fail;\n\n      var nodes = [];\n      while (node) {\n        if (pred(node)) { break; }\n        nodes.push(node);\n        node = node.previousSibling;\n      }\n      return nodes;\n    };\n\n    /**\n     * listing next siblings (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [pred] - predicate function\n     */\n    var listNext = function (node, pred) {\n      pred = pred || func.fail;\n\n      var nodes = [];\n      while (node) {\n        if (pred(node)) { break; }\n        nodes.push(node);\n        node = node.nextSibling;\n      }\n      return nodes;\n    };\n\n    /**\n     * listing descendant nodes\n     *\n     * @param {Node} node\n     * @param {Function} [pred] - predicate function\n     */\n    var listDescendant = function (node, pred) {\n      var descendants = [];\n      pred = pred || func.ok;\n\n      // start DFS(depth first search) with node\n      (function fnWalk(current) {\n        if (node !== current && pred(current)) {\n          descendants.push(current);\n        }\n        for (var idx = 0, len = current.childNodes.length; idx < len; idx++) {\n          fnWalk(current.childNodes[idx]);\n        }\n      })(node);\n\n      return descendants;\n    };\n\n    /**\n     * wrap node with new tag.\n     *\n     * @param {Node} node\n     * @param {Node} tagName of wrapper\n     * @return {Node} - wrapper\n     */\n    var wrap = function (node, wrapperName) {\n      var parent = node.parentNode;\n      var wrapper = $('<' + wrapperName + '>')[0];\n\n      parent.insertBefore(wrapper, node);\n      wrapper.appendChild(node);\n\n      return wrapper;\n    };\n\n    /**\n     * insert node after preceding\n     *\n     * @param {Node} node\n     * @param {Node} preceding - predicate function\n     */\n    var insertAfter = function (node, preceding) {\n      var next = preceding.nextSibling, parent = preceding.parentNode;\n      if (next) {\n        parent.insertBefore(node, next);\n      } else {\n        parent.appendChild(node);\n      }\n      return node;\n    };\n\n    /**\n     * append elements.\n     *\n     * @param {Node} node\n     * @param {Collection} aChild\n     */\n    var appendChildNodes = function (node, aChild) {\n      $.each(aChild, function (idx, child) {\n        node.appendChild(child);\n      });\n      return node;\n    };\n\n    /**\n     * returns whether boundaryPoint is left edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isLeftEdgePoint = function (point) {\n      return point.offset === 0;\n    };\n\n    /**\n     * returns whether boundaryPoint is right edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isRightEdgePoint = function (point) {\n      return point.offset === nodeLength(point.node);\n    };\n\n    /**\n     * returns whether boundaryPoint is edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isEdgePoint = function (point) {\n      return isLeftEdgePoint(point) || isRightEdgePoint(point);\n    };\n\n    /**\n     * returns whether node is left edge of ancestor or not.\n     *\n     * @param {Node} node\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isLeftEdgeOf = function (node, ancestor) {\n      while (node && node !== ancestor) {\n        if (position(node) !== 0) {\n          return false;\n        }\n        node = node.parentNode;\n      }\n\n      return true;\n    };\n\n    /**\n     * returns whether node is right edge of ancestor or not.\n     *\n     * @param {Node} node\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isRightEdgeOf = function (node, ancestor) {\n      while (node && node !== ancestor) {\n        if (position(node) !== nodeLength(node.parentNode) - 1) {\n          return false;\n        }\n        node = node.parentNode;\n      }\n\n      return true;\n    };\n\n    /**\n     * returns whether point is left edge of ancestor or not.\n     * @param {BoundaryPoint} point\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isLeftEdgePointOf = function (point, ancestor) {\n      return isLeftEdgePoint(point) && isLeftEdgeOf(point.node, ancestor);\n    };\n\n    /**\n     * returns whether point is right edge of ancestor or not.\n     * @param {BoundaryPoint} point\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isRightEdgePointOf = function (point, ancestor) {\n      return isRightEdgePoint(point) && isRightEdgeOf(point.node, ancestor);\n    };\n\n    /**\n     * returns offset from parent.\n     *\n     * @param {Node} node\n     */\n    var position = function (node) {\n      var offset = 0;\n      while ((node = node.previousSibling)) {\n        offset += 1;\n      }\n      return offset;\n    };\n\n    var hasChildren = function (node) {\n      return !!(node && node.childNodes && node.childNodes.length);\n    };\n\n    /**\n     * returns previous boundaryPoint\n     *\n     * @param {BoundaryPoint} point\n     * @param {Boolean} isSkipInnerOffset\n     * @return {BoundaryPoint}\n     */\n    var prevPoint = function (point, isSkipInnerOffset) {\n      var node, offset;\n\n      if (point.offset === 0) {\n        if (isEditable(point.node)) {\n          return null;\n        }\n\n        node = point.node.parentNode;\n        offset = position(point.node);\n      } else if (hasChildren(point.node)) {\n        node = point.node.childNodes[point.offset - 1];\n        offset = nodeLength(node);\n      } else {\n        node = point.node;\n        offset = isSkipInnerOffset ? 0 : point.offset - 1;\n      }\n\n      return {\n        node: node,\n        offset: offset\n      };\n    };\n\n    /**\n     * returns next boundaryPoint\n     *\n     * @param {BoundaryPoint} point\n     * @param {Boolean} isSkipInnerOffset\n     * @return {BoundaryPoint}\n     */\n    var nextPoint = function (point, isSkipInnerOffset) {\n      var node, offset;\n\n      if (nodeLength(point.node) === point.offset) {\n        if (isEditable(point.node)) {\n          return null;\n        }\n\n        node = point.node.parentNode;\n        offset = position(point.node) + 1;\n      } else if (hasChildren(point.node)) {\n        node = point.node.childNodes[point.offset];\n        offset = 0;\n      } else {\n        node = point.node;\n        offset = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;\n      }\n\n      return {\n        node: node,\n        offset: offset\n      };\n    };\n\n    /**\n     * returns whether pointA and pointB is same or not.\n     *\n     * @param {BoundaryPoint} pointA\n     * @param {BoundaryPoint} pointB\n     * @return {Boolean}\n     */\n    var isSamePoint = function (pointA, pointB) {\n      return pointA.node === pointB.node && pointA.offset === pointB.offset;\n    };\n\n    /**\n     * returns whether point is visible (can set cursor) or not.\n     * \n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isVisiblePoint = function (point) {\n      if (isText(point.node) || !hasChildren(point.node) || isEmpty(point.node)) {\n        return true;\n      }\n\n      var leftNode = point.node.childNodes[point.offset - 1];\n      var rightNode = point.node.childNodes[point.offset];\n      if ((!leftNode || isVoid(leftNode)) && (!rightNode || isVoid(rightNode))) {\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * @method prevPointUtil\n     *\n     * @param {BoundaryPoint} point\n     * @param {Function} pred\n     * @return {BoundaryPoint}\n     */\n    var prevPointUntil = function (point, pred) {\n      while (point) {\n        if (pred(point)) {\n          return point;\n        }\n\n        point = prevPoint(point);\n      }\n\n      return null;\n    };\n\n    /**\n     * @method nextPointUntil\n     *\n     * @param {BoundaryPoint} point\n     * @param {Function} pred\n     * @return {BoundaryPoint}\n     */\n    var nextPointUntil = function (point, pred) {\n      while (point) {\n        if (pred(point)) {\n          return point;\n        }\n\n        point = nextPoint(point);\n      }\n\n      return null;\n    };\n\n    /**\n     * returns whether point has character or not.\n     *\n     * @param {Point} point\n     * @return {Boolean}\n     */\n    var isCharPoint = function (point) {\n      if (!isText(point.node)) {\n        return false;\n      }\n\n      var ch = point.node.nodeValue.charAt(point.offset - 1);\n      return ch && (ch !== ' ' && ch !== NBSP_CHAR);\n    };\n\n    /**\n     * @method walkPoint\n     *\n     * @param {BoundaryPoint} startPoint\n     * @param {BoundaryPoint} endPoint\n     * @param {Function} handler\n     * @param {Boolean} isSkipInnerOffset\n     */\n    var walkPoint = function (startPoint, endPoint, handler, isSkipInnerOffset) {\n      var point = startPoint;\n\n      while (point) {\n        handler(point);\n\n        if (isSamePoint(point, endPoint)) {\n          break;\n        }\n\n        var isSkipOffset = isSkipInnerOffset &&\n                           startPoint.node !== point.node &&\n                           endPoint.node !== point.node;\n        point = nextPoint(point, isSkipOffset);\n      }\n    };\n\n    /**\n     * @method makeOffsetPath\n     *\n     * return offsetPath(array of offset) from ancestor\n     *\n     * @param {Node} ancestor - ancestor node\n     * @param {Node} node\n     */\n    var makeOffsetPath = function (ancestor, node) {\n      var ancestors = listAncestor(node, func.eq(ancestor));\n      return ancestors.map(position).reverse();\n    };\n\n    /**\n     * @method fromOffsetPath\n     *\n     * return element from offsetPath(array of offset)\n     *\n     * @param {Node} ancestor - ancestor node\n     * @param {array} offsets - offsetPath\n     */\n    var fromOffsetPath = function (ancestor, offsets) {\n      var current = ancestor;\n      for (var i = 0, len = offsets.length; i < len; i++) {\n        if (current.childNodes.length <= offsets[i]) {\n          current = current.childNodes[current.childNodes.length - 1];\n        } else {\n          current = current.childNodes[offsets[i]];\n        }\n      }\n      return current;\n    };\n\n    /**\n     * @method splitNode\n     *\n     * split element or #text\n     *\n     * @param {BoundaryPoint} point\n     * @param {Object} [options]\n     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n     * @return {Node} right node of boundaryPoint\n     */\n    var splitNode = function (point, options) {\n      var isSkipPaddingBlankHTML = options && options.isSkipPaddingBlankHTML;\n      var isNotSplitEdgePoint = options && options.isNotSplitEdgePoint;\n\n      // edge case\n      if (isEdgePoint(point) && (isText(point.node) || isNotSplitEdgePoint)) {\n        if (isLeftEdgePoint(point)) {\n          return point.node;\n        } else if (isRightEdgePoint(point)) {\n          return point.node.nextSibling;\n        }\n      }\n\n      // split #text\n      if (isText(point.node)) {\n        return point.node.splitText(point.offset);\n      } else {\n        var childNode = point.node.childNodes[point.offset];\n        var clone = insertAfter(point.node.cloneNode(false), point.node);\n        appendChildNodes(clone, listNext(childNode));\n\n        if (!isSkipPaddingBlankHTML) {\n          paddingBlankHTML(point.node);\n          paddingBlankHTML(clone);\n        }\n\n        return clone;\n      }\n    };\n\n    /**\n     * @method splitTree\n     *\n     * split tree by point\n     *\n     * @param {Node} root - split root\n     * @param {BoundaryPoint} point\n     * @param {Object} [options]\n     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n     * @return {Node} right node of boundaryPoint\n     */\n    var splitTree = function (root, point, options) {\n      // ex) [#text, <span>, <p>]\n      var ancestors = listAncestor(point.node, func.eq(root));\n\n      if (!ancestors.length) {\n        return null;\n      } else if (ancestors.length === 1) {\n        return splitNode(point, options);\n      }\n\n      return ancestors.reduce(function (node, parent) {\n        if (node === point.node) {\n          node = splitNode(point, options);\n        }\n\n        return splitNode({\n          node: parent,\n          offset: node ? dom.position(node) : nodeLength(parent)\n        }, options);\n      });\n    };\n\n    /**\n     * split point\n     *\n     * @param {Point} point\n     * @param {Boolean} isInline\n     * @return {Object}\n     */\n    var splitPoint = function (point, isInline) {\n      // find splitRoot, container\n      //  - inline: splitRoot is a child of paragraph\n      //  - block: splitRoot is a child of bodyContainer\n      var pred = isInline ? isPara : isBodyContainer;\n      var ancestors = listAncestor(point.node, pred);\n      var topAncestor = list.last(ancestors) || point.node;\n\n      var splitRoot, container;\n      if (pred(topAncestor)) {\n        splitRoot = ancestors[ancestors.length - 2];\n        container = topAncestor;\n      } else {\n        splitRoot = topAncestor;\n        container = splitRoot.parentNode;\n      }\n\n      // if splitRoot is exists, split with splitTree\n      var pivot = splitRoot && splitTree(splitRoot, point, {\n        isSkipPaddingBlankHTML: isInline,\n        isNotSplitEdgePoint: isInline\n      });\n\n      // if container is point.node, find pivot with point.offset\n      if (!pivot && container === point.node) {\n        pivot = point.node.childNodes[point.offset];\n      }\n\n      return {\n        rightNode: pivot,\n        container: container\n      };\n    };\n\n    var create = function (nodeName) {\n      return document.createElement(nodeName);\n    };\n\n    var createText = function (text) {\n      return document.createTextNode(text);\n    };\n\n    /**\n     * @method remove\n     *\n     * remove node, (isRemoveChild: remove child or not)\n     *\n     * @param {Node} node\n     * @param {Boolean} isRemoveChild\n     */\n    var remove = function (node, isRemoveChild) {\n      if (!node || !node.parentNode) { return; }\n      if (node.removeNode) { return node.removeNode(isRemoveChild); }\n\n      var parent = node.parentNode;\n      if (!isRemoveChild) {\n        var nodes = [];\n        var i, len;\n        for (i = 0, len = node.childNodes.length; i < len; i++) {\n          nodes.push(node.childNodes[i]);\n        }\n\n        for (i = 0, len = nodes.length; i < len; i++) {\n          parent.insertBefore(nodes[i], node);\n        }\n      }\n\n      parent.removeChild(node);\n    };\n\n    /**\n     * @method removeWhile\n     *\n     * @param {Node} node\n     * @param {Function} pred\n     */\n    var removeWhile = function (node, pred) {\n      while (node) {\n        if (isEditable(node) || !pred(node)) {\n          break;\n        }\n\n        var parent = node.parentNode;\n        remove(node);\n        node = parent;\n      }\n    };\n\n    /**\n     * @method replace\n     *\n     * replace node with provided nodeName\n     *\n     * @param {Node} node\n     * @param {String} nodeName\n     * @return {Node} - new node\n     */\n    var replace = function (node, nodeName) {\n      if (node.nodeName.toUpperCase() === nodeName.toUpperCase()) {\n        return node;\n      }\n\n      var newNode = create(nodeName);\n\n      if (node.style.cssText) {\n        newNode.style.cssText = node.style.cssText;\n      }\n\n      appendChildNodes(newNode, list.from(node.childNodes));\n      insertAfter(newNode, node);\n      remove(node);\n\n      return newNode;\n    };\n\n    var isTextarea = makePredByNodeName('TEXTAREA');\n\n    /**\n     * @param {jQuery} $node\n     * @param {Boolean} [stripLinebreaks] - default: false\n     */\n    var value = function ($node, stripLinebreaks) {\n      var val = isTextarea($node[0]) ? $node.val() : $node.html();\n      if (stripLinebreaks) {\n        return val.replace(/[\\n\\r]/g, '');\n      }\n      return val;\n    };\n\n    /**\n     * @method html\n     *\n     * get the HTML contents of node\n     *\n     * @param {jQuery} $node\n     * @param {Boolean} [isNewlineOnBlock]\n     */\n    var html = function ($node, isNewlineOnBlock) {\n      var markup = value($node);\n\n      if (isNewlineOnBlock) {\n        var regexTag = /<(\\/?)(\\b(?!!)[^>\\s]*)(.*?)(\\s*\\/?>)/g;\n        markup = markup.replace(regexTag, function (match, endSlash, name) {\n          name = name.toUpperCase();\n          var isEndOfInlineContainer = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(name) &&\n                                       !!endSlash;\n          var isBlockNode = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(name);\n\n          return match + ((isEndOfInlineContainer || isBlockNode) ? '\\n' : '');\n        });\n        markup = $.trim(markup);\n      }\n\n      return markup;\n    };\n\n    var posFromPlaceholder = function (placeholder) {\n      var $placeholder = $(placeholder);\n      var pos = $placeholder.offset();\n      var height = $placeholder.outerHeight(true); // include margin\n\n      return {\n        left: pos.left,\n        top: pos.top + height\n      };\n    };\n\n    var attachEvents = function ($node, events) {\n      Object.keys(events).forEach(function (key) {\n        $node.on(key, events[key]);\n      });\n    };\n\n    var detachEvents = function ($node, events) {\n      Object.keys(events).forEach(function (key) {\n        $node.off(key, events[key]);\n      });\n    };\n\n    return {\n      /** @property {String} NBSP_CHAR */\n      NBSP_CHAR: NBSP_CHAR,\n      /** @property {String} ZERO_WIDTH_NBSP_CHAR */\n      ZERO_WIDTH_NBSP_CHAR: ZERO_WIDTH_NBSP_CHAR,\n      /** @property {String} blank */\n      blank: blankHTML,\n      /** @property {String} emptyPara */\n      emptyPara: '<p>' + blankHTML + '</p>',\n      makePredByNodeName: makePredByNodeName,\n      isEditable: isEditable,\n      isControlSizing: isControlSizing,\n      isText: isText,\n      isElement: isElement,\n      isVoid: isVoid,\n      isPara: isPara,\n      isPurePara: isPurePara,\n      isHeading: isHeading,\n      isInline: isInline,\n      isBlock: func.not(isInline),\n      isBodyInline: isBodyInline,\n      isBody: isBody,\n      isParaInline: isParaInline,\n      isPre: isPre,\n      isList: isList,\n      isTable: isTable,\n      isCell: isCell,\n      isBlockquote: isBlockquote,\n      isBodyContainer: isBodyContainer,\n      isAnchor: isAnchor,\n      isDiv: makePredByNodeName('DIV'),\n      isLi: isLi,\n      isBR: makePredByNodeName('BR'),\n      isSpan: makePredByNodeName('SPAN'),\n      isB: makePredByNodeName('B'),\n      isU: makePredByNodeName('U'),\n      isS: makePredByNodeName('S'),\n      isI: makePredByNodeName('I'),\n      isImg: makePredByNodeName('IMG'),\n      isTextarea: isTextarea,\n      isEmpty: isEmpty,\n      isEmptyAnchor: func.and(isAnchor, isEmpty),\n      isClosestSibling: isClosestSibling,\n      withClosestSiblings: withClosestSiblings,\n      nodeLength: nodeLength,\n      isLeftEdgePoint: isLeftEdgePoint,\n      isRightEdgePoint: isRightEdgePoint,\n      isEdgePoint: isEdgePoint,\n      isLeftEdgeOf: isLeftEdgeOf,\n      isRightEdgeOf: isRightEdgeOf,\n      isLeftEdgePointOf: isLeftEdgePointOf,\n      isRightEdgePointOf: isRightEdgePointOf,\n      prevPoint: prevPoint,\n      nextPoint: nextPoint,\n      isSamePoint: isSamePoint,\n      isVisiblePoint: isVisiblePoint,\n      prevPointUntil: prevPointUntil,\n      nextPointUntil: nextPointUntil,\n      isCharPoint: isCharPoint,\n      walkPoint: walkPoint,\n      ancestor: ancestor,\n      singleChildAncestor: singleChildAncestor,\n      listAncestor: listAncestor,\n      lastAncestor: lastAncestor,\n      listNext: listNext,\n      listPrev: listPrev,\n      listDescendant: listDescendant,\n      commonAncestor: commonAncestor,\n      wrap: wrap,\n      insertAfter: insertAfter,\n      appendChildNodes: appendChildNodes,\n      position: position,\n      hasChildren: hasChildren,\n      makeOffsetPath: makeOffsetPath,\n      fromOffsetPath: fromOffsetPath,\n      splitTree: splitTree,\n      splitPoint: splitPoint,\n      create: create,\n      createText: createText,\n      remove: remove,\n      removeWhile: removeWhile,\n      replace: replace,\n      html: html,\n      value: value,\n      posFromPlaceholder: posFromPlaceholder,\n      attachEvents: attachEvents,\n      detachEvents: detachEvents\n    };\n  })();\n\n  /**\n   * @param {jQuery} $note\n   * @param {Object} options\n   * @return {Context}\n   */\n  var Context = function ($note, options) {\n    var self = this;\n\n    var ui = $.summernote.ui;\n    this.memos = {};\n    this.modules = {};\n    this.layoutInfo = {};\n    this.options = options;\n\n    /**\n     * create layout and initialize modules and other resources\n     */\n    this.initialize = function () {\n      this.layoutInfo = ui.createLayout($note, options);\n      this._initialize();\n      $note.hide();\n      return this;\n    };\n\n    /**\n     * destroy modules and other resources and remove layout\n     */\n    this.destroy = function () {\n      this._destroy();\n      $note.removeData('summernote');\n      ui.removeLayout($note, this.layoutInfo);\n    };\n\n    /**\n     * destory modules and other resources and initialize it again\n     */\n    this.reset = function () {\n      var disabled = self.isDisabled();\n      this.code(dom.emptyPara);\n      this._destroy();\n      this._initialize();\n\n      if (disabled) {\n        self.disable();\n      }\n    };\n\n    this._initialize = function () {\n      // add optional buttons\n      var buttons = $.extend({}, this.options.buttons);\n      Object.keys(buttons).forEach(function (key) {\n        self.memo('button.' + key, buttons[key]);\n      });\n\n      var modules = $.extend({}, this.options.modules, $.summernote.plugins || {});\n\n      // add and initialize modules\n      Object.keys(modules).forEach(function (key) {\n        self.module(key, modules[key], true);\n      });\n\n      Object.keys(this.modules).forEach(function (key) {\n        self.initializeModule(key);\n      });\n    };\n\n    this._destroy = function () {\n      // destroy modules with reversed order\n      Object.keys(this.modules).reverse().forEach(function (key) {\n        self.removeModule(key);\n      });\n\n      Object.keys(this.memos).forEach(function (key) {\n        self.removeMemo(key);\n      });\n    };\n\n    this.code = function (html) {\n      var isActivated = this.invoke('codeview.isActivated');\n\n      if (html === undefined) {\n        this.invoke('codeview.sync');\n        return isActivated ? this.layoutInfo.codable.val() : this.layoutInfo.editable.html();\n      } else {\n        if (isActivated) {\n          this.layoutInfo.codable.val(html);\n        } else {\n          this.layoutInfo.editable.html(html);\n        }\n        $note.val(html);\n        this.triggerEvent('change', html);\n      }\n    };\n\n    this.isDisabled = function () {\n      return this.layoutInfo.editable.attr('contenteditable') === 'false';\n    };\n\n    this.enable = function () {\n      this.layoutInfo.editable.attr('contenteditable', true);\n      this.invoke('toolbar.activate', true);\n    };\n\n    this.disable = function () {\n      // close codeview if codeview is opend\n      if (this.invoke('codeview.isActivated')) {\n        this.invoke('codeview.deactivate');\n      }\n      this.layoutInfo.editable.attr('contenteditable', false);\n      this.invoke('toolbar.deactivate', true);\n    };\n\n    this.triggerEvent = function () {\n      var namespace = list.head(arguments);\n      var args = list.tail(list.from(arguments));\n\n      var callback = this.options.callbacks[func.namespaceToCamel(namespace, 'on')];\n      if (callback) {\n        callback.apply($note[0], args);\n      }\n      $note.trigger('summernote.' + namespace, args);\n    };\n\n    this.initializeModule = function (key) {\n      var module = this.modules[key];\n      module.shouldInitialize = module.shouldInitialize || func.ok;\n      if (!module.shouldInitialize()) {\n        return;\n      }\n\n      // initialize module\n      if (module.initialize) {\n        module.initialize();\n      }\n\n      // attach events\n      if (module.events) {\n        dom.attachEvents($note, module.events);\n      }\n    };\n\n    this.module = function (key, ModuleClass, withoutIntialize) {\n      if (arguments.length === 1) {\n        return this.modules[key];\n      }\n\n      this.modules[key] = new ModuleClass(this);\n\n      if (!withoutIntialize) {\n        this.initializeModule(key);\n      }\n    };\n\n    this.removeModule = function (key) {\n      var module = this.modules[key];\n      if (module.shouldInitialize()) {\n        if (module.events) {\n          dom.detachEvents($note, module.events);\n        }\n\n        if (module.destroy) {\n          module.destroy();\n        }\n      }\n\n      delete this.modules[key];\n    };\n\n    this.memo = function (key, obj) {\n      if (arguments.length === 1) {\n        return this.memos[key];\n      }\n      this.memos[key] = obj;\n    };\n\n    this.removeMemo = function (key) {\n      if (this.memos[key] && this.memos[key].destroy) {\n        this.memos[key].destroy();\n      }\n\n      delete this.memos[key];\n    };\n\n    this.createInvokeHandler = function (namespace, value) {\n      return function (event) {\n        event.preventDefault();\n        self.invoke(namespace, value || $(event.target).closest('[data-value]').data('value'));\n      };\n    };\n\n    this.invoke = function () {\n      var namespace = list.head(arguments);\n      var args = list.tail(list.from(arguments));\n\n      var splits = namespace.split('.');\n      var hasSeparator = splits.length > 1;\n      var moduleName = hasSeparator && list.head(splits);\n      var methodName = hasSeparator ? list.last(splits) : list.head(splits);\n\n      var module = this.modules[moduleName || 'editor'];\n      if (!moduleName && this[methodName]) {\n        return this[methodName].apply(this, args);\n      } else if (module && module[methodName] && module.shouldInitialize()) {\n        return module[methodName].apply(module, args);\n      }\n    };\n\n    return this.initialize();\n  };\n\n  $.fn.extend({\n    /**\n     * Summernote API\n     *\n     * @param {Object|String}\n     * @return {this}\n     */\n    summernote: function () {\n      var type = $.type(list.head(arguments));\n      var isExternalAPICalled = type === 'string';\n      var hasInitOptions = type === 'object';\n\n      var options = hasInitOptions ? list.head(arguments) : {};\n\n      options = $.extend({}, $.summernote.options, options);\n      options.langInfo = $.extend(true, {}, $.summernote.lang['en-US'], $.summernote.lang[options.lang]);\n\n      this.each(function (idx, note) {\n        var $note = $(note);\n        if (!$note.data('summernote')) {\n          var context = new Context($note, options);\n          $note.data('summernote', context);\n          $note.data('summernote').triggerEvent('init', context.layoutInfo);\n        }\n      });\n\n      var $note = this.first();\n      if ($note.length) {\n        var context = $note.data('summernote');\n        if (isExternalAPICalled) {\n          return context.invoke.apply(context, list.from(arguments));\n        } else if (options.focus) {\n          context.invoke('editor.focus');\n        }\n      }\n\n      return this;\n    }\n  });\n\n\n  var Renderer = function (markup, children, options, callback) {\n    this.render = function ($parent) {\n      var $node = $(markup);\n\n      if (options && options.contents) {\n        $node.html(options.contents);\n      }\n\n      if (options && options.className) {\n        $node.addClass(options.className);\n      }\n\n      if (options && options.data) {\n        $.each(options.data, function (k, v) {\n          $node.attr('data-' + k, v);\n        });\n      }\n\n      if (options && options.click) {\n        $node.on('click', options.click);\n      }\n\n      if (children) {\n        var $container = $node.find('.note-children-container');\n        children.forEach(function (child) {\n          child.render($container.length ? $container : $node);\n        });\n      }\n\n      if (callback) {\n        callback($node, options);\n      }\n\n      if (options && options.callback) {\n        options.callback($node);\n      }\n\n      if ($parent) {\n        $parent.append($node);\n      }\n\n      return $node;\n    };\n  };\n\n  var renderer = {\n    create: function (markup, callback) {\n      return function () {\n        var children = $.isArray(arguments[0]) ? arguments[0] : [];\n        var options = typeof arguments[1] === 'object' ? arguments[1] : arguments[0];\n        if (options && options.children) {\n          children = options.children;\n        }\n        return new Renderer(markup, children, options, callback);\n      };\n    }\n  };\n\n  var editor = renderer.create('<div class=\"note-editor note-frame panel panel-default\"/>');\n  var toolbar = renderer.create('<div class=\"note-toolbar panel-heading\"/>');\n  var editingArea = renderer.create('<div class=\"note-editing-area\"/>');\n  var codable = renderer.create('<textarea class=\"note-codable\"/>');\n  var editable = renderer.create('<div class=\"note-editable panel-body\" contentEditable=\"true\"/>');\n  var statusbar = renderer.create([\n    '<div class=\"note-statusbar\">',\n    '  <div class=\"note-resizebar\">',\n    '    <div class=\"note-icon-bar\"/>',\n    '    <div class=\"note-icon-bar\"/>',\n    '    <div class=\"note-icon-bar\"/>',\n    '  </div>',\n    '</div>'\n  ].join(''));\n\n  var airEditor = renderer.create('<div class=\"note-editor\"/>');\n  var airEditable = renderer.create('<div class=\"note-editable\" contentEditable=\"true\"/>');\n\n  var buttonGroup = renderer.create('<div class=\"note-btn-group btn-group\">');\n  var button = renderer.create('<button type=\"button\" class=\"note-btn btn btn-default btn-sm\">', function ($node, options) {\n    if (options && options.tooltip) {\n      $node.attr({\n        title: options.tooltip\n      }).tooltip({\n        container: 'body',\n        trigger: 'hover',\n        placement: 'bottom'\n      });\n    }\n  });\n\n  var dropdown = renderer.create('<div class=\"dropdown-menu\">', function ($node, options) {\n    var markup = $.isArray(options.items) ? options.items.map(function (item) {\n      var value = (typeof item === 'string') ? item : (item.value || '');\n      var content = options.template ? options.template(item) : item;\n      return '<li><a href=\"#\" data-value=\"' + value + '\">' + content + '</a></li>';\n    }).join('') : options.items;\n\n    $node.html(markup);\n  });\n\n  var dropdownCheck = renderer.create('<div class=\"dropdown-menu note-check\">', function ($node, options) {\n    var markup = $.isArray(options.items) ? options.items.map(function (item) {\n      var value = (typeof item === 'string') ? item : (item.value || '');\n      var content = options.template ? options.template(item) : item;\n      return '<li><a href=\"#\" data-value=\"' + value + '\">' + icon(options.checkClassName) + ' ' + content + '</a></li>';\n    }).join('') : options.items;\n    $node.html(markup);\n  });\n\n  var palette = renderer.create('<div class=\"note-color-palette\"/>', function ($node, options) {\n    var contents = [];\n    for (var row = 0, rowSize = options.colors.length; row < rowSize; row++) {\n      var eventName = options.eventName;\n      var colors = options.colors[row];\n      var buttons = [];\n      for (var col = 0, colSize = colors.length; col < colSize; col++) {\n        var color = colors[col];\n        buttons.push([\n          '<button type=\"button\" class=\"note-color-btn\"',\n          'style=\"background-color:', color, '\" ',\n          'data-event=\"', eventName, '\" ',\n          'data-value=\"', color, '\" ',\n          'title=\"', color, '\" ',\n          'data-toggle=\"button\" tabindex=\"-1\"></button>'\n        ].join(''));\n      }\n      contents.push('<div class=\"note-color-row\">' + buttons.join('') + '</div>');\n    }\n    $node.html(contents.join(''));\n\n    $node.find('.note-color-btn').tooltip({\n      container: 'body',\n      trigger: 'hover',\n      placement: 'bottom'\n    });\n  });\n\n  var dialog = renderer.create('<div class=\"modal\" aria-hidden=\"false\" tabindex=\"-1\"/>', function ($node, options) {\n    if (options.fade) {\n      $node.addClass('fade');\n    }\n    $node.html([\n      '<div class=\"modal-dialog\">',\n      '  <div class=\"modal-content\">',\n      (options.title ?\n      '    <div class=\"modal-header\">' +\n      '      <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>' +\n      '      <h4 class=\"modal-title\">' + options.title + '</h4>' +\n      '    </div>' : ''\n      ),\n      '    <div class=\"modal-body\">' + options.body + '</div>',\n      (options.footer ?\n      '    <div class=\"modal-footer\">' + options.footer + '</div>' : ''\n      ),\n      '  </div>',\n      '</div>'\n    ].join(''));\n  });\n\n  var popover = renderer.create([\n    '<div class=\"note-popover popover in\">',\n    '  <div class=\"arrow\"/>',\n    '  <div class=\"popover-content note-children-container\"/>',\n    '</div>'\n  ].join(''), function ($node, options) {\n    var direction = typeof options.direction !== 'undefined' ? options.direction : 'bottom';\n\n    $node.addClass(direction);\n\n    if (options.hideArrow) {\n      $node.find('.arrow').hide();\n    }\n  });\n\n  var icon = function (iconClassName, tagName) {\n    tagName = tagName || 'i';\n    return '<' + tagName + ' class=\"' + iconClassName + '\"/>';\n  };\n\n  var ui = {\n    editor: editor,\n    toolbar: toolbar,\n    editingArea: editingArea,\n    codable: codable,\n    editable: editable,\n    statusbar: statusbar,\n    airEditor: airEditor,\n    airEditable: airEditable,\n    buttonGroup: buttonGroup,\n    button: button,\n    dropdown: dropdown,\n    dropdownCheck: dropdownCheck,\n    palette: palette,\n    dialog: dialog,\n    popover: popover,\n    icon: icon,\n\n    toggleBtn: function ($btn, isEnable) {\n      $btn.toggleClass('disabled', !isEnable);\n      $btn.attr('disabled', !isEnable);\n    },\n\n    toggleBtnActive: function ($btn, isActive) {\n      $btn.toggleClass('active', isActive);\n    },\n\n    onDialogShown: function ($dialog, handler) {\n      $dialog.one('shown.bs.modal', handler);\n    },\n\n    onDialogHidden: function ($dialog, handler) {\n      $dialog.one('hidden.bs.modal', handler);\n    },\n\n    showDialog: function ($dialog) {\n      $dialog.modal('show');\n    },\n\n    hideDialog: function ($dialog) {\n      $dialog.modal('hide');\n    },\n\n    createLayout: function ($note, options) {\n      var $editor = (options.airMode ? ui.airEditor([\n        ui.editingArea([\n          ui.airEditable()\n        ])\n      ]) : ui.editor([\n        ui.toolbar(),\n        ui.editingArea([\n          ui.codable(),\n          ui.editable()\n        ]),\n        ui.statusbar()\n      ])).render();\n\n      $editor.insertAfter($note);\n\n      return {\n        note: $note,\n        editor: $editor,\n        toolbar: $editor.find('.note-toolbar'),\n        editingArea: $editor.find('.note-editing-area'),\n        editable: $editor.find('.note-editable'),\n        codable: $editor.find('.note-codable'),\n        statusbar: $editor.find('.note-statusbar')\n      };\n    },\n\n    removeLayout: function ($note, layoutInfo) {\n      $note.html(layoutInfo.editable.html());\n      layoutInfo.editor.remove();\n      $note.show();\n    }\n  };\n\n  $.summernote = $.summernote || {\n    lang: {}\n  };\n\n  $.extend($.summernote.lang, {\n    'en-US': {\n      font: {\n        bold: 'Bold',\n        italic: 'Italic',\n        underline: 'Underline',\n        clear: 'Remove Font Style',\n        height: 'Line Height',\n        name: 'Font Family',\n        strikethrough: 'Strikethrough',\n        subscript: 'Subscript',\n        superscript: 'Superscript',\n        size: 'Font Size'\n      },\n      image: {\n        image: 'Picture',\n        insert: 'Insert Image',\n        resizeFull: 'Resize Full',\n        resizeHalf: 'Resize Half',\n        resizeQuarter: 'Resize Quarter',\n        floatLeft: 'Float Left',\n        floatRight: 'Float Right',\n        floatNone: 'Float None',\n        shapeRounded: 'Shape: Rounded',\n        shapeCircle: 'Shape: Circle',\n        shapeThumbnail: 'Shape: Thumbnail',\n        shapeNone: 'Shape: None',\n        dragImageHere: 'Drag image or text here',\n        dropImage: 'Drop image or Text',\n        selectFromFiles: 'Select from files',\n        maximumFileSize: 'Maximum file size',\n        maximumFileSizeError: 'Maximum file size exceeded.',\n        url: 'Image URL',\n        remove: 'Remove Image'\n      },\n      video: {\n        video: 'Video',\n        videoLink: 'Video Link',\n        insert: 'Insert Video',\n        url: 'Video URL?',\n        providers: '(YouTube, Vimeo, Vine, Instagram, DailyMotion or Youku)'\n      },\n      link: {\n        link: 'Link',\n        insert: 'Insert Link',\n        unlink: 'Unlink',\n        edit: 'Edit',\n        textToDisplay: 'Text to display',\n        url: 'To what URL should this link go?',\n        openInNewWindow: 'Open in new window'\n      },\n      table: {\n        table: 'Table'\n      },\n      hr: {\n        insert: 'Insert Horizontal Rule'\n      },\n      style: {\n        style: 'Style',\n        normal: 'Normal',\n        blockquote: 'Quote',\n        pre: 'Code',\n        h1: 'Header 1',\n        h2: 'Header 2',\n        h3: 'Header 3',\n        h4: 'Header 4',\n        h5: 'Header 5',\n        h6: 'Header 6'\n      },\n      lists: {\n        unordered: 'Unordered list',\n        ordered: 'Ordered list'\n      },\n      options: {\n        help: 'Help',\n        fullscreen: 'Full Screen',\n        codeview: 'Code View'\n      },\n      paragraph: {\n        paragraph: 'Paragraph',\n        outdent: 'Outdent',\n        indent: 'Indent',\n        left: 'Align left',\n        center: 'Align center',\n        right: 'Align right',\n        justify: 'Justify full'\n      },\n      color: {\n        recent: 'Recent Color',\n        more: 'More Color',\n        background: 'Background Color',\n        foreground: 'Foreground Color',\n        transparent: 'Transparent',\n        setTransparent: 'Set transparent',\n        reset: 'Reset',\n        resetToDefault: 'Reset to default'\n      },\n      shortcut: {\n        shortcuts: 'Keyboard shortcuts',\n        close: 'Close',\n        textFormatting: 'Text formatting',\n        action: 'Action',\n        paragraphFormatting: 'Paragraph formatting',\n        documentStyle: 'Document Style',\n        extraKeys: 'Extra keys'\n      },\n      help: {\n        'insertParagraph': 'Insert Paragraph',\n        'undo': 'Undoes the last command',\n        'redo': 'Redoes the last command',\n        'tab': 'Tab',\n        'untab': 'Untab',\n        'bold': 'Set a bold style',\n        'italic': 'Set a italic style',\n        'underline': 'Set a underline style',\n        'strikethrough': 'Set a strikethrough style',\n        'removeFormat': 'Clean a style',\n        'justifyLeft': 'Set left align',\n        'justifyCenter': 'Set center align',\n        'justifyRight': 'Set right align',\n        'justifyFull': 'Set full align',\n        'insertUnorderedList': 'Toggle unordered list',\n        'insertOrderedList': 'Toggle ordered list',\n        'outdent': 'Outdent on current paragraph',\n        'indent': 'Indent on current paragraph',\n        'formatPara': 'Change current block\\'s format as a paragraph(P tag)',\n        'formatH1': 'Change current block\\'s format as H1',\n        'formatH2': 'Change current block\\'s format as H2',\n        'formatH3': 'Change current block\\'s format as H3',\n        'formatH4': 'Change current block\\'s format as H4',\n        'formatH5': 'Change current block\\'s format as H5',\n        'formatH6': 'Change current block\\'s format as H6',\n        'insertHorizontalRule': 'Insert horizontal rule',\n        'linkDialog.show': 'Show Link Dialog'\n      },\n      history: {\n        undo: 'Undo',\n        redo: 'Redo'\n      },\n      specialChar: {\n        specialChar: 'SPECIAL CHARACTERS',\n        select: 'Select Special characters'\n      }\n    }\n  });\n\n\n  /**\n   * @class core.key\n   *\n   * Object for keycodes.\n   *\n   * @singleton\n   * @alternateClassName key\n   */\n  var key = (function () {\n    var keyMap = {\n      'BACKSPACE': 8,\n      'TAB': 9,\n      'ENTER': 13,\n      'SPACE': 32,\n\n      // Arrow\n      'LEFT': 37,\n      'UP': 38,\n      'RIGHT': 39,\n      'DOWN': 40,\n\n      // Number: 0-9\n      'NUM0': 48,\n      'NUM1': 49,\n      'NUM2': 50,\n      'NUM3': 51,\n      'NUM4': 52,\n      'NUM5': 53,\n      'NUM6': 54,\n      'NUM7': 55,\n      'NUM8': 56,\n\n      // Alphabet: a-z\n      'B': 66,\n      'E': 69,\n      'I': 73,\n      'J': 74,\n      'K': 75,\n      'L': 76,\n      'R': 82,\n      'S': 83,\n      'U': 85,\n      'V': 86,\n      'Y': 89,\n      'Z': 90,\n\n      'SLASH': 191,\n      'LEFTBRACKET': 219,\n      'BACKSLASH': 220,\n      'RIGHTBRACKET': 221\n    };\n\n    return {\n      /**\n       * @method isEdit\n       *\n       * @param {Number} keyCode\n       * @return {Boolean}\n       */\n      isEdit: function (keyCode) {\n        return list.contains([\n          keyMap.BACKSPACE,\n          keyMap.TAB,\n          keyMap.ENTER,\n          keyMap.SPACE\n        ], keyCode);\n      },\n      /**\n       * @method isMove\n       *\n       * @param {Number} keyCode\n       * @return {Boolean}\n       */\n      isMove: function (keyCode) {\n        return list.contains([\n          keyMap.LEFT,\n          keyMap.UP,\n          keyMap.RIGHT,\n          keyMap.DOWN\n        ], keyCode);\n      },\n      /**\n       * @property {Object} nameFromCode\n       * @property {String} nameFromCode.8 \"BACKSPACE\"\n       */\n      nameFromCode: func.invertObject(keyMap),\n      code: keyMap\n    };\n  })();\n\n  var range = (function () {\n\n    /**\n     * return boundaryPoint from TextRange, inspired by Andy Na's HuskyRange.js\n     *\n     * @param {TextRange} textRange\n     * @param {Boolean} isStart\n     * @return {BoundaryPoint}\n     *\n     * @see http://msdn.microsoft.com/en-us/library/ie/ms535872(v=vs.85).aspx\n     */\n    var textRangeToPoint = function (textRange, isStart) {\n      var container = textRange.parentElement(), offset;\n  \n      var tester = document.body.createTextRange(), prevContainer;\n      var childNodes = list.from(container.childNodes);\n      for (offset = 0; offset < childNodes.length; offset++) {\n        if (dom.isText(childNodes[offset])) {\n          continue;\n        }\n        tester.moveToElementText(childNodes[offset]);\n        if (tester.compareEndPoints('StartToStart', textRange) >= 0) {\n          break;\n        }\n        prevContainer = childNodes[offset];\n      }\n  \n      if (offset !== 0 && dom.isText(childNodes[offset - 1])) {\n        var textRangeStart = document.body.createTextRange(), curTextNode = null;\n        textRangeStart.moveToElementText(prevContainer || container);\n        textRangeStart.collapse(!prevContainer);\n        curTextNode = prevContainer ? prevContainer.nextSibling : container.firstChild;\n  \n        var pointTester = textRange.duplicate();\n        pointTester.setEndPoint('StartToStart', textRangeStart);\n        var textCount = pointTester.text.replace(/[\\r\\n]/g, '').length;\n  \n        while (textCount > curTextNode.nodeValue.length && curTextNode.nextSibling) {\n          textCount -= curTextNode.nodeValue.length;\n          curTextNode = curTextNode.nextSibling;\n        }\n  \n        /* jshint ignore:start */\n        var dummy = curTextNode.nodeValue; // enforce IE to re-reference curTextNode, hack\n        /* jshint ignore:end */\n  \n        if (isStart && curTextNode.nextSibling && dom.isText(curTextNode.nextSibling) &&\n            textCount === curTextNode.nodeValue.length) {\n          textCount -= curTextNode.nodeValue.length;\n          curTextNode = curTextNode.nextSibling;\n        }\n  \n        container = curTextNode;\n        offset = textCount;\n      }\n  \n      return {\n        cont: container,\n        offset: offset\n      };\n    };\n    \n    /**\n     * return TextRange from boundary point (inspired by google closure-library)\n     * @param {BoundaryPoint} point\n     * @return {TextRange}\n     */\n    var pointToTextRange = function (point) {\n      var textRangeInfo = function (container, offset) {\n        var node, isCollapseToStart;\n  \n        if (dom.isText(container)) {\n          var prevTextNodes = dom.listPrev(container, func.not(dom.isText));\n          var prevContainer = list.last(prevTextNodes).previousSibling;\n          node =  prevContainer || container.parentNode;\n          offset += list.sum(list.tail(prevTextNodes), dom.nodeLength);\n          isCollapseToStart = !prevContainer;\n        } else {\n          node = container.childNodes[offset] || container;\n          if (dom.isText(node)) {\n            return textRangeInfo(node, 0);\n          }\n  \n          offset = 0;\n          isCollapseToStart = false;\n        }\n  \n        return {\n          node: node,\n          collapseToStart: isCollapseToStart,\n          offset: offset\n        };\n      };\n  \n      var textRange = document.body.createTextRange();\n      var info = textRangeInfo(point.node, point.offset);\n  \n      textRange.moveToElementText(info.node);\n      textRange.collapse(info.collapseToStart);\n      textRange.moveStart('character', info.offset);\n      return textRange;\n    };\n    \n    /**\n     * Wrapped Range\n     *\n     * @constructor\n     * @param {Node} sc - start container\n     * @param {Number} so - start offset\n     * @param {Node} ec - end container\n     * @param {Number} eo - end offset\n     */\n    var WrappedRange = function (sc, so, ec, eo) {\n      this.sc = sc;\n      this.so = so;\n      this.ec = ec;\n      this.eo = eo;\n  \n      // nativeRange: get nativeRange from sc, so, ec, eo\n      var nativeRange = function () {\n        if (agent.isW3CRangeSupport) {\n          var w3cRange = document.createRange();\n          w3cRange.setStart(sc, so);\n          w3cRange.setEnd(ec, eo);\n\n          return w3cRange;\n        } else {\n          var textRange = pointToTextRange({\n            node: sc,\n            offset: so\n          });\n\n          textRange.setEndPoint('EndToEnd', pointToTextRange({\n            node: ec,\n            offset: eo\n          }));\n\n          return textRange;\n        }\n      };\n\n      this.getPoints = function () {\n        return {\n          sc: sc,\n          so: so,\n          ec: ec,\n          eo: eo\n        };\n      };\n\n      this.getStartPoint = function () {\n        return {\n          node: sc,\n          offset: so\n        };\n      };\n\n      this.getEndPoint = function () {\n        return {\n          node: ec,\n          offset: eo\n        };\n      };\n\n      /**\n       * select update visible range\n       */\n      this.select = function () {\n        var nativeRng = nativeRange();\n        if (agent.isW3CRangeSupport) {\n          var selection = document.getSelection();\n          if (selection.rangeCount > 0) {\n            selection.removeAllRanges();\n          }\n          selection.addRange(nativeRng);\n        } else {\n          nativeRng.select();\n        }\n        \n        return this;\n      };\n\n      /**\n       * Moves the scrollbar to start container(sc) of current range\n       *\n       * @return {WrappedRange}\n       */\n      this.scrollIntoView = function (container) {\n        var height = $(container).height();\n        if (container.scrollTop + height < this.sc.offsetTop) {\n          container.scrollTop += Math.abs(container.scrollTop + height - this.sc.offsetTop);\n        }\n\n        return this;\n      };\n\n      /**\n       * @return {WrappedRange}\n       */\n      this.normalize = function () {\n\n        /**\n         * @param {BoundaryPoint} point\n         * @param {Boolean} isLeftToRight\n         * @return {BoundaryPoint}\n         */\n        var getVisiblePoint = function (point, isLeftToRight) {\n          if ((dom.isVisiblePoint(point) && !dom.isEdgePoint(point)) ||\n              (dom.isVisiblePoint(point) && dom.isRightEdgePoint(point) && !isLeftToRight) ||\n              (dom.isVisiblePoint(point) && dom.isLeftEdgePoint(point) && isLeftToRight) ||\n              (dom.isVisiblePoint(point) && dom.isBlock(point.node) && dom.isEmpty(point.node))) {\n            return point;\n          }\n\n          // point on block's edge\n          var block = dom.ancestor(point.node, dom.isBlock);\n          if (((dom.isLeftEdgePointOf(point, block) || dom.isVoid(dom.prevPoint(point).node)) && !isLeftToRight) ||\n              ((dom.isRightEdgePointOf(point, block) || dom.isVoid(dom.nextPoint(point).node)) && isLeftToRight)) {\n\n            // returns point already on visible point\n            if (dom.isVisiblePoint(point)) {\n              return point;\n            }\n            // reverse direction \n            isLeftToRight = !isLeftToRight;\n          }\n\n          var nextPoint = isLeftToRight ? dom.nextPointUntil(dom.nextPoint(point), dom.isVisiblePoint) :\n                                          dom.prevPointUntil(dom.prevPoint(point), dom.isVisiblePoint);\n          return nextPoint || point;\n        };\n\n        var endPoint = getVisiblePoint(this.getEndPoint(), false);\n        var startPoint = this.isCollapsed() ? endPoint : getVisiblePoint(this.getStartPoint(), true);\n\n        return new WrappedRange(\n          startPoint.node,\n          startPoint.offset,\n          endPoint.node,\n          endPoint.offset\n        );\n      };\n\n      /**\n       * returns matched nodes on range\n       *\n       * @param {Function} [pred] - predicate function\n       * @param {Object} [options]\n       * @param {Boolean} [options.includeAncestor]\n       * @param {Boolean} [options.fullyContains]\n       * @return {Node[]}\n       */\n      this.nodes = function (pred, options) {\n        pred = pred || func.ok;\n\n        var includeAncestor = options && options.includeAncestor;\n        var fullyContains = options && options.fullyContains;\n\n        // TODO compare points and sort\n        var startPoint = this.getStartPoint();\n        var endPoint = this.getEndPoint();\n\n        var nodes = [];\n        var leftEdgeNodes = [];\n\n        dom.walkPoint(startPoint, endPoint, function (point) {\n          if (dom.isEditable(point.node)) {\n            return;\n          }\n\n          var node;\n          if (fullyContains) {\n            if (dom.isLeftEdgePoint(point)) {\n              leftEdgeNodes.push(point.node);\n            }\n            if (dom.isRightEdgePoint(point) && list.contains(leftEdgeNodes, point.node)) {\n              node = point.node;\n            }\n          } else if (includeAncestor) {\n            node = dom.ancestor(point.node, pred);\n          } else {\n            node = point.node;\n          }\n\n          if (node && pred(node)) {\n            nodes.push(node);\n          }\n        }, true);\n\n        return list.unique(nodes);\n      };\n\n      /**\n       * returns commonAncestor of range\n       * @return {Element} - commonAncestor\n       */\n      this.commonAncestor = function () {\n        return dom.commonAncestor(sc, ec);\n      };\n\n      /**\n       * returns expanded range by pred\n       *\n       * @param {Function} pred - predicate function\n       * @return {WrappedRange}\n       */\n      this.expand = function (pred) {\n        var startAncestor = dom.ancestor(sc, pred);\n        var endAncestor = dom.ancestor(ec, pred);\n\n        if (!startAncestor && !endAncestor) {\n          return new WrappedRange(sc, so, ec, eo);\n        }\n\n        var boundaryPoints = this.getPoints();\n\n        if (startAncestor) {\n          boundaryPoints.sc = startAncestor;\n          boundaryPoints.so = 0;\n        }\n\n        if (endAncestor) {\n          boundaryPoints.ec = endAncestor;\n          boundaryPoints.eo = dom.nodeLength(endAncestor);\n        }\n\n        return new WrappedRange(\n          boundaryPoints.sc,\n          boundaryPoints.so,\n          boundaryPoints.ec,\n          boundaryPoints.eo\n        );\n      };\n\n      /**\n       * @param {Boolean} isCollapseToStart\n       * @return {WrappedRange}\n       */\n      this.collapse = function (isCollapseToStart) {\n        if (isCollapseToStart) {\n          return new WrappedRange(sc, so, sc, so);\n        } else {\n          return new WrappedRange(ec, eo, ec, eo);\n        }\n      };\n\n      /**\n       * splitText on range\n       */\n      this.splitText = function () {\n        var isSameContainer = sc === ec;\n        var boundaryPoints = this.getPoints();\n\n        if (dom.isText(ec) && !dom.isEdgePoint(this.getEndPoint())) {\n          ec.splitText(eo);\n        }\n\n        if (dom.isText(sc) && !dom.isEdgePoint(this.getStartPoint())) {\n          boundaryPoints.sc = sc.splitText(so);\n          boundaryPoints.so = 0;\n\n          if (isSameContainer) {\n            boundaryPoints.ec = boundaryPoints.sc;\n            boundaryPoints.eo = eo - so;\n          }\n        }\n\n        return new WrappedRange(\n          boundaryPoints.sc,\n          boundaryPoints.so,\n          boundaryPoints.ec,\n          boundaryPoints.eo\n        );\n      };\n\n      /**\n       * delete contents on range\n       * @return {WrappedRange}\n       */\n      this.deleteContents = function () {\n        if (this.isCollapsed()) {\n          return this;\n        }\n\n        var rng = this.splitText();\n        var nodes = rng.nodes(null, {\n          fullyContains: true\n        });\n\n        // find new cursor point\n        var point = dom.prevPointUntil(rng.getStartPoint(), function (point) {\n          return !list.contains(nodes, point.node);\n        });\n\n        var emptyParents = [];\n        $.each(nodes, function (idx, node) {\n          // find empty parents\n          var parent = node.parentNode;\n          if (point.node !== parent && dom.nodeLength(parent) === 1) {\n            emptyParents.push(parent);\n          }\n          dom.remove(node, false);\n        });\n\n        // remove empty parents\n        $.each(emptyParents, function (idx, node) {\n          dom.remove(node, false);\n        });\n\n        return new WrappedRange(\n          point.node,\n          point.offset,\n          point.node,\n          point.offset\n        ).normalize();\n      };\n      \n      /**\n       * makeIsOn: return isOn(pred) function\n       */\n      var makeIsOn = function (pred) {\n        return function () {\n          var ancestor = dom.ancestor(sc, pred);\n          return !!ancestor && (ancestor === dom.ancestor(ec, pred));\n        };\n      };\n  \n      // isOnEditable: judge whether range is on editable or not\n      this.isOnEditable = makeIsOn(dom.isEditable);\n      // isOnList: judge whether range is on list node or not\n      this.isOnList = makeIsOn(dom.isList);\n      // isOnAnchor: judge whether range is on anchor node or not\n      this.isOnAnchor = makeIsOn(dom.isAnchor);\n      // isOnAnchor: judge whether range is on cell node or not\n      this.isOnCell = makeIsOn(dom.isCell);\n\n      /**\n       * @param {Function} pred\n       * @return {Boolean}\n       */\n      this.isLeftEdgeOf = function (pred) {\n        if (!dom.isLeftEdgePoint(this.getStartPoint())) {\n          return false;\n        }\n\n        var node = dom.ancestor(this.sc, pred);\n        return node && dom.isLeftEdgeOf(this.sc, node);\n      };\n\n      /**\n       * returns whether range was collapsed or not\n       */\n      this.isCollapsed = function () {\n        return sc === ec && so === eo;\n      };\n\n      /**\n       * wrap inline nodes which children of body with paragraph\n       *\n       * @return {WrappedRange}\n       */\n      this.wrapBodyInlineWithPara = function () {\n        if (dom.isBodyContainer(sc) && dom.isEmpty(sc)) {\n          sc.innerHTML = dom.emptyPara;\n          return new WrappedRange(sc.firstChild, 0, sc.firstChild, 0);\n        }\n\n        /**\n         * [workaround] firefox often create range on not visible point. so normalize here.\n         *  - firefox: |<p>text</p>|\n         *  - chrome: <p>|text|</p>\n         */\n        var rng = this.normalize();\n        if (dom.isParaInline(sc) || dom.isPara(sc)) {\n          return rng;\n        }\n\n        // find inline top ancestor\n        var topAncestor;\n        if (dom.isInline(rng.sc)) {\n          var ancestors = dom.listAncestor(rng.sc, func.not(dom.isInline));\n          topAncestor = list.last(ancestors);\n          if (!dom.isInline(topAncestor)) {\n            topAncestor = ancestors[ancestors.length - 2] || rng.sc.childNodes[rng.so];\n          }\n        } else {\n          topAncestor = rng.sc.childNodes[rng.so > 0 ? rng.so - 1 : 0];\n        }\n\n        // siblings not in paragraph\n        var inlineSiblings = dom.listPrev(topAncestor, dom.isParaInline).reverse();\n        inlineSiblings = inlineSiblings.concat(dom.listNext(topAncestor.nextSibling, dom.isParaInline));\n\n        // wrap with paragraph\n        if (inlineSiblings.length) {\n          var para = dom.wrap(list.head(inlineSiblings), 'p');\n          dom.appendChildNodes(para, list.tail(inlineSiblings));\n        }\n\n        return this.normalize();\n      };\n\n      /**\n       * insert node at current cursor\n       *\n       * @param {Node} node\n       * @return {Node}\n       */\n      this.insertNode = function (node) {\n        var rng = this.wrapBodyInlineWithPara().deleteContents();\n        var info = dom.splitPoint(rng.getStartPoint(), dom.isInline(node));\n\n        if (info.rightNode) {\n          info.rightNode.parentNode.insertBefore(node, info.rightNode);\n        } else {\n          info.container.appendChild(node);\n        }\n\n        return node;\n      };\n\n      /**\n       * insert html at current cursor\n       */\n      this.pasteHTML = function (markup) {\n        var contentsContainer = $('<div></div>').html(markup)[0];\n        var childNodes = list.from(contentsContainer.childNodes);\n\n        var rng = this.wrapBodyInlineWithPara().deleteContents();\n\n        return childNodes.reverse().map(function (childNode) {\n          return rng.insertNode(childNode);\n        }).reverse();\n      };\n  \n      /**\n       * returns text in range\n       *\n       * @return {String}\n       */\n      this.toString = function () {\n        var nativeRng = nativeRange();\n        return agent.isW3CRangeSupport ? nativeRng.toString() : nativeRng.text;\n      };\n\n      /**\n       * returns range for word before cursor\n       *\n       * @param {Boolean} [findAfter] - find after cursor, default: false\n       * @return {WrappedRange}\n       */\n      this.getWordRange = function (findAfter) {\n        var endPoint = this.getEndPoint();\n\n        if (!dom.isCharPoint(endPoint)) {\n          return this;\n        }\n\n        var startPoint = dom.prevPointUntil(endPoint, function (point) {\n          return !dom.isCharPoint(point);\n        });\n\n        if (findAfter) {\n          endPoint = dom.nextPointUntil(endPoint, function (point) {\n            return !dom.isCharPoint(point);\n          });\n        }\n\n        return new WrappedRange(\n          startPoint.node,\n          startPoint.offset,\n          endPoint.node,\n          endPoint.offset\n        );\n      };\n  \n      /**\n       * create offsetPath bookmark\n       *\n       * @param {Node} editable\n       */\n      this.bookmark = function (editable) {\n        return {\n          s: {\n            path: dom.makeOffsetPath(editable, sc),\n            offset: so\n          },\n          e: {\n            path: dom.makeOffsetPath(editable, ec),\n            offset: eo\n          }\n        };\n      };\n\n      /**\n       * create offsetPath bookmark base on paragraph\n       *\n       * @param {Node[]} paras\n       */\n      this.paraBookmark = function (paras) {\n        return {\n          s: {\n            path: list.tail(dom.makeOffsetPath(list.head(paras), sc)),\n            offset: so\n          },\n          e: {\n            path: list.tail(dom.makeOffsetPath(list.last(paras), ec)),\n            offset: eo\n          }\n        };\n      };\n\n      /**\n       * getClientRects\n       * @return {Rect[]}\n       */\n      this.getClientRects = function () {\n        var nativeRng = nativeRange();\n        return nativeRng.getClientRects();\n      };\n    };\n\n  /**\n   * @class core.range\n   *\n   * Data structure\n   *  * BoundaryPoint: a point of dom tree\n   *  * BoundaryPoints: two boundaryPoints corresponding to the start and the end of the Range\n   *\n   * See to http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Position\n   *\n   * @singleton\n   * @alternateClassName range\n   */\n    return {\n      /**\n       * create Range Object From arguments or Browser Selection\n       *\n       * @param {Node} sc - start container\n       * @param {Number} so - start offset\n       * @param {Node} ec - end container\n       * @param {Number} eo - end offset\n       * @return {WrappedRange}\n       */\n      create: function (sc, so, ec, eo) {\n        if (arguments.length === 4) {\n          return new WrappedRange(sc, so, ec, eo);\n        } else if (arguments.length === 2) { //collapsed\n          ec = sc;\n          eo = so;\n          return new WrappedRange(sc, so, ec, eo);\n        } else {\n          var wrappedRange = this.createFromSelection();\n          if (!wrappedRange && arguments.length === 1) {\n            wrappedRange = this.createFromNode(arguments[0]);\n            return wrappedRange.collapse(dom.emptyPara === arguments[0].innerHTML);\n          }\n          return wrappedRange;\n        }\n      },\n\n      createFromSelection: function () {\n        var sc, so, ec, eo;\n        if (agent.isW3CRangeSupport) {\n          var selection = document.getSelection();\n          if (!selection || selection.rangeCount === 0) {\n            return null;\n          } else if (dom.isBody(selection.anchorNode)) {\n            // Firefox: returns entire body as range on initialization.\n            // We won't never need it.\n            return null;\n          }\n\n          var nativeRng = selection.getRangeAt(0);\n          sc = nativeRng.startContainer;\n          so = nativeRng.startOffset;\n          ec = nativeRng.endContainer;\n          eo = nativeRng.endOffset;\n        } else { // IE8: TextRange\n          var textRange = document.selection.createRange();\n          var textRangeEnd = textRange.duplicate();\n          textRangeEnd.collapse(false);\n          var textRangeStart = textRange;\n          textRangeStart.collapse(true);\n\n          var startPoint = textRangeToPoint(textRangeStart, true),\n          endPoint = textRangeToPoint(textRangeEnd, false);\n\n          // same visible point case: range was collapsed.\n          if (dom.isText(startPoint.node) && dom.isLeftEdgePoint(startPoint) &&\n              dom.isTextNode(endPoint.node) && dom.isRightEdgePoint(endPoint) &&\n              endPoint.node.nextSibling === startPoint.node) {\n            startPoint = endPoint;\n          }\n\n          sc = startPoint.cont;\n          so = startPoint.offset;\n          ec = endPoint.cont;\n          eo = endPoint.offset;\n        }\n\n        return new WrappedRange(sc, so, ec, eo);\n      },\n\n      /**\n       * @method \n       * \n       * create WrappedRange from node\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNode: function (node) {\n        var sc = node;\n        var so = 0;\n        var ec = node;\n        var eo = dom.nodeLength(ec);\n\n        // browsers can't target a picture or void node\n        if (dom.isVoid(sc)) {\n          so = dom.listPrev(sc).length - 1;\n          sc = sc.parentNode;\n        }\n        if (dom.isBR(ec)) {\n          eo = dom.listPrev(ec).length - 1;\n          ec = ec.parentNode;\n        } else if (dom.isVoid(ec)) {\n          eo = dom.listPrev(ec).length;\n          ec = ec.parentNode;\n        }\n\n        return this.create(sc, so, ec, eo);\n      },\n\n      /**\n       * create WrappedRange from node after position\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNodeBefore: function (node) {\n        return this.createFromNode(node).collapse(true);\n      },\n\n      /**\n       * create WrappedRange from node after position\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNodeAfter: function (node) {\n        return this.createFromNode(node).collapse();\n      },\n\n      /**\n       * @method \n       * \n       * create WrappedRange from bookmark\n       *\n       * @param {Node} editable\n       * @param {Object} bookmark\n       * @return {WrappedRange}\n       */\n      createFromBookmark: function (editable, bookmark) {\n        var sc = dom.fromOffsetPath(editable, bookmark.s.path);\n        var so = bookmark.s.offset;\n        var ec = dom.fromOffsetPath(editable, bookmark.e.path);\n        var eo = bookmark.e.offset;\n        return new WrappedRange(sc, so, ec, eo);\n      },\n\n      /**\n       * @method \n       *\n       * create WrappedRange from paraBookmark\n       *\n       * @param {Object} bookmark\n       * @param {Node[]} paras\n       * @return {WrappedRange}\n       */\n      createFromParaBookmark: function (bookmark, paras) {\n        var so = bookmark.s.offset;\n        var eo = bookmark.e.offset;\n        var sc = dom.fromOffsetPath(list.head(paras), bookmark.s.path);\n        var ec = dom.fromOffsetPath(list.last(paras), bookmark.e.path);\n\n        return new WrappedRange(sc, so, ec, eo);\n      }\n    };\n  })();\n\n  /**\n   * @class core.async\n   *\n   * Async functions which returns `Promise`\n   *\n   * @singleton\n   * @alternateClassName async\n   */\n  var async = (function () {\n    /**\n     * @method readFileAsDataURL\n     *\n     * read contents of file as representing URL\n     *\n     * @param {File} file\n     * @return {Promise} - then: dataUrl\n     */\n    var readFileAsDataURL = function (file) {\n      return $.Deferred(function (deferred) {\n        $.extend(new FileReader(), {\n          onload: function (e) {\n            var dataURL = e.target.result;\n            deferred.resolve(dataURL);\n          },\n          onerror: function () {\n            deferred.reject(this);\n          }\n        }).readAsDataURL(file);\n      }).promise();\n    };\n  \n    /**\n     * @method createImage\n     *\n     * create `<image>` from url string\n     *\n     * @param {String} url\n     * @return {Promise} - then: $image\n     */\n    var createImage = function (url) {\n      return $.Deferred(function (deferred) {\n        var $img = $('<img>');\n\n        $img.one('load', function () {\n          $img.off('error abort');\n          deferred.resolve($img);\n        }).one('error abort', function () {\n          $img.off('load').detach();\n          deferred.reject($img);\n        }).css({\n          display: 'none'\n        }).appendTo(document.body).attr('src', url);\n      }).promise();\n    };\n\n    return {\n      readFileAsDataURL: readFileAsDataURL,\n      createImage: createImage\n    };\n  })();\n\n  /**\n   * @class editing.History\n   *\n   * Editor History\n   *\n   */\n  var History = function ($editable) {\n    var stack = [], stackOffset = -1;\n    var editable = $editable[0];\n\n    var makeSnapshot = function () {\n      var rng = range.create(editable);\n      var emptyBookmark = {s: {path: [], offset: 0}, e: {path: [], offset: 0}};\n\n      return {\n        contents: $editable.html(),\n        bookmark: (rng ? rng.bookmark(editable) : emptyBookmark)\n      };\n    };\n\n    var applySnapshot = function (snapshot) {\n      if (snapshot.contents !== null) {\n        $editable.html(snapshot.contents);\n      }\n      if (snapshot.bookmark !== null) {\n        range.createFromBookmark(editable, snapshot.bookmark).select();\n      }\n    };\n\n    /**\n    * @method rewind\n    * Rewinds the history stack back to the first snapshot taken.\n    * Leaves the stack intact, so that \"Redo\" can still be used.\n    */\n    this.rewind = function () {\n      // Create snap shot if not yet recorded\n      if ($editable.html() !== stack[stackOffset].contents) {\n        this.recordUndo();\n      }\n\n      // Return to the first available snapshot.\n      stackOffset = 0;\n\n      // Apply that snapshot.\n      applySnapshot(stack[stackOffset]);\n    };\n\n    /**\n    * @method reset\n    * Resets the history stack completely; reverting to an empty editor.\n    */\n    this.reset = function () {\n      // Clear the stack.\n      stack = [];\n\n      // Restore stackOffset to its original value.\n      stackOffset = -1;\n\n      // Clear the editable area.\n      $editable.html('');\n\n      // Record our first snapshot (of nothing).\n      this.recordUndo();\n    };\n\n    /**\n     * undo\n     */\n    this.undo = function () {\n      // Create snap shot if not yet recorded\n      if ($editable.html() !== stack[stackOffset].contents) {\n        this.recordUndo();\n      }\n\n      if (0 < stackOffset) {\n        stackOffset--;\n        applySnapshot(stack[stackOffset]);\n      }\n    };\n\n    /**\n     * redo\n     */\n    this.redo = function () {\n      if (stack.length - 1 > stackOffset) {\n        stackOffset++;\n        applySnapshot(stack[stackOffset]);\n      }\n    };\n\n    /**\n     * recorded undo\n     */\n    this.recordUndo = function () {\n      stackOffset++;\n\n      // Wash out stack after stackOffset\n      if (stack.length > stackOffset) {\n        stack = stack.slice(0, stackOffset);\n      }\n\n      // Create new snapshot and push it to the end\n      stack.push(makeSnapshot());\n    };\n  };\n\n  /**\n   * @class editing.Style\n   *\n   * Style\n   *\n   */\n  var Style = function () {\n    /**\n     * @method jQueryCSS\n     *\n     * [workaround] for old jQuery\n     * passing an array of style properties to .css()\n     * will result in an object of property-value pairs.\n     * (compability with version < 1.9)\n     *\n     * @private\n     * @param  {jQuery} $obj\n     * @param  {Array} propertyNames - An array of one or more CSS properties.\n     * @return {Object}\n     */\n    var jQueryCSS = function ($obj, propertyNames) {\n      if (agent.jqueryVersion < 1.9) {\n        var result = {};\n        $.each(propertyNames, function (idx, propertyName) {\n          result[propertyName] = $obj.css(propertyName);\n        });\n        return result;\n      }\n      return $obj.css.call($obj, propertyNames);\n    };\n\n    /**\n     * returns style object from node\n     *\n     * @param {jQuery} $node\n     * @return {Object}\n     */\n    this.fromNode = function ($node) {\n      var properties = ['font-family', 'font-size', 'text-align', 'list-style-type', 'line-height'];\n      var styleInfo = jQueryCSS($node, properties) || {};\n      styleInfo['font-size'] = parseInt(styleInfo['font-size'], 10);\n      return styleInfo;\n    };\n\n    /**\n     * paragraph level style\n     *\n     * @param {WrappedRange} rng\n     * @param {Object} styleInfo\n     */\n    this.stylePara = function (rng, styleInfo) {\n      $.each(rng.nodes(dom.isPara, {\n        includeAncestor: true\n      }), function (idx, para) {\n        $(para).css(styleInfo);\n      });\n    };\n\n    /**\n     * insert and returns styleNodes on range.\n     *\n     * @param {WrappedRange} rng\n     * @param {Object} [options] - options for styleNodes\n     * @param {String} [options.nodeName] - default: `SPAN`\n     * @param {Boolean} [options.expandClosestSibling] - default: `false`\n     * @param {Boolean} [options.onlyPartialContains] - default: `false`\n     * @return {Node[]}\n     */\n    this.styleNodes = function (rng, options) {\n      rng = rng.splitText();\n\n      var nodeName = options && options.nodeName || 'SPAN';\n      var expandClosestSibling = !!(options && options.expandClosestSibling);\n      var onlyPartialContains = !!(options && options.onlyPartialContains);\n\n      if (rng.isCollapsed()) {\n        return [rng.insertNode(dom.create(nodeName))];\n      }\n\n      var pred = dom.makePredByNodeName(nodeName);\n      var nodes = rng.nodes(dom.isText, {\n        fullyContains: true\n      }).map(function (text) {\n        return dom.singleChildAncestor(text, pred) || dom.wrap(text, nodeName);\n      });\n\n      if (expandClosestSibling) {\n        if (onlyPartialContains) {\n          var nodesInRange = rng.nodes();\n          // compose with partial contains predication\n          pred = func.and(pred, function (node) {\n            return list.contains(nodesInRange, node);\n          });\n        }\n\n        return nodes.map(function (node) {\n          var siblings = dom.withClosestSiblings(node, pred);\n          var head = list.head(siblings);\n          var tails = list.tail(siblings);\n          $.each(tails, function (idx, elem) {\n            dom.appendChildNodes(head, elem.childNodes);\n            dom.remove(elem);\n          });\n          return list.head(siblings);\n        });\n      } else {\n        return nodes;\n      }\n    };\n\n    /**\n     * get current style on cursor\n     *\n     * @param {WrappedRange} rng\n     * @return {Object} - object contains style properties.\n     */\n    this.current = function (rng) {\n      var $cont = $(!dom.isElement(rng.sc) ? rng.sc.parentNode : rng.sc);\n      var styleInfo = this.fromNode($cont);\n\n      // document.queryCommandState for toggle state\n      // [workaround] prevent Firefox nsresult: \"0x80004005 (NS_ERROR_FAILURE)\"\n      try {\n        styleInfo = $.extend(styleInfo, {\n          'font-bold': document.queryCommandState('bold') ? 'bold' : 'normal',\n          'font-italic': document.queryCommandState('italic') ? 'italic' : 'normal',\n          'font-underline': document.queryCommandState('underline') ? 'underline' : 'normal',\n          'font-subscript': document.queryCommandState('subscript') ? 'subscript' : 'normal',\n          'font-superscript': document.queryCommandState('superscript') ? 'superscript' : 'normal',\n          'font-strikethrough': document.queryCommandState('strikethrough') ? 'strikethrough' : 'normal'\n        });\n      } catch (e) {}\n\n      // list-style-type to list-style(unordered, ordered)\n      if (!rng.isOnList()) {\n        styleInfo['list-style'] = 'none';\n      } else {\n        var orderedTypes = ['circle', 'disc', 'disc-leading-zero', 'square'];\n        var isUnordered = $.inArray(styleInfo['list-style-type'], orderedTypes) > -1;\n        styleInfo['list-style'] = isUnordered ? 'unordered' : 'ordered';\n      }\n\n      var para = dom.ancestor(rng.sc, dom.isPara);\n      if (para && para.style['line-height']) {\n        styleInfo['line-height'] = para.style.lineHeight;\n      } else {\n        var lineHeight = parseInt(styleInfo['line-height'], 10) / parseInt(styleInfo['font-size'], 10);\n        styleInfo['line-height'] = lineHeight.toFixed(1);\n      }\n\n      styleInfo.anchor = rng.isOnAnchor() && dom.ancestor(rng.sc, dom.isAnchor);\n      styleInfo.ancestors = dom.listAncestor(rng.sc, dom.isEditable);\n      styleInfo.range = rng;\n\n      return styleInfo;\n    };\n  };\n\n\n  /**\n   * @class editing.Bullet\n   *\n   * @alternateClassName Bullet\n   */\n  var Bullet = function () {\n    var self = this;\n\n    /**\n     * toggle ordered list\n     */\n    this.insertOrderedList = function (editable) {\n      this.toggleList('OL', editable);\n    };\n\n    /**\n     * toggle unordered list\n     */\n    this.insertUnorderedList = function (editable) {\n      this.toggleList('UL', editable);\n    };\n\n    /**\n     * indent\n     */\n    this.indent = function (editable) {\n      var self = this;\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        if (dom.isLi(head)) {\n          self.wrapList(paras, head.parentNode.nodeName);\n        } else {\n          $.each(paras, function (idx, para) {\n            $(para).css('marginLeft', function (idx, val) {\n              return (parseInt(val, 10) || 0) + 25;\n            });\n          });\n        }\n      });\n\n      rng.select();\n    };\n\n    /**\n     * outdent\n     */\n    this.outdent = function (editable) {\n      var self = this;\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        if (dom.isLi(head)) {\n          self.releaseList([paras]);\n        } else {\n          $.each(paras, function (idx, para) {\n            $(para).css('marginLeft', function (idx, val) {\n              val = (parseInt(val, 10) || 0);\n              return val > 25 ? val - 25 : '';\n            });\n          });\n        }\n      });\n\n      rng.select();\n    };\n\n    /**\n     * toggle list\n     *\n     * @param {String} listName - OL or UL\n     */\n    this.toggleList = function (listName, editable) {\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var bookmark = rng.paraBookmark(paras);\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      // paragraph to list\n      if (list.find(paras, dom.isPurePara)) {\n        var wrappedParas = [];\n        $.each(clustereds, function (idx, paras) {\n          wrappedParas = wrappedParas.concat(self.wrapList(paras, listName));\n        });\n        paras = wrappedParas;\n      // list to paragraph or change list style\n      } else {\n        var diffLists = rng.nodes(dom.isList, {\n          includeAncestor: true\n        }).filter(function (listNode) {\n          return !$.nodeName(listNode, listName);\n        });\n\n        if (diffLists.length) {\n          $.each(diffLists, function (idx, listNode) {\n            dom.replace(listNode, listName);\n          });\n        } else {\n          paras = this.releaseList(clustereds, true);\n        }\n      }\n\n      range.createFromParaBookmark(bookmark, paras).select();\n    };\n\n    /**\n     * @param {Node[]} paras\n     * @param {String} listName\n     * @return {Node[]}\n     */\n    this.wrapList = function (paras, listName) {\n      var head = list.head(paras);\n      var last = list.last(paras);\n\n      var prevList = dom.isList(head.previousSibling) && head.previousSibling;\n      var nextList = dom.isList(last.nextSibling) && last.nextSibling;\n\n      var listNode = prevList || dom.insertAfter(dom.create(listName || 'UL'), last);\n\n      // P to LI\n      paras = paras.map(function (para) {\n        return dom.isPurePara(para) ? dom.replace(para, 'LI') : para;\n      });\n\n      // append to list(<ul>, <ol>)\n      dom.appendChildNodes(listNode, paras);\n\n      if (nextList) {\n        dom.appendChildNodes(listNode, list.from(nextList.childNodes));\n        dom.remove(nextList);\n      }\n\n      return paras;\n    };\n\n    /**\n     * @method releaseList\n     *\n     * @param {Array[]} clustereds\n     * @param {Boolean} isEscapseToBody\n     * @return {Node[]}\n     */\n    this.releaseList = function (clustereds, isEscapseToBody) {\n      var releasedParas = [];\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        var last = list.last(paras);\n\n        var headList = isEscapseToBody ? dom.lastAncestor(head, dom.isList) :\n                                         head.parentNode;\n        var lastList = headList.childNodes.length > 1 ? dom.splitTree(headList, {\n          node: last.parentNode,\n          offset: dom.position(last) + 1\n        }, {\n          isSkipPaddingBlankHTML: true\n        }) : null;\n\n        var middleList = dom.splitTree(headList, {\n          node: head.parentNode,\n          offset: dom.position(head)\n        }, {\n          isSkipPaddingBlankHTML: true\n        });\n\n        paras = isEscapseToBody ? dom.listDescendant(middleList, dom.isLi) :\n                                  list.from(middleList.childNodes).filter(dom.isLi);\n\n        // LI to P\n        if (isEscapseToBody || !dom.isList(headList.parentNode)) {\n          paras = paras.map(function (para) {\n            return dom.replace(para, 'P');\n          });\n        }\n\n        $.each(list.from(paras).reverse(), function (idx, para) {\n          dom.insertAfter(para, headList);\n        });\n\n        // remove empty lists\n        var rootLists = list.compact([headList, middleList, lastList]);\n        $.each(rootLists, function (idx, rootList) {\n          var listNodes = [rootList].concat(dom.listDescendant(rootList, dom.isList));\n          $.each(listNodes.reverse(), function (idx, listNode) {\n            if (!dom.nodeLength(listNode)) {\n              dom.remove(listNode, true);\n            }\n          });\n        });\n\n        releasedParas = releasedParas.concat(paras);\n      });\n\n      return releasedParas;\n    };\n  };\n\n\n  /**\n   * @class editing.Typing\n   *\n   * Typing\n   *\n   */\n  var Typing = function () {\n\n    // a Bullet instance to toggle lists off\n    var bullet = new Bullet();\n\n    /**\n     * insert tab\n     *\n     * @param {WrappedRange} rng\n     * @param {Number} tabsize\n     */\n    this.insertTab = function (rng, tabsize) {\n      var tab = dom.createText(new Array(tabsize + 1).join(dom.NBSP_CHAR));\n      rng = rng.deleteContents();\n      rng.insertNode(tab, true);\n\n      rng = range.create(tab, tabsize);\n      rng.select();\n    };\n\n    /**\n     * insert paragraph\n     */\n    this.insertParagraph = function (editable) {\n      var rng = range.create(editable);\n\n      // deleteContents on range.\n      rng = rng.deleteContents();\n\n      // Wrap range if it needs to be wrapped by paragraph\n      rng = rng.wrapBodyInlineWithPara();\n\n      // finding paragraph\n      var splitRoot = dom.ancestor(rng.sc, dom.isPara);\n\n      var nextPara;\n      // on paragraph: split paragraph\n      if (splitRoot) {\n        // if it is an empty line with li\n        if (dom.isEmpty(splitRoot) && dom.isLi(splitRoot)) {\n          // toogle UL/OL and escape\n          bullet.toggleList(splitRoot.parentNode.nodeName);\n          return;\n        // if it is an empty line with para on blockquote\n        } else if (dom.isEmpty(splitRoot) && dom.isPara(splitRoot) && dom.isBlockquote(splitRoot.parentNode)) {\n          // escape blockquote\n          dom.insertAfter(splitRoot, splitRoot.parentNode);\n          nextPara = splitRoot;\n        // if new line has content (not a line break)\n        } else {\n          nextPara = dom.splitTree(splitRoot, rng.getStartPoint());\n\n          var emptyAnchors = dom.listDescendant(splitRoot, dom.isEmptyAnchor);\n          emptyAnchors = emptyAnchors.concat(dom.listDescendant(nextPara, dom.isEmptyAnchor));\n\n          $.each(emptyAnchors, function (idx, anchor) {\n            dom.remove(anchor);\n          });\n\n          // replace empty heading or pre with P tag\n          if ((dom.isHeading(nextPara) || dom.isPre(nextPara)) && dom.isEmpty(nextPara)) {\n            nextPara = dom.replace(nextPara, 'p');\n          }\n        }\n      // no paragraph: insert empty paragraph\n      } else {\n        var next = rng.sc.childNodes[rng.so];\n        nextPara = $(dom.emptyPara)[0];\n        if (next) {\n          rng.sc.insertBefore(nextPara, next);\n        } else {\n          rng.sc.appendChild(nextPara);\n        }\n      }\n\n      range.create(nextPara, 0).normalize().select().scrollIntoView(editable);\n    };\n  };\n\n  /**\n   * @class editing.Table\n   *\n   * Table\n   *\n   */\n  var Table = function () {\n    /**\n     * handle tab key\n     *\n     * @param {WrappedRange} rng\n     * @param {Boolean} isShift\n     */\n    this.tab = function (rng, isShift) {\n      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);\n      var table = dom.ancestor(cell, dom.isTable);\n      var cells = dom.listDescendant(table, dom.isCell);\n\n      var nextCell = list[isShift ? 'prev' : 'next'](cells, cell);\n      if (nextCell) {\n        range.create(nextCell, 0).select();\n      }\n    };\n\n    /**\n     * create empty table element\n     *\n     * @param {Number} rowCount\n     * @param {Number} colCount\n     * @return {Node}\n     */\n    this.createTable = function (colCount, rowCount, options) {\n      var tds = [], tdHTML;\n      for (var idxCol = 0; idxCol < colCount; idxCol++) {\n        tds.push('<td>' + dom.blank + '</td>');\n      }\n      tdHTML = tds.join('');\n\n      var trs = [], trHTML;\n      for (var idxRow = 0; idxRow < rowCount; idxRow++) {\n        trs.push('<tr>' + tdHTML + '</tr>');\n      }\n      trHTML = trs.join('');\n      var $table = $('<table>' + trHTML + '</table>');\n      if (options && options.tableClassName) {\n        $table.addClass(options.tableClassName);\n      }\n\n      return $table[0];\n    };\n  };\n\n\n  var KEY_BOGUS = 'bogus';\n\n  /**\n   * @class Editor\n   */\n  var Editor = function (context) {\n    var self = this;\n\n    var $note = context.layoutInfo.note;\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    var editable = $editable[0];\n    var lastRange = null;\n\n    var style = new Style();\n    var table = new Table();\n    var typing = new Typing();\n    var bullet = new Bullet();\n    var history = new History($editable);\n\n    this.initialize = function () {\n      // bind custom events\n      $editable.on('keydown', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          context.triggerEvent('enter', event);\n        }\n        context.triggerEvent('keydown', event);\n\n        if (options.shortcuts && !event.isDefaultPrevented()) {\n          self.handleKeyMap(event);\n        }\n      }).on('keyup', function (event) {\n        context.triggerEvent('keyup', event);\n      }).on('focus', function (event) {\n        context.triggerEvent('focus', event);\n      }).on('blur', function (event) {\n        context.triggerEvent('blur', event);\n      }).on('mousedown', function (event) {\n        context.triggerEvent('mousedown', event);\n      }).on('mouseup', function (event) {\n        context.triggerEvent('mouseup', event);\n      }).on('scroll', function (event) {\n        context.triggerEvent('scroll', event);\n      }).on('paste', function (event) {\n        context.triggerEvent('paste', event);\n      });\n\n      // init content before set event\n      $editable.html(dom.html($note) || dom.emptyPara);\n\n      // [workaround] IE doesn't have input events for contentEditable\n      // - see: https://goo.gl/4bfIvA\n      var changeEventName = agent.isMSIE ? 'DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted' : 'input';\n      $editable.on(changeEventName, function () {\n        context.triggerEvent('change', $editable.html());\n      });\n\n      $editor.on('focusin', function (event) {\n        context.triggerEvent('focusin', event);\n      }).on('focusout', function (event) {\n        context.triggerEvent('focusout', event);\n      });\n\n      if (!options.airMode && options.height) {\n        this.setHeight(options.height);\n      }\n      if (!options.airMode && options.maxHeight) {\n        $editable.css('max-height', options.maxHeight);\n      }\n      if (!options.airMode && options.minHeight) {\n        $editable.css('min-height', options.minHeight);\n      }\n\n      history.recordUndo();\n    };\n\n    this.destroy = function () {\n      $editable.off();\n    };\n\n    this.handleKeyMap = function (event) {\n      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n      var keys = [];\n\n      if (event.metaKey) { keys.push('CMD'); }\n      if (event.ctrlKey && !event.altKey) { keys.push('CTRL'); }\n      if (event.shiftKey) { keys.push('SHIFT'); }\n\n      var keyName = key.nameFromCode[event.keyCode];\n      if (keyName) {\n        keys.push(keyName);\n      }\n\n      var eventName = keyMap[keys.join('+')];\n      if (eventName) {\n        event.preventDefault();\n        context.invoke(eventName);\n      } else if (key.isEdit(event.keyCode)) {\n        this.afterCommand();\n      }\n    };\n\n    /**\n     * create range\n     * @return {WrappedRange}\n     */\n    this.createRange = function () {\n      this.focus();\n      return range.create(editable);\n    };\n\n    /**\n     * saveRange\n     *\n     * save current range\n     *\n     * @param {Boolean} [thenCollapse=false]\n     */\n    this.saveRange = function (thenCollapse) {\n      lastRange = this.createRange();\n      if (thenCollapse) {\n        lastRange.collapse().select();\n      }\n    };\n\n    /**\n     * restoreRange\n     *\n     * restore lately range\n     */\n    this.restoreRange = function () {\n      if (lastRange) {\n        lastRange.select();\n        this.focus();\n      }\n    };\n\n    this.saveTarget = function (node) {\n      $editable.data('target', node);\n    };\n\n    this.clearTarget = function () {\n      $editable.removeData('target');\n    };\n\n    this.restoreTarget = function () {\n      return $editable.data('target');\n    };\n\n    /**\n     * currentStyle\n     *\n     * current style\n     * @return {Object|Boolean} unfocus\n     */\n    this.currentStyle = function () {\n      var rng = range.create();\n      if (rng) {\n        rng = rng.normalize();\n      }\n      return rng ? style.current(rng) : style.fromNode($editable);\n    };\n\n    /**\n     * style from node\n     *\n     * @param {jQuery} $node\n     * @return {Object}\n     */\n    this.styleFromNode = function ($node) {\n      return style.fromNode($node);\n    };\n\n    /**\n     * undo\n     */\n    this.undo = function () {\n      context.triggerEvent('before.command', $editable.html());\n      history.undo();\n      context.triggerEvent('change', $editable.html());\n    };\n    context.memo('help.undo', lang.help.undo);\n\n    /**\n     * redo\n     */\n    this.redo = function () {\n      context.triggerEvent('before.command', $editable.html());\n      history.redo();\n      context.triggerEvent('change', $editable.html());\n    };\n    context.memo('help.redo', lang.help.redo);\n\n    /**\n     * before command\n     */\n    var beforeCommand = this.beforeCommand = function () {\n      context.triggerEvent('before.command', $editable.html());\n      // keep focus on editable before command execution\n      self.focus();\n    };\n\n    /**\n     * after command\n     * @param {Boolean} isPreventTrigger\n     */\n    var afterCommand = this.afterCommand = function (isPreventTrigger) {\n      history.recordUndo();\n      if (!isPreventTrigger) {\n        context.triggerEvent('change', $editable.html());\n      }\n    };\n\n    /* jshint ignore:start */\n    // native commands(with execCommand), generate function for execCommand\n    var commands = ['bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript',\n                    'justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull',\n                    'formatBlock', 'removeFormat',\n                    'backColor', 'foreColor', 'fontName'];\n\n    for (var idx = 0, len = commands.length; idx < len; idx ++) {\n      this[commands[idx]] = (function (sCmd) {\n        return function (value) {\n          beforeCommand();\n          document.execCommand(sCmd, false, value);\n          afterCommand(true);\n        };\n      })(commands[idx]);\n      context.memo('help.' + commands[idx], lang.help[commands[idx]]);\n    }\n    /* jshint ignore:end */\n\n    /**\n     * handle tab key\n     */\n    this.tab = function () {\n      var rng = this.createRange();\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        table.tab(rng);\n      } else {\n        beforeCommand();\n        typing.insertTab(rng, options.tabSize);\n        afterCommand();\n      }\n    };\n    context.memo('help.tab', lang.help.tab);\n\n    /**\n     * handle shift+tab key\n     */\n    this.untab = function () {\n      var rng = this.createRange();\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        table.tab(rng, true);\n      }\n    };\n    context.memo('help.untab', lang.help.untab);\n\n    /**\n     * run given function between beforeCommand and afterCommand\n     */\n    this.wrapCommand = function (fn) {\n      return function () {\n        beforeCommand();\n        fn.apply(self, arguments);\n        afterCommand();\n      };\n    };\n\n    /**\n     * insert paragraph\n     */\n    this.insertParagraph = this.wrapCommand(function () {\n      typing.insertParagraph(editable);\n    });\n    context.memo('help.insertParagraph', lang.help.insertParagraph);\n\n    this.insertOrderedList = this.wrapCommand(function () {\n      bullet.insertOrderedList(editable);\n    });\n    context.memo('help.insertOrderedList', lang.help.insertOrderedList);\n\n    this.insertUnorderedList = this.wrapCommand(function () {\n      bullet.insertUnorderedList(editable);\n    });\n    context.memo('help.insertUnorderedList', lang.help.insertUnorderedList);\n\n    this.indent = this.wrapCommand(function () {\n      bullet.indent(editable);\n    });\n    context.memo('help.indent', lang.help.indent);\n\n    this.outdent = this.wrapCommand(function () {\n      bullet.outdent(editable);\n    });\n    context.memo('help.outdent', lang.help.outdent);\n\n    /**\n     * insert image\n     *\n     * @param {String} src\n     * @param {String|Function} param\n     * @return {Promise}\n     */\n    this.insertImage = function (src, param) {\n      return async.createImage(src, param).then(function ($image) {\n        beforeCommand();\n\n        if (typeof param === 'function') {\n          param($image);\n        } else {\n          if (typeof param === 'string') {\n            $image.attr('data-filename', param);\n          }\n          $image.css('width', Math.min($editable.width(), $image.width()));\n        }\n\n        $image.show();\n        range.create(editable).insertNode($image[0]);\n        range.createFromNodeAfter($image[0]).select();\n        afterCommand();\n      }).fail(function (e) {\n        context.triggerEvent('image.upload.error', e);\n      });\n    };\n\n    /**\n     * insertImages\n     * @param {File[]} files\n     */\n    this.insertImages = function (files) {\n      $.each(files, function (idx, file) {\n        var filename = file.name;\n        if (options.maximumImageFileSize && options.maximumImageFileSize < file.size) {\n          context.triggerEvent('image.upload.error', lang.image.maximumFileSizeError);\n        } else {\n          async.readFileAsDataURL(file).then(function (dataURL) {\n            return self.insertImage(dataURL, filename);\n          }).fail(function () {\n            context.triggerEvent('image.upload.error');\n          });\n        }\n      });\n    };\n\n    /**\n     * insertImagesOrCallback\n     * @param {File[]} files\n     */\n    this.insertImagesOrCallback = function (files) {\n      var callbacks = options.callbacks;\n\n      // If onImageUpload options setted\n      if (callbacks.onImageUpload) {\n        context.triggerEvent('image.upload', files);\n      // else insert Image as dataURL\n      } else {\n        this.insertImages(files);\n      }\n    };\n\n    /**\n     * insertNode\n     * insert node\n     * @param {Node} node\n     */\n    this.insertNode = this.wrapCommand(function (node) {\n      var rng = this.createRange();\n      rng.insertNode(node);\n      range.createFromNodeAfter(node).select();\n    });\n\n    /**\n     * insert text\n     * @param {String} text\n     */\n    this.insertText = this.wrapCommand(function (text) {\n      var rng = this.createRange();\n      var textNode = rng.insertNode(dom.createText(text));\n      range.create(textNode, dom.nodeLength(textNode)).select();\n    });\n\n    /**\n     * return selected plain text\n     * @return {String} text\n     */\n    this.getSelectedText = function () {\n      var rng = this.createRange();\n\n      // if range on anchor, expand range with anchor\n      if (rng.isOnAnchor()) {\n        rng = range.createFromNode(dom.ancestor(rng.sc, dom.isAnchor));\n      }\n\n      return rng.toString();\n    };\n\n    /**\n     * paste HTML\n     * @param {String} markup\n     */\n    this.pasteHTML = this.wrapCommand(function (markup) {\n      var contents = this.createRange().pasteHTML(markup);\n      range.createFromNodeAfter(list.last(contents)).select();\n    });\n\n    /**\n     * formatBlock\n     *\n     * @param {String} tagName\n     */\n    this.formatBlock = this.wrapCommand(function (tagName) {\n      // [workaround] for MSIE, IE need `<`\n      tagName = agent.isMSIE ? '<' + tagName + '>' : tagName;\n      document.execCommand('FormatBlock', false, tagName);\n    });\n\n    this.formatPara = function () {\n      this.formatBlock('P');\n    };\n    context.memo('help.formatPara', lang.help.formatPara);\n\n    /* jshint ignore:start */\n    for (var idx = 1; idx <= 6; idx ++) {\n      this['formatH' + idx] = function (idx) {\n        return function () {\n          this.formatBlock('H' + idx);\n        };\n      }(idx);\n      context.memo('help.formatH'+idx, lang.help['formatH' + idx]);\n    };\n    /* jshint ignore:end */\n\n    /**\n     * fontSize\n     *\n     * @param {String} value - px\n     */\n    this.fontSize = function (value) {\n      var rng = this.createRange();\n\n      if (rng && rng.isCollapsed()) {\n        var spans = style.styleNodes(rng);\n        var firstSpan = list.head(spans);\n\n        $(spans).css({\n          'font-size': value + 'px'\n        });\n\n        // [workaround] added styled bogus span for style\n        //  - also bogus character needed for cursor position\n        if (firstSpan && !dom.nodeLength(firstSpan)) {\n          firstSpan.innerHTML = dom.ZERO_WIDTH_NBSP_CHAR;\n          range.createFromNodeAfter(firstSpan.firstChild).select();\n          $editable.data(KEY_BOGUS, firstSpan);\n        }\n      } else {\n        beforeCommand();\n        $(style.styleNodes(rng)).css({\n          'font-size': value + 'px'\n        });\n        afterCommand();\n      }\n    };\n\n    /**\n     * insert horizontal rule\n     */\n    this.insertHorizontalRule = this.wrapCommand(function () {\n      var hrNode = this.createRange().insertNode(dom.create('HR'));\n      if (hrNode.nextSibling) {\n        range.create(hrNode.nextSibling, 0).normalize().select();\n      }\n    });\n    context.memo('help.insertHorizontalRule', lang.help.insertHorizontalRule);\n\n    /**\n     * remove bogus node and character\n     */\n    this.removeBogus = function () {\n      var bogusNode = $editable.data(KEY_BOGUS);\n      if (!bogusNode) {\n        return;\n      }\n\n      var textNode = list.find(list.from(bogusNode.childNodes), dom.isText);\n\n      var bogusCharIdx = textNode.nodeValue.indexOf(dom.ZERO_WIDTH_NBSP_CHAR);\n      if (bogusCharIdx !== -1) {\n        textNode.deleteData(bogusCharIdx, 1);\n      }\n\n      if (dom.isEmpty(bogusNode)) {\n        dom.remove(bogusNode);\n      }\n\n      $editable.removeData(KEY_BOGUS);\n    };\n\n    /**\n     * lineHeight\n     * @param {String} value\n     */\n    this.lineHeight = this.wrapCommand(function (value) {\n      style.stylePara(this.createRange(), {\n        lineHeight: value\n      });\n    });\n\n    /**\n     * unlink\n     *\n     * @type command\n     */\n    this.unlink = function () {\n      var rng = this.createRange();\n      if (rng.isOnAnchor()) {\n        var anchor = dom.ancestor(rng.sc, dom.isAnchor);\n        rng = range.createFromNode(anchor);\n        rng.select();\n\n        beforeCommand();\n        document.execCommand('unlink');\n        afterCommand();\n      }\n    };\n\n    /**\n     * create link (command)\n     *\n     * @param {Object} linkInfo\n     */\n    this.createLink = this.wrapCommand(function (linkInfo) {\n      var linkUrl = linkInfo.url;\n      var linkText = linkInfo.text;\n      var isNewWindow = linkInfo.isNewWindow;\n      var rng = linkInfo.range || this.createRange();\n      var isTextChanged = rng.toString() !== linkText;\n\n      if (options.onCreateLink) {\n        linkUrl = options.onCreateLink(linkUrl);\n      }\n\n      var anchors = [];\n      if (isTextChanged) {\n        rng = rng.deleteContents();\n        var anchor = rng.insertNode($('<A>' + linkText + '</A>')[0]);\n        anchors.push(anchor);\n      } else {\n        anchors = style.styleNodes(rng, {\n          nodeName: 'A',\n          expandClosestSibling: true,\n          onlyPartialContains: true\n        });\n      }\n\n      $.each(anchors, function (idx, anchor) {\n        $(anchor).attr('href', linkUrl);\n        if (isNewWindow) {\n          $(anchor).attr('target', '_blank');\n        } else {\n          $(anchor).removeAttr('target');\n        }\n      });\n\n      var startRange = range.createFromNodeBefore(list.head(anchors));\n      var startPoint = startRange.getStartPoint();\n      var endRange = range.createFromNodeAfter(list.last(anchors));\n      var endPoint = endRange.getEndPoint();\n\n      range.create(\n        startPoint.node,\n        startPoint.offset,\n        endPoint.node,\n        endPoint.offset\n      ).select();\n    });\n\n    /**\n     * returns link info\n     *\n     * @return {Object}\n     * @return {WrappedRange} return.range\n     * @return {String} return.text\n     * @return {Boolean} [return.isNewWindow=true]\n     * @return {String} [return.url=\"\"]\n     */\n    this.getLinkInfo = function () {\n      var rng = this.createRange().expand(dom.isAnchor);\n\n      // Get the first anchor on range(for edit).\n      var $anchor = $(list.head(rng.nodes(dom.isAnchor)));\n\n      return {\n        range: rng,\n        text: rng.toString(),\n        isNewWindow: $anchor.length ? $anchor.attr('target') === '_blank' : false,\n        url: $anchor.length ? $anchor.attr('href') : ''\n      };\n    };\n\n    /**\n     * setting color\n     *\n     * @param {Object} sObjColor  color code\n     * @param {String} sObjColor.foreColor foreground color\n     * @param {String} sObjColor.backColor background color\n     */\n    this.color = this.wrapCommand(function (colorInfo) {\n      var foreColor = colorInfo.foreColor;\n      var backColor = colorInfo.backColor;\n\n      if (foreColor) { document.execCommand('foreColor', false, foreColor); }\n      if (backColor) { document.execCommand('backColor', false, backColor); }\n    });\n\n    /**\n     * insert Table\n     *\n     * @param {String} dimension of table (ex : \"5x5\")\n     */\n    this.insertTable = this.wrapCommand(function (dim) {\n      var dimension = dim.split('x');\n\n      var rng = this.createRange().deleteContents();\n      rng.insertNode(table.createTable(dimension[0], dimension[1], options));\n    });\n\n    /**\n     * float me\n     *\n     * @param {String} value\n     */\n    this.floatMe = this.wrapCommand(function (value) {\n      var $target = $(this.restoreTarget());\n      $target.css('float', value);\n    });\n\n    /**\n     * resize overlay element\n     * @param {String} value\n     */\n    this.resize = this.wrapCommand(function (value) {\n      var $target = $(this.restoreTarget());\n      $target.css({\n        width: value * 100 + '%',\n        height: ''\n      });\n    });\n\n    /**\n     * @param {Position} pos\n     * @param {jQuery} $target - target element\n     * @param {Boolean} [bKeepRatio] - keep ratio\n     */\n    this.resizeTo = function (pos, $target, bKeepRatio) {\n      var imageSize;\n      if (bKeepRatio) {\n        var newRatio = pos.y / pos.x;\n        var ratio = $target.data('ratio');\n        imageSize = {\n          width: ratio > newRatio ? pos.x : pos.y / ratio,\n          height: ratio > newRatio ? pos.x * ratio : pos.y\n        };\n      } else {\n        imageSize = {\n          width: pos.x,\n          height: pos.y\n        };\n      }\n\n      $target.css(imageSize);\n    };\n\n    /**\n     * remove media object\n     */\n    this.removeMedia = this.wrapCommand(function () {\n      var $target = $(this.restoreTarget()).detach();\n      context.triggerEvent('media.delete', $target, $editable);\n    });\n\n    /**\n     * returns whether editable area has focus or not.\n     */\n    this.hasFocus = function () {\n      return $editable.is(':focus');\n    };\n\n    /**\n     * set focus\n     */\n    this.focus = function () {\n      // [workaround] Screen will move when page is scolled in IE.\n      //  - do focus when not focused\n      if (!this.hasFocus()) {\n        $editable.focus();\n      }\n    };\n\n    /**\n     * returns whether contents is empty or not.\n     * @return {Boolean}\n     */\n    this.isEmpty = function () {\n      return dom.isEmpty($editable[0]) || dom.emptyPara === $editable.html();\n    };\n\n    /**\n     * Removes all contents and restores the editable instance to an _emptyPara_.\n     */\n    this.empty = function () {\n      context.invoke('code', dom.emptyPara);\n    };\n\n    /**\n     * set height for editable\n     */\n    this.setHeight = function (height) {\n      $editable.outerHeight(height);\n    };\n  };\n\n  var Clipboard = function (context) {\n    var self = this;\n\n    var $editable = context.layoutInfo.editable;\n\n    this.events = {\n      'summernote.keydown': function (we, e) {\n        if (self.needKeydownHook()) {\n          if ((e.ctrlKey || e.metaKey) && e.keyCode === key.code.V) {\n            context.invoke('editor.saveRange');\n            self.$paste.focus();\n\n            setTimeout(function () {\n              self.pasteByHook();\n            }, 0);\n          }\n        }\n      }\n    };\n\n    this.needKeydownHook = function () {\n      return (agent.isMSIE && agent.browserVersion > 10) || agent.isFF;\n    };\n\n    this.initialize = function () {\n      // [workaround] getting image from clipboard\n      //  - IE11 and Firefox: CTRL+v hook\n      //  - Webkit: event.clipboardData\n      if (this.needKeydownHook()) {\n        this.$paste = $('<div />').attr('contenteditable', true).css({\n          position: 'absolute',\n          left: -100000,\n          opacity: 0\n        });\n        $editable.before(this.$paste);\n\n        this.$paste.on('paste', function (event) {\n          context.triggerEvent('paste', event);\n        });\n      } else {\n        $editable.on('paste', this.pasteByEvent);\n      }\n    };\n\n    this.destroy = function () {\n      if (this.needKeydownHook()) {\n        this.$paste.remove();\n        this.$paste = null;\n      }\n    };\n\n    this.pasteByHook = function () {\n      var node = this.$paste[0].firstChild;\n\n      if (dom.isImg(node)) {\n        var dataURI = node.src;\n        var decodedData = atob(dataURI.split(',')[1]);\n        var array = new Uint8Array(decodedData.length);\n        for (var i = 0; i < decodedData.length; i++) {\n          array[i] = decodedData.charCodeAt(i);\n        }\n\n        var blob = new Blob([array], { type: 'image/png' });\n        blob.name = 'clipboard.png';\n\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.focus');\n        context.invoke('editor.insertImagesOrCallback', [blob]);\n      } else {\n        var pasteContent = $('<div />').html(this.$paste.html()).html();\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.focus');\n\n        if (pasteContent) {\n          context.invoke('editor.pasteHTML', pasteContent);\n        }\n      }\n\n      this.$paste.empty();\n    };\n\n    /**\n     * paste by clipboard event\n     *\n     * @param {Event} event\n     */\n    this.pasteByEvent = function (event) {\n      var clipboardData = event.originalEvent.clipboardData;\n      if (clipboardData && clipboardData.items && clipboardData.items.length) {\n        var item = list.head(clipboardData.items);\n        if (item.kind === 'file' && item.type.indexOf('image/') !== -1) {\n          context.invoke('editor.insertImagesOrCallback', [item.getAsFile()]);\n        }\n        context.invoke('editor.afterCommand');\n      }\n    };\n  };\n\n  var Dropzone = function (context) {\n    var $document = $(document);\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    var $dropzone = $([\n      '<div class=\"note-dropzone\">',\n      '  <div class=\"note-dropzone-message\"/>',\n      '</div>'\n    ].join('')).prependTo($editor);\n\n    /**\n     * attach Drag and Drop Events\n     */\n    this.initialize = function () {\n      if (options.disableDragAndDrop) {\n        // prevent default drop event\n        $document.on('drop', function (e) {\n          e.preventDefault();\n        });\n      } else {\n        this.attachDragAndDropEvent();\n      }\n    };\n\n    /**\n     * attach Drag and Drop Events\n     */\n    this.attachDragAndDropEvent = function () {\n      var collection = $(),\n          $dropzoneMessage = $dropzone.find('.note-dropzone-message');\n\n      // show dropzone on dragenter when dragging a object to document\n      // -but only if the editor is visible, i.e. has a positive width and height\n      $document.on('dragenter', function (e) {\n        var isCodeview = context.invoke('codeview.isActivated');\n        var hasEditorSize = $editor.width() > 0 && $editor.height() > 0;\n        if (!isCodeview && !collection.length && hasEditorSize) {\n          $editor.addClass('dragover');\n          $dropzone.width($editor.width());\n          $dropzone.height($editor.height());\n          $dropzoneMessage.text(lang.image.dragImageHere);\n        }\n        collection = collection.add(e.target);\n      }).on('dragleave', function (e) {\n        collection = collection.not(e.target);\n        if (!collection.length) {\n          $editor.removeClass('dragover');\n        }\n      }).on('drop', function () {\n        collection = $();\n        $editor.removeClass('dragover');\n      });\n\n      // change dropzone's message on hover.\n      $dropzone.on('dragenter', function () {\n        $dropzone.addClass('hover');\n        $dropzoneMessage.text(lang.image.dropImage);\n      }).on('dragleave', function () {\n        $dropzone.removeClass('hover');\n        $dropzoneMessage.text(lang.image.dragImageHere);\n      });\n\n      // attach dropImage\n      $dropzone.on('drop', function (event) {\n        var dataTransfer = event.originalEvent.dataTransfer;\n\n        if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {\n          event.preventDefault();\n          $editable.focus();\n          context.invoke('editor.insertImagesOrCallback', dataTransfer.files);\n        } else {\n          $.each(dataTransfer.types, function (idx, type) {\n            var content = dataTransfer.getData(type);\n\n            if (type.toLowerCase().indexOf('text') > -1) {\n              context.invoke('editor.pasteHTML', content);\n            } else {\n              $(content).each(function () {\n                context.invoke('editor.insertNode', this);\n              });\n            }\n          });\n        }\n      }).on('dragover', false); // prevent default dragover event\n    };\n  };\n\n\n  var CodeMirror;\n  if (agent.hasCodeMirror) {\n    if (agent.isSupportAmd) {\n      new Promise(function(resolve) { resolve(); }).then(function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(144)]; (function (cm) {\n        CodeMirror = cm;\n      }.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}).catch(__webpack_require__.oe);\n    } else {\n      CodeMirror = window.CodeMirror;\n    }\n  }\n\n  /**\n   * @class Codeview\n   */\n  var Codeview = function (context) {\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var $codable = context.layoutInfo.codable;\n    var options = context.options;\n\n    this.sync = function () {\n      var isCodeview = this.isActivated();\n      if (isCodeview && agent.hasCodeMirror) {\n        $codable.data('cmEditor').save();\n      }\n    };\n\n    /**\n     * @return {Boolean}\n     */\n    this.isActivated = function () {\n      return $editor.hasClass('codeview');\n    };\n\n    /**\n     * toggle codeview\n     */\n    this.toggle = function () {\n      if (this.isActivated()) {\n        this.deactivate();\n      } else {\n        this.activate();\n      }\n      context.triggerEvent('codeview.toggled');\n    };\n\n    /**\n     * activate code view\n     */\n    this.activate = function () {\n      $codable.val(dom.html($editable, options.prettifyHtml));\n      $codable.height($editable.height());\n\n      context.invoke('toolbar.updateCodeview', true);\n      $editor.addClass('codeview');\n      $codable.focus();\n\n      // activate CodeMirror as codable\n      if (agent.hasCodeMirror) {\n        var cmEditor = CodeMirror.fromTextArea($codable[0], options.codemirror);\n\n        // CodeMirror TernServer\n        if (options.codemirror.tern) {\n          var server = new CodeMirror.TernServer(options.codemirror.tern);\n          cmEditor.ternServer = server;\n          cmEditor.on('cursorActivity', function (cm) {\n            server.updateArgHints(cm);\n          });\n        }\n\n        // CodeMirror hasn't Padding.\n        cmEditor.setSize(null, $editable.outerHeight());\n        $codable.data('cmEditor', cmEditor);\n      }\n    };\n\n    /**\n     * deactivate code view\n     */\n    this.deactivate = function () {\n      // deactivate CodeMirror as codable\n      if (agent.hasCodeMirror) {\n        var cmEditor = $codable.data('cmEditor');\n        $codable.val(cmEditor.getValue());\n        cmEditor.toTextArea();\n      }\n\n      var value = dom.value($codable, options.prettifyHtml) || dom.emptyPara;\n      var isChange = $editable.html() !== value;\n\n      $editable.html(value);\n      $editable.height(options.height ? $codable.height() : 'auto');\n      $editor.removeClass('codeview');\n\n      if (isChange) {\n        context.triggerEvent('change', $editable.html(), $editable);\n      }\n\n      $editable.focus();\n\n      context.invoke('toolbar.updateCodeview', false);\n    };\n\n    this.destroy = function () {\n      if (this.isActivated()) {\n        this.deactivate();\n      }\n    };\n  };\n\n  var EDITABLE_PADDING = 24;\n\n  var Statusbar = function (context) {\n    var $document = $(document);\n    var $statusbar = context.layoutInfo.statusbar;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n\n    this.initialize = function () {\n      if (options.airMode || options.disableResizeEditor) {\n        return;\n      }\n\n      $statusbar.on('mousedown', function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        var editableTop = $editable.offset().top - $document.scrollTop();\n\n        $document.on('mousemove', function (event) {\n          var height = event.clientY - (editableTop + EDITABLE_PADDING);\n\n          height = (options.minheight > 0) ? Math.max(height, options.minheight) : height;\n          height = (options.maxHeight > 0) ? Math.min(height, options.maxHeight) : height;\n\n          $editable.height(height);\n        }).one('mouseup', function () {\n          $document.off('mousemove');\n        });\n      });\n    };\n\n    this.destroy = function () {\n      $statusbar.off();\n    };\n  };\n\n  var Fullscreen = function (context) {\n    var $editor = context.layoutInfo.editor;\n    var $toolbar = context.layoutInfo.toolbar;\n    var $editable = context.layoutInfo.editable;\n    var $codable = context.layoutInfo.codable;\n\n    var $window = $(window);\n    var $scrollbar = $('html, body');\n\n    /**\n     * toggle fullscreen\n     */\n    this.toggle = function () {\n      var resize = function (size) {\n        $editable.css('height', size.h);\n        $codable.css('height', size.h);\n        if ($codable.data('cmeditor')) {\n          $codable.data('cmeditor').setsize(null, size.h);\n        }\n      };\n\n      $editor.toggleClass('fullscreen');\n      if (this.isFullscreen()) {\n        $editable.data('orgHeight', $editable.css('height'));\n\n        $window.on('resize', function () {\n          resize({\n            h: $window.height() - $toolbar.outerHeight()\n          });\n        }).trigger('resize');\n\n        $scrollbar.css('overflow', 'hidden');\n      } else {\n        $window.off('resize');\n        resize({\n          h: $editable.data('orgHeight')\n        });\n        $scrollbar.css('overflow', 'visible');\n      }\n\n      context.invoke('toolbar.updateFullscreen', this.isFullscreen());\n    };\n\n    this.isFullscreen = function () {\n      return $editor.hasClass('fullscreen');\n    };\n  };\n\n  var Handle = function (context) {\n    var self = this;\n\n    var $document = $(document);\n    var $editingArea = context.layoutInfo.editingArea;\n    var options = context.options;\n\n    this.events = {\n      'summernote.mousedown': function (we, e) {\n        if (self.update(e.target)) {\n          e.preventDefault();\n        }\n      },\n      'summernote.keyup summernote.scroll summernote.change summernote.dialog.shown': function () {\n        self.update();\n      }\n    };\n\n    this.initialize = function () {\n      this.$handle = $([\n        '<div class=\"note-handle\">',\n        '<div class=\"note-control-selection\">',\n        '<div class=\"note-control-selection-bg\"></div>',\n        '<div class=\"note-control-holder note-control-nw\"></div>',\n        '<div class=\"note-control-holder note-control-ne\"></div>',\n        '<div class=\"note-control-holder note-control-sw\"></div>',\n        '<div class=\"',\n        (options.disableResizeImage ? 'note-control-holder' : 'note-control-sizing'),\n        ' note-control-se\"></div>',\n        (options.disableResizeImage ? '' : '<div class=\"note-control-selection-info\"></div>'),\n        '</div>',\n        '</div>'\n      ].join('')).prependTo($editingArea);\n\n      this.$handle.on('mousedown', function (event) {\n        if (dom.isControlSizing(event.target)) {\n          event.preventDefault();\n          event.stopPropagation();\n\n          var $target = self.$handle.find('.note-control-selection').data('target'),\n              posStart = $target.offset(),\n              scrollTop = $document.scrollTop();\n\n          $document.on('mousemove', function (event) {\n            context.invoke('editor.resizeTo', {\n              x: event.clientX - posStart.left,\n              y: event.clientY - (posStart.top - scrollTop)\n            }, $target, !event.shiftKey);\n\n            self.update($target[0]);\n          }).one('mouseup', function (e) {\n            e.preventDefault();\n            $document.off('mousemove');\n            context.invoke('editor.afterCommand');\n          });\n\n          if (!$target.data('ratio')) { // original ratio.\n            $target.data('ratio', $target.height() / $target.width());\n          }\n        }\n      });\n    };\n\n    this.destroy = function () {\n      this.$handle.remove();\n    };\n\n    this.update = function (target) {\n      var isImage = dom.isImg(target);\n      var $selection = this.$handle.find('.note-control-selection');\n\n      context.invoke('imagePopover.update', target);\n\n      if (isImage) {\n        var $image = $(target);\n        var pos = $image.position();\n\n        // include margin\n        var imageSize = {\n          w: $image.outerWidth(true),\n          h: $image.outerHeight(true)\n        };\n\n        $selection.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top,\n          width: imageSize.w,\n          height: imageSize.h\n        }).data('target', $image); // save current image element.\n\n        var sizingText = imageSize.w + 'x' + imageSize.h;\n        $selection.find('.note-control-selection-info').text(sizingText);\n        context.invoke('editor.saveTarget', target);\n      } else {\n        this.hide();\n      }\n\n      return isImage;\n    };\n\n    /**\n     * hide\n     *\n     * @param {jQuery} $handle\n     */\n    this.hide = function () {\n      context.invoke('editor.clearTarget');\n      this.$handle.children().hide();\n    };\n  };\n\n  var AutoLink = function (context) {\n    var self = this;\n    var defaultScheme = 'http://';\n    var linkPattern = /^(https?:\\/\\/|ssh:\\/\\/|ftp:\\/\\/|file:\\/|mailto:[A-Z0-9._%+-]+@)?(www\\.)?(.+)$/i;\n\n    this.events = {\n      'summernote.keyup': function (we, e) {\n        if (!e.isDefaultPrevented()) {\n          self.handleKeyup(e);\n        }\n      },\n      'summernote.keydown': function (we, e) {\n        self.handleKeydown(e);\n      }\n    };\n\n    this.initialize = function () {\n      this.lastWordRange = null;\n    };\n\n    this.destroy = function () {\n      this.lastWordRange = null;\n    };\n\n    this.replace = function () {\n      if (!this.lastWordRange) {\n        return;\n      }\n\n      var keyword = this.lastWordRange.toString();\n      var match = keyword.match(linkPattern);\n\n      if (match && (match[1] || match[2])) {\n        var link = match[1] ? keyword : defaultScheme + keyword;\n        var node = $('<a />').html(keyword).attr('href', link)[0];\n\n        this.lastWordRange.insertNode(node);\n        this.lastWordRange = null;\n        context.invoke('editor.focus');\n      }\n\n    };\n\n    this.handleKeydown = function (e) {\n      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {\n        var wordRange = context.invoke('editor.createRange').getWordRange();\n        this.lastWordRange = wordRange;\n      }\n    };\n\n    this.handleKeyup = function (e) {\n      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {\n        this.replace();\n      }\n    };\n  };\n\n  /**\n   * textarea auto sync.\n   */\n  var AutoSync = function (context) {\n    var $note = context.layoutInfo.note;\n\n    this.events = {\n      'summernote.change': function () {\n        $note.val(context.invoke('code'));\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return dom.isTextarea($note[0]);\n    };\n  };\n\n  var Placeholder = function (context) {\n    var self = this;\n    var $editingArea = context.layoutInfo.editingArea;\n    var options = context.options;\n\n    this.events = {\n      'summernote.init summernote.change': function () {\n        self.update();\n      },\n      'summernote.codeview.toggled': function () {\n        self.update();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return !!options.placeholder;\n    };\n\n    this.initialize = function () {\n      this.$placeholder = $('<div class=\"note-placeholder\">');\n      this.$placeholder.on('click', function () {\n        context.invoke('focus');\n      }).text(options.placeholder).prependTo($editingArea);\n    };\n\n    this.destroy = function () {\n      this.$placeholder.remove();\n    };\n\n    this.update = function () {\n      var isShow = !context.invoke('codeview.isActivated') && context.invoke('editor.isEmpty');\n      this.$placeholder.toggle(isShow);\n    };\n  };\n\n  var Buttons = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $toolbar = context.layoutInfo.toolbar;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    var invertedKeyMap = func.invertObject(options.keyMap[agent.isMac ? 'mac' : 'pc']);\n\n    var representShortcut = this.representShortcut = function (editorMethod) {\n      var shortcut = invertedKeyMap[editorMethod];\n      if (agent.isMac) {\n        shortcut = shortcut.replace('CMD', '⌘').replace('SHIFT', '⇧');\n      }\n\n      shortcut = shortcut.replace('BACKSLASH', '\\\\')\n                         .replace('SLASH', '/')\n                         .replace('LEFTBRACKET', '[')\n                         .replace('RIGHTBRACKET', ']');\n\n      return ' (' + shortcut + ')';\n    };\n\n    this.initialize = function () {\n      this.addToolbarButtons();\n      this.addImagePopoverButtons();\n      this.addLinkPopoverButtons();\n      this.fontInstalledMap = {};\n    };\n\n    this.destroy = function () {\n      delete this.fontInstalledMap;\n    };\n\n    this.isFontInstalled = function (name) {\n      if (!self.fontInstalledMap.hasOwnProperty(name)) {\n        self.fontInstalledMap[name] = agent.isFontInstalled(name) ||\n          list.contains(options.fontNamesIgnoreCheck, name);\n      }\n\n      return self.fontInstalledMap[name];\n    };\n\n    this.addToolbarButtons = function () {\n      context.memo('button.style', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.magic) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.style.style,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown({\n            className: 'dropdown-style',\n            items: context.options.styleTags,\n            template: function (item) {\n\n              if (typeof item === 'string') {\n                item = { tag: item, title: item };\n              }\n\n              var tag = item.tag;\n              var title = item.title;\n              var style = item.style ? ' style=\"' + item.style + '\" ' : '';\n              var className = item.className ? ' className=\"' + item.className + '\"' : '';\n\n              return '<' + tag + style + className + '>' + title + '</' + tag +  '>';\n            },\n            click: context.createInvokeHandler('editor.formatBlock')\n          })\n        ]).render();\n      });\n\n      context.memo('button.bold', function () {\n        return ui.button({\n          className: 'note-btn-bold',\n          contents: ui.icon(options.icons.bold),\n          tooltip: lang.font.bold + representShortcut('bold'),\n          click: context.createInvokeHandler('editor.bold')\n        }).render();\n      });\n\n      context.memo('button.italic', function () {\n        return ui.button({\n          className: 'note-btn-italic',\n          contents: ui.icon(options.icons.italic),\n          tooltip: lang.font.italic + representShortcut('italic'),\n          click: context.createInvokeHandler('editor.italic')\n        }).render();\n      });\n\n      context.memo('button.underline', function () {\n        return ui.button({\n          className: 'note-btn-underline',\n          contents: ui.icon(options.icons.underline),\n          tooltip: lang.font.underline + representShortcut('underline'),\n          click: context.createInvokeHandler('editor.underline')\n        }).render();\n      });\n\n      context.memo('button.clear', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.eraser),\n          tooltip: lang.font.clear + representShortcut('removeFormat'),\n          click: context.createInvokeHandler('editor.removeFormat')\n        }).render();\n      });\n\n      context.memo('button.strikethrough', function () {\n        return ui.button({\n          className: 'note-btn-strikethrough',\n          contents: ui.icon(options.icons.strikethrough),\n          tooltip: lang.font.strikethrough + representShortcut('strikethrough'),\n          click: context.createInvokeHandler('editor.strikethrough')\n        }).render();\n      });\n\n      context.memo('button.superscript', function () {\n        return ui.button({\n          className: 'note-btn-superscript',\n          contents: ui.icon(options.icons.superscript),\n          tooltip: lang.font.superscript,\n          click: context.createInvokeHandler('editor.superscript')\n        }).render();\n      });\n\n      context.memo('button.subscript', function () {\n        return ui.button({\n          className: 'note-btn-subscript',\n          contents: ui.icon(options.icons.subscript),\n          tooltip: lang.font.subscript,\n          click: context.createInvokeHandler('editor.subscript')\n        }).render();\n      });\n\n      context.memo('button.fontname', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: '<span class=\"note-current-fontname\"/> ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.font.name,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            className: 'dropdown-fontname',\n            checkClassName: options.icons.menuCheck,\n            items: options.fontNames.filter(self.isFontInstalled),\n            template: function (item) {\n              return '<span style=\"font-family:' + item + '\">' + item + '</span>';\n            },\n            click: context.createInvokeHandler('editor.fontName')\n          })\n        ]).render();\n      });\n\n      context.memo('button.fontsize', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: '<span class=\"note-current-fontsize\"/>' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.font.size,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            className: 'dropdown-fontsize',\n            checkClassName: options.icons.menuCheck,\n            items: options.fontSizes,\n            click: context.createInvokeHandler('editor.fontSize')\n          })\n        ]).render();\n      });\n\n      context.memo('button.color', function () {\n        return ui.buttonGroup({\n          className: 'note-color',\n          children: [\n            ui.button({\n              className: 'note-current-color-button',\n              contents: ui.icon(options.icons.font + ' note-recent-color'),\n              tooltip: lang.color.recent,\n              click: function (e) {\n                var $button = $(e.currentTarget);\n                context.invoke('editor.color', {\n                  backColor: $button.attr('data-backColor'),\n                  foreColor: $button.attr('data-foreColor')\n                });\n              },\n              callback: function ($button) {\n                var $recentColor = $button.find('.note-recent-color');\n                $recentColor.css('background-color', '#FFFF00');\n                $button.attr('data-backColor', '#FFFF00');\n              }\n            }),\n            ui.button({\n              className: 'dropdown-toggle',\n              contents: ui.icon(options.icons.caret, 'span'),\n              tooltip: lang.color.more,\n              data: {\n                toggle: 'dropdown'\n              }\n            }),\n            ui.dropdown({\n              items: [\n                '<li>',\n                '<div class=\"btn-group\">',\n                '  <div class=\"note-palette-title\">' + lang.color.background + '</div>',\n                '  <div>',\n                '    <button type=\"button\" class=\"note-color-reset btn btn-default\" data-event=\"backColor\" data-value=\"inherit\">',\n                lang.color.transparent,\n                '    </button>',\n                '  </div>',\n                '  <div class=\"note-holder\" data-event=\"backColor\"/>',\n                '</div>',\n                '<div class=\"btn-group\">',\n                '  <div class=\"note-palette-title\">' + lang.color.foreground + '</div>',\n                '  <div>',\n                '    <button type=\"button\" class=\"note-color-reset btn btn-default\" data-event=\"removeFormat\" data-value=\"foreColor\">',\n                lang.color.resetToDefault,\n                '    </button>',\n                '  </div>',\n                '  <div class=\"note-holder\" data-event=\"foreColor\"/>',\n                '</div>',\n                '</li>'\n              ].join(''),\n              callback: function ($dropdown) {\n                $dropdown.find('.note-holder').each(function () {\n                  var $holder = $(this);\n                  $holder.append(ui.palette({\n                    colors: options.colors,\n                    eventName: $holder.data('event')\n                  }).render());\n                });\n              },\n              click: function (event) {\n                var $button = $(event.target);\n                var eventName = $button.data('event');\n                var value = $button.data('value');\n\n                if (eventName && value) {\n                  var key = eventName === 'backColor' ? 'background-color' : 'color';\n                  var $color = $button.closest('.note-color').find('.note-recent-color');\n                  var $currentButton = $button.closest('.note-color').find('.note-current-color-button');\n\n                  $color.css(key, value);\n                  $currentButton.attr('data-' + eventName, value);\n                  context.invoke('editor.' + eventName, value);\n                }\n              }\n            })\n          ]\n        }).render();\n      });\n\n      context.memo('button.ul',  function () {\n        return ui.button({\n          contents: ui.icon(options.icons.unorderedlist),\n          tooltip: lang.lists.unordered + representShortcut('insertUnorderedList'),\n          click: context.createInvokeHandler('editor.insertUnorderedList')\n        }).render();\n      });\n\n      context.memo('button.ol', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.orderedlist),\n          tooltip: lang.lists.ordered + representShortcut('insertOrderedList'),\n          click:  context.createInvokeHandler('editor.insertOrderedList')\n        }).render();\n      });\n\n      var justifyLeft = ui.button({\n        contents: ui.icon(options.icons.alignLeft),\n        tooltip: lang.paragraph.left + representShortcut('justifyLeft'),\n        click: context.createInvokeHandler('editor.justifyLeft')\n      });\n\n      var justifyCenter = ui.button({\n        contents: ui.icon(options.icons.alignCenter),\n        tooltip: lang.paragraph.center + representShortcut('justifyCenter'),\n        click: context.createInvokeHandler('editor.justifyCenter')\n      });\n\n      var justifyRight = ui.button({\n        contents: ui.icon(options.icons.alignRight),\n        tooltip: lang.paragraph.right + representShortcut('justifyRight'),\n        click: context.createInvokeHandler('editor.justifyRight')\n      });\n\n      var justifyFull = ui.button({\n        contents: ui.icon(options.icons.alignJustify),\n        tooltip: lang.paragraph.justify + representShortcut('justifyFull'),\n        click: context.createInvokeHandler('editor.justifyFull')\n      });\n\n      var outdent = ui.button({\n        contents: ui.icon(options.icons.outdent),\n        tooltip: lang.paragraph.outdent + representShortcut('outdent'),\n        click: context.createInvokeHandler('editor.outdent')\n      });\n\n      var indent = ui.button({\n        contents: ui.icon(options.icons.indent),\n        tooltip: lang.paragraph.indent + representShortcut('indent'),\n        click: context.createInvokeHandler('editor.indent')\n      });\n\n      context.memo('button.justifyLeft', func.invoke(justifyLeft, 'render'));\n      context.memo('button.justifyCenter', func.invoke(justifyCenter, 'render'));\n      context.memo('button.justifyRight', func.invoke(justifyRight, 'render'));\n      context.memo('button.justifyFull', func.invoke(justifyFull, 'render'));\n      context.memo('button.outdent', func.invoke(outdent, 'render'));\n      context.memo('button.indent', func.invoke(indent, 'render'));\n\n      context.memo('button.paragraph', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.alignLeft) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.paragraph.paragraph,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown([\n            ui.buttonGroup({\n              className: 'note-align',\n              children: [justifyLeft, justifyCenter, justifyRight, justifyFull]\n            }),\n            ui.buttonGroup({\n              className: 'note-list',\n              children: [outdent, indent]\n            })\n          ])\n        ]).render();\n      });\n\n      context.memo('button.height', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.textHeight) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.font.height,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            items: options.lineHeights,\n            checkClassName: options.icons.menuCheck,\n            className: 'dropdown-line-height',\n            click: context.createInvokeHandler('editor.lineHeight')\n          })\n        ]).render();\n      });\n\n      context.memo('button.table', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.table) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.table.table,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown({\n            className: 'note-table',\n            items: [\n              '<div class=\"note-dimension-picker\">',\n              '  <div class=\"note-dimension-picker-mousecatcher\" data-event=\"insertTable\" data-value=\"1x1\"/>',\n              '  <div class=\"note-dimension-picker-highlighted\"/>',\n              '  <div class=\"note-dimension-picker-unhighlighted\"/>',\n              '</div>',\n              '<div class=\"note-dimension-display\">1 x 1</div>'\n            ].join('')\n          })\n        ], {\n          callback: function ($node) {\n            var $catcher = $node.find('.note-dimension-picker-mousecatcher');\n            $catcher.css({\n              width: options.insertTableMaxSize.col + 'em',\n              height: options.insertTableMaxSize.row + 'em'\n            }).mousedown(context.createInvokeHandler('editor.insertTable'))\n              .on('mousemove', self.tableMoveHandler);\n          }\n        }).render();\n      });\n\n      context.memo('button.link', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.link),\n          tooltip: lang.link.link,\n          click: context.createInvokeHandler('linkDialog.show')\n        }).render();\n      });\n\n      context.memo('button.picture', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.picture),\n          tooltip: lang.image.image,\n          click: context.createInvokeHandler('imageDialog.show')\n        }).render();\n      });\n\n      context.memo('button.video', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.video),\n          tooltip: lang.video.video,\n          click: context.createInvokeHandler('videoDialog.show')\n        }).render();\n      });\n\n      context.memo('button.hr', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.minus),\n          tooltip: lang.hr.insert + representShortcut('insertHorizontalRule'),\n          click: context.createInvokeHandler('editor.insertHorizontalRule')\n        }).render();\n      });\n\n      context.memo('button.fullscreen', function () {\n        return ui.button({\n          className: 'btn-fullscreen',\n          contents: ui.icon(options.icons.arrowsAlt),\n          tooltip: lang.options.fullscreen,\n          click: context.createInvokeHandler('fullscreen.toggle')\n        }).render();\n      });\n\n      context.memo('button.codeview', function () {\n        return ui.button({\n          className: 'btn-codeview',\n          contents: ui.icon(options.icons.code),\n          tooltip: lang.options.codeview,\n          click: context.createInvokeHandler('codeview.toggle')\n        }).render();\n      });\n\n      context.memo('button.redo', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.redo),\n          tooltip: lang.history.redo + representShortcut('redo'),\n          click: context.createInvokeHandler('editor.redo')\n        }).render();\n      });\n\n      context.memo('button.undo', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.undo),\n          tooltip: lang.history.undo + representShortcut('undo'),\n          click: context.createInvokeHandler('editor.undo')\n        }).render();\n      });\n\n      context.memo('button.help', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.question),\n          tooltip: lang.options.help,\n          click: context.createInvokeHandler('helpDialog.show')\n        }).render();\n      });\n    };\n\n    /**\n     * image : [\n     *   ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],\n     *   ['float', ['floatLeft', 'floatRight', 'floatNone' ]],\n     *   ['remove', ['removeMedia']]\n     * ],\n     */\n    this.addImagePopoverButtons = function () {\n      // Image Size Buttons\n      context.memo('button.imageSize100', function () {\n        return ui.button({\n          contents: '<span class=\"note-fontsize-10\">100%</span>',\n          tooltip: lang.image.resizeFull,\n          click: context.createInvokeHandler('editor.resize', '1')\n        }).render();\n      });\n      context.memo('button.imageSize50', function () {\n        return  ui.button({\n          contents: '<span class=\"note-fontsize-10\">50%</span>',\n          tooltip: lang.image.resizeHalf,\n          click: context.createInvokeHandler('editor.resize', '0.5')\n        }).render();\n      });\n      context.memo('button.imageSize25', function () {\n        return ui.button({\n          contents: '<span class=\"note-fontsize-10\">25%</span>',\n          tooltip: lang.image.resizeQuarter,\n          click: context.createInvokeHandler('editor.resize', '0.25')\n        }).render();\n      });\n\n      // Float Buttons\n      context.memo('button.floatLeft', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignLeft),\n          tooltip: lang.image.floatLeft,\n          click: context.createInvokeHandler('editor.floatMe', 'left')\n        }).render();\n      });\n\n      context.memo('button.floatRight', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignRight),\n          tooltip: lang.image.floatRight,\n          click: context.createInvokeHandler('editor.floatMe', 'right')\n        }).render();\n      });\n\n      context.memo('button.floatNone', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignJustify),\n          tooltip: lang.image.floatNone,\n          click: context.createInvokeHandler('editor.floatMe', 'none')\n        }).render();\n      });\n\n      // Remove Buttons\n      context.memo('button.removeMedia', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.trash),\n          tooltip: lang.image.remove,\n          click: context.createInvokeHandler('editor.removeMedia')\n        }).render();\n      });\n    };\n\n    this.addLinkPopoverButtons = function () {\n      context.memo('button.linkDialogShow', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.link),\n          tooltip: lang.link.edit,\n          click: context.createInvokeHandler('linkDialog.show')\n        }).render();\n      });\n\n      context.memo('button.unlink', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.unlink),\n          tooltip: lang.link.unlink,\n          click: context.createInvokeHandler('editor.unlink')\n        }).render();\n      });\n    };\n\n    this.build = function ($container, groups) {\n      for (var groupIdx = 0, groupLen = groups.length; groupIdx < groupLen; groupIdx++) {\n        var group = groups[groupIdx];\n        var groupName = group[0];\n        var buttons = group[1];\n\n        var $group = ui.buttonGroup({\n          className: 'note-' + groupName\n        }).render();\n\n        for (var idx = 0, len = buttons.length; idx < len; idx++) {\n          var button = context.memo('button.' + buttons[idx]);\n          if (button) {\n            $group.append(typeof button === 'function' ? button(context) : button);\n          }\n        }\n        $group.appendTo($container);\n      }\n    };\n\n    this.updateCurrentStyle = function () {\n      var styleInfo = context.invoke('editor.currentStyle');\n      this.updateBtnStates({\n        '.note-btn-bold': function () {\n          return styleInfo['font-bold'] === 'bold';\n        },\n        '.note-btn-italic': function () {\n          return styleInfo['font-italic'] === 'italic';\n        },\n        '.note-btn-underline': function () {\n          return styleInfo['font-underline'] === 'underline';\n        },\n        '.note-btn-subscript': function () {\n          return styleInfo['font-subscript'] === 'subscript';\n        },\n        '.note-btn-superscript': function () {\n          return styleInfo['font-superscript'] === 'superscript';\n        },\n        '.note-btn-strikethrough': function () {\n          return styleInfo['font-strikethrough'] === 'strikethrough';\n        }\n      });\n\n      if (styleInfo['font-family']) {\n        var fontNames = styleInfo['font-family'].split(',').map(function (name) {\n          return name.replace(/[\\'\\\"]/g, '')\n            .replace(/\\s+$/, '')\n            .replace(/^\\s+/, '');\n        });\n        var fontName = list.find(fontNames, self.isFontInstalled);\n\n        $toolbar.find('.dropdown-fontname li a').each(function () {\n          // always compare string to avoid creating another func.\n          var isChecked = ($(this).data('value') + '') === (fontName + '');\n          this.className = isChecked ? 'checked' : '';\n        });\n        $toolbar.find('.note-current-fontname').text(fontName);\n      }\n\n      if (styleInfo['font-size']) {\n        var fontSize = styleInfo['font-size'];\n        $toolbar.find('.dropdown-fontsize li a').each(function () {\n          // always compare with string to avoid creating another func.\n          var isChecked = ($(this).data('value') + '') === (fontSize + '');\n          this.className = isChecked ? 'checked' : '';\n        });\n        $toolbar.find('.note-current-fontsize').text(fontSize);\n      }\n\n      if (styleInfo['line-height']) {\n        var lineHeight = styleInfo['line-height'];\n        $toolbar.find('.dropdown-line-height li a').each(function () {\n          // always compare with string to avoid creating another func.\n          var isChecked = ($(this).data('value') + '') === (lineHeight + '');\n          this.className = isChecked ? 'checked' : '';\n        });\n      }\n    };\n\n    this.updateBtnStates = function (infos) {\n      $.each(infos, function (selector, pred) {\n        ui.toggleBtnActive($toolbar.find(selector), pred());\n      });\n    };\n\n    this.tableMoveHandler = function (event) {\n      var PX_PER_EM = 18;\n      var $picker = $(event.target.parentNode); // target is mousecatcher\n      var $dimensionDisplay = $picker.next();\n      var $catcher = $picker.find('.note-dimension-picker-mousecatcher');\n      var $highlighted = $picker.find('.note-dimension-picker-highlighted');\n      var $unhighlighted = $picker.find('.note-dimension-picker-unhighlighted');\n\n      var posOffset;\n      // HTML5 with jQuery - e.offsetX is undefined in Firefox\n      if (event.offsetX === undefined) {\n        var posCatcher = $(event.target).offset();\n        posOffset = {\n          x: event.pageX - posCatcher.left,\n          y: event.pageY - posCatcher.top\n        };\n      } else {\n        posOffset = {\n          x: event.offsetX,\n          y: event.offsetY\n        };\n      }\n\n      var dim = {\n        c: Math.ceil(posOffset.x / PX_PER_EM) || 1,\n        r: Math.ceil(posOffset.y / PX_PER_EM) || 1\n      };\n\n      $highlighted.css({ width: dim.c + 'em', height: dim.r + 'em' });\n      $catcher.data('value', dim.c + 'x' + dim.r);\n\n      if (3 < dim.c && dim.c < options.insertTableMaxSize.col) {\n        $unhighlighted.css({ width: dim.c + 1 + 'em'});\n      }\n\n      if (3 < dim.r && dim.r < options.insertTableMaxSize.row) {\n        $unhighlighted.css({ height: dim.r + 1 + 'em'});\n      }\n\n      $dimensionDisplay.html(dim.c + ' x ' + dim.r);\n    };\n  };\n\n  var Toolbar = function (context) {\n    var ui = $.summernote.ui;\n\n    var $note = context.layoutInfo.note;\n    var $toolbar = context.layoutInfo.toolbar;\n    var options = context.options;\n\n    this.shouldInitialize = function () {\n      return !options.airMode;\n    };\n\n    this.initialize = function () {\n      options.toolbar = options.toolbar || [];\n\n      if (!options.toolbar.length) {\n        $toolbar.hide();\n      } else {\n        context.invoke('buttons.build', $toolbar, options.toolbar);\n      }\n\n      if (options.toolbarContainer) {\n        $toolbar.appendTo(options.toolbarContainer);\n      }\n\n      $note.on('summernote.keyup summernote.mouseup summernote.change', function () {\n        context.invoke('buttons.updateCurrentStyle');\n      });\n\n      context.invoke('buttons.updateCurrentStyle');\n    };\n\n    this.destroy = function () {\n      $toolbar.children().remove();\n    };\n\n    this.updateFullscreen = function (isFullscreen) {\n      ui.toggleBtnActive($toolbar.find('.btn-fullscreen'), isFullscreen);\n    };\n\n    this.updateCodeview = function (isCodeview) {\n      ui.toggleBtnActive($toolbar.find('.btn-codeview'), isCodeview);\n      if (isCodeview) {\n        this.deactivate();\n      } else {\n        this.activate();\n      }\n    };\n\n    this.activate = function (isIncludeCodeview) {\n      var $btn = $toolbar.find('button');\n      if (!isIncludeCodeview) {\n        $btn = $btn.not('.btn-codeview');\n      }\n      ui.toggleBtn($btn, true);\n    };\n\n    this.deactivate = function (isIncludeCodeview) {\n      var $btn = $toolbar.find('button');\n      if (!isIncludeCodeview) {\n        $btn = $btn.not('.btn-codeview');\n      }\n      ui.toggleBtn($btn, false);\n    };\n  };\n\n  var LinkDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = '<div class=\"form-group\">' +\n                   '<label>' + lang.link.textToDisplay + '</label>' +\n                   '<input class=\"note-link-text form-control\" type=\"text\" />' +\n                 '</div>' +\n                 '<div class=\"form-group\">' +\n                   '<label>' + lang.link.url + '</label>' +\n                   '<input class=\"note-link-url form-control\" type=\"text\" value=\"http://\" />' +\n                 '</div>' +\n                 (!options.disableLinkTarget ?\n                   '<div class=\"checkbox\">' +\n                     '<label>' + '<input type=\"checkbox\" checked> ' + lang.link.openInNewWindow + '</label>' +\n                   '</div>' : ''\n                 );\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-link-btn disabled\" disabled>' + lang.link.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        className: 'link-dialog',\n        title: lang.link.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    /**\n     * Show link dialog and set event handlers on dialog controls.\n     *\n     * @param {Object} linkInfo\n     * @return {Promise}\n     */\n    this.showLinkDialog = function (linkInfo) {\n      return $.Deferred(function (deferred) {\n        var $linkText = self.$dialog.find('.note-link-text'),\n        $linkUrl = self.$dialog.find('.note-link-url'),\n        $linkBtn = self.$dialog.find('.note-link-btn'),\n        $openInNewWindow = self.$dialog.find('input[type=checkbox]');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          $linkText.val(linkInfo.text);\n\n          $linkText.on('input', function () {\n            ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());\n            // if linktext was modified by keyup,\n            // stop cloning text from linkUrl\n            linkInfo.text = $linkText.val();\n          });\n\n          // if no url was given, copy text to url\n          if (!linkInfo.url) {\n            linkInfo.url = linkInfo.text || 'http://';\n            ui.toggleBtn($linkBtn, linkInfo.text);\n          }\n\n          $linkUrl.on('input', function () {\n            ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());\n            // display same link on `Text to display` input\n            // when create a new link\n            if (!linkInfo.text) {\n              $linkText.val($linkUrl.val());\n            }\n          }).val(linkInfo.url).trigger('focus');\n\n          self.bindEnterKey($linkUrl, $linkBtn);\n          self.bindEnterKey($linkText, $linkBtn);\n\n          $openInNewWindow.prop('checked', linkInfo.isNewWindow);\n\n          $linkBtn.one('click', function (event) {\n            event.preventDefault();\n\n            deferred.resolve({\n              range: linkInfo.range,\n              url: $linkUrl.val(),\n              text: $linkText.val(),\n              isNewWindow: $openInNewWindow.is(':checked')\n            });\n            self.$dialog.modal('hide');\n          });\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          // detach events\n          $linkText.off('input keypress');\n          $linkUrl.off('input keypress');\n          $linkBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      }).promise();\n    };\n\n    /**\n     * @param {Object} layoutInfo\n     */\n    this.show = function () {\n      var linkInfo = context.invoke('editor.getLinkInfo');\n\n      context.invoke('editor.saveRange');\n      this.showLinkDialog(linkInfo).then(function (linkInfo) {\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.createLink', linkInfo);\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n    context.memo('help.linkDialog.show', options.langInfo.help['linkDialog.show']);\n  };\n\n  var LinkPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    this.events = {\n      'summernote.keyup summernote.mouseup summernote.change summernote.scroll': function () {\n        self.update();\n      },\n      'summernote.dialog.shown': function () {\n        self.hide();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return !list.isEmpty(options.popover.link);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-link-popover',\n        callback: function ($node) {\n          var $content = $node.find('.popover-content');\n          $content.prepend('<span><a target=\"_blank\"></a>&nbsp;</span>');\n        }\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.link);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function () {\n      // Prevent focusing on editable when invoke('code') is executed\n      if (!context.invoke('editor.hasFocus')) {\n        this.hide();\n        return;\n      }\n\n      var rng = context.invoke('editor.createRange');\n      if (rng.isCollapsed() && rng.isOnAnchor()) {\n        var anchor = dom.ancestor(rng.sc, dom.isAnchor);\n        var href = $(anchor).attr('href');\n        this.$popover.find('a').attr('href', href).html(href);\n\n        var pos = dom.posFromPlaceholder(anchor);\n        this.$popover.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top\n        });\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var ImageDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var imageLimitation = '';\n      if (options.maximumImageFileSize) {\n        var unit = Math.floor(Math.log(options.maximumImageFileSize) / Math.log(1024));\n        var readableSize = (options.maximumImageFileSize / Math.pow(1024, unit)).toFixed(2) * 1 +\n                           ' ' + ' KMGTP'[unit] + 'B';\n        imageLimitation = '<small>' + lang.image.maximumFileSize + ' : ' + readableSize + '</small>';\n      }\n\n      var body = '<div class=\"form-group note-group-select-from-files\">' +\n                   '<label>' + lang.image.selectFromFiles + '</label>' +\n                   '<input class=\"note-image-input form-control\" type=\"file\" name=\"files\" accept=\"image/*\" multiple=\"multiple\" />' +\n                   imageLimitation +\n                 '</div>' +\n                 '<div class=\"form-group\" style=\"overflow:auto;\">' +\n                   '<label>' + lang.image.url + '</label>' +\n                   '<input class=\"note-image-url form-control col-md-12\" type=\"text\" />' +\n                 '</div>';\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-image-btn disabled\" disabled>' + lang.image.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        title: lang.image.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    this.show = function () {\n      context.invoke('editor.saveRange');\n      this.showImageDialog().then(function (data) {\n        // [workaround] hide dialog before restore range for IE range focus\n        ui.hideDialog(self.$dialog);\n        context.invoke('editor.restoreRange');\n\n        if (typeof data === 'string') { // image url\n          context.invoke('editor.insertImage', data);\n        } else { // array of files\n          context.invoke('editor.insertImagesOrCallback', data);\n        }\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n\n    /**\n     * show image dialog\n     *\n     * @param {jQuery} $dialog\n     * @return {Promise}\n     */\n    this.showImageDialog = function () {\n      return $.Deferred(function (deferred) {\n        var $imageInput = self.$dialog.find('.note-image-input'),\n            $imageUrl = self.$dialog.find('.note-image-url'),\n            $imageBtn = self.$dialog.find('.note-image-btn');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          // Cloning imageInput to clear element.\n          $imageInput.replaceWith($imageInput.clone()\n            .on('change', function () {\n              deferred.resolve(this.files || this.value);\n            })\n            .val('')\n          );\n\n          $imageBtn.click(function (event) {\n            event.preventDefault();\n\n            deferred.resolve($imageUrl.val());\n          });\n\n          $imageUrl.on('keyup paste', function () {\n            var url = $imageUrl.val();\n            ui.toggleBtn($imageBtn, url);\n          }).val('').trigger('focus');\n          self.bindEnterKey($imageUrl, $imageBtn);\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          $imageInput.off('change');\n          $imageUrl.off('keyup paste keypress');\n          $imageBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      });\n    };\n  };\n\n  var ImagePopover = function (context) {\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    this.shouldInitialize = function () {\n      return !list.isEmpty(options.popover.image);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-image-popover'\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.image);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function (target) {\n      if (dom.isImg(target)) {\n        var pos = dom.posFromPlaceholder(target);\n        this.$popover.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top\n        });\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var VideoDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = '<div class=\"form-group row-fluid\">' +\n          '<label>' + lang.video.url + ' <small class=\"text-muted\">' + lang.video.providers + '</small></label>' +\n          '<input class=\"note-video-url form-control span12\" type=\"text\" />' +\n          '</div>';\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-video-btn disabled\" disabled>' + lang.video.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        title: lang.video.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    this.createVideoNode = function (url) {\n      // video url patterns(youtube, instagram, vimeo, dailymotion, youku, mp4, ogg, webm)\n      var ytRegExp = /^(?:https?:\\/\\/)?(?:www\\.)?(?:youtu\\.be\\/|youtube\\.com\\/(?:embed\\/|v\\/|watch\\?v=|watch\\?.+&v=))((\\w|-){11})(?:\\S+)?$/;\n      var ytMatch = url.match(ytRegExp);\n\n      var igRegExp = /\\/\\/instagram.com\\/p\\/(.[a-zA-Z0-9_-]*)/;\n      var igMatch = url.match(igRegExp);\n\n      var vRegExp = /\\/\\/vine.co\\/v\\/(.[a-zA-Z0-9]*)/;\n      var vMatch = url.match(vRegExp);\n\n      var vimRegExp = /\\/\\/(player.)?vimeo.com\\/([a-z]*\\/)*([0-9]{6,11})[?]?.*/;\n      var vimMatch = url.match(vimRegExp);\n\n      var dmRegExp = /.+dailymotion.com\\/(video|hub)\\/([^_]+)[^#]*(#video=([^_&]+))?/;\n      var dmMatch = url.match(dmRegExp);\n\n      var youkuRegExp = /\\/\\/v\\.youku\\.com\\/v_show\\/id_(\\w+)=*\\.html/;\n      var youkuMatch = url.match(youkuRegExp);\n\n      var mp4RegExp = /^.+.(mp4|m4v)$/;\n      var mp4Match = url.match(mp4RegExp);\n\n      var oggRegExp = /^.+.(ogg|ogv)$/;\n      var oggMatch = url.match(oggRegExp);\n\n      var webmRegExp = /^.+.(webm)$/;\n      var webmMatch = url.match(webmRegExp);\n\n      var $video;\n      if (ytMatch && ytMatch[1].length === 11) {\n        var youtubeId = ytMatch[1];\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', '//www.youtube.com/embed/' + youtubeId)\n            .attr('width', '640').attr('height', '360');\n      } else if (igMatch && igMatch[0].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', igMatch[0] + '/embed/')\n            .attr('width', '612').attr('height', '710')\n            .attr('scrolling', 'no')\n            .attr('allowtransparency', 'true');\n      } else if (vMatch && vMatch[0].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', vMatch[0] + '/embed/simple')\n            .attr('width', '600').attr('height', '600')\n            .attr('class', 'vine-embed');\n      } else if (vimMatch && vimMatch[3].length) {\n        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n            .attr('frameborder', 0)\n            .attr('src', '//player.vimeo.com/video/' + vimMatch[3])\n            .attr('width', '640').attr('height', '360');\n      } else if (dmMatch && dmMatch[2].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', '//www.dailymotion.com/embed/video/' + dmMatch[2])\n            .attr('width', '640').attr('height', '360');\n      } else if (youkuMatch && youkuMatch[1].length) {\n        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n            .attr('frameborder', 0)\n            .attr('height', '498')\n            .attr('width', '510')\n            .attr('src', '//player.youku.com/embed/' + youkuMatch[1]);\n      } else if (mp4Match || oggMatch || webmMatch) {\n        $video = $('<video controls>')\n            .attr('src', url)\n            .attr('width', '640').attr('height', '360');\n      } else {\n        // this is not a known video link. Now what, Cat? Now what?\n        return false;\n      }\n\n      $video.addClass('note-video-clip');\n\n      return $video[0];\n    };\n\n    this.show = function () {\n      var text = context.invoke('editor.getSelectedText');\n      context.invoke('editor.saveRange');\n      this.showVideoDialog(text).then(function (url) {\n        // [workaround] hide dialog before restore range for IE range focus\n        ui.hideDialog(self.$dialog);\n        context.invoke('editor.restoreRange');\n\n        // build node\n        var $node = self.createVideoNode(url);\n\n        if ($node) {\n          // insert video node\n          context.invoke('editor.insertNode', $node);\n        }\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n\n    /**\n     * show image dialog\n     *\n     * @param {jQuery} $dialog\n     * @return {Promise}\n     */\n    this.showVideoDialog = function (text) {\n      return $.Deferred(function (deferred) {\n        var $videoUrl = self.$dialog.find('.note-video-url'),\n            $videoBtn = self.$dialog.find('.note-video-btn');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          $videoUrl.val(text).on('input', function () {\n            ui.toggleBtn($videoBtn, $videoUrl.val());\n          }).trigger('focus');\n\n          $videoBtn.click(function (event) {\n            event.preventDefault();\n\n            deferred.resolve($videoUrl.val());\n          });\n\n          self.bindEnterKey($videoUrl, $videoBtn);\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          $videoUrl.off('input');\n          $videoBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      });\n    };\n  };\n\n  var HelpDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.createShortCutList = function () {\n      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n      return Object.keys(keyMap).map(function (key) {\n        var command = keyMap[key];\n        var $row = $('<div><div class=\"help-list-item\"/></div>');\n        $row.append($('<label><kbd>' + key + '</kdb></label>').css({\n          'width': 180,\n          'margin-right': 10\n        })).append($('<span/>').html(context.memo('help.' + command) || command));\n        return $row.html();\n      }).join('');\n    };\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = [\n        '<p class=\"text-center\">',\n        '<a href=\"//summernote.org/\" target=\"_blank\">Summernote 0.8.1</a> · ',\n        '<a href=\"//github.com/summernote/summernote\" target=\"_blank\">Project</a> · ',\n        '<a href=\"//github.com/summernote/summernote/issues\" target=\"_blank\">Issues</a>',\n        '</p>'\n      ].join('');\n\n      this.$dialog = ui.dialog({\n        title: lang.options.help,\n        fade: options.dialogsFade,\n        body: this.createShortCutList(),\n        footer: body,\n        callback: function ($node) {\n          $node.find('.modal-body').css({\n            'max-height': 300,\n            'overflow': 'scroll'\n          });\n        }\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    /**\n     * show help dialog\n     *\n     * @return {Promise}\n     */\n    this.showHelpDialog = function () {\n      return $.Deferred(function (deferred) {\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n          deferred.resolve();\n        });\n        ui.showDialog(self.$dialog);\n      }).promise();\n    };\n\n    this.show = function () {\n      context.invoke('editor.saveRange');\n      this.showHelpDialog().then(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n  };\n\n  var AirPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    var AIR_MODE_POPOVER_X_OFFSET = 20;\n\n    this.events = {\n      'summernote.keyup summernote.mouseup summernote.scroll': function () {\n        self.update();\n      },\n      'summernote.change summernote.dialog.shown': function () {\n        self.hide();\n      },\n      'summernote.focusout': function (we, e) {\n        // [workaround] Firefox doesn't support relatedTarget on focusout\n        //  - Ignore hide action on focus out in FF.\n        if (agent.isFF) {\n          return;\n        }\n\n        if (!e.relatedTarget || !dom.ancestor(e.relatedTarget, func.eq(self.$popover[0]))) {\n          self.hide();\n        }\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return options.airMode && !list.isEmpty(options.popover.air);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-air-popover'\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.air);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function () {\n      var styleInfo = context.invoke('editor.currentStyle');\n      if (styleInfo.range && !styleInfo.range.isCollapsed()) {\n        var rect = list.last(styleInfo.range.getClientRects());\n        if (rect) {\n          var bnd = func.rect2bnd(rect);\n          this.$popover.css({\n            display: 'block',\n            left: Math.max(bnd.left + bnd.width / 2, 0) - AIR_MODE_POPOVER_X_OFFSET,\n            top: bnd.top + bnd.height\n          });\n        }\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var HintPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var POPOVER_DIST = 5;\n    var hint = context.options.hint || [];\n    var direction = context.options.hintDirection || 'bottom';\n    var hints = $.isArray(hint) ? hint : [hint];\n\n    this.events = {\n      'summernote.keyup': function (we, e) {\n        if (!e.isDefaultPrevented()) {\n          self.handleKeyup(e);\n        }\n      },\n      'summernote.keydown': function (we, e) {\n        self.handleKeydown(e);\n      },\n      'summernote.dialog.shown': function () {\n        self.hide();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return hints.length > 0;\n    };\n\n    this.initialize = function () {\n      this.lastWordRange = null;\n      this.$popover = ui.popover({\n        className: 'note-hint-popover',\n        hideArrow: true,\n        direction: ''\n      }).render().appendTo('body');\n\n      this.$popover.hide();\n\n      this.$content = this.$popover.find('.popover-content');\n\n      this.$content.on('click', '.note-hint-item', function () {\n        self.$content.find('.active').removeClass('active');\n        $(this).addClass('active');\n        self.replace();\n      });\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.selectItem = function ($item) {\n      this.$content.find('.active').removeClass('active');\n      $item.addClass('active');\n\n      this.$content[0].scrollTop = $item[0].offsetTop - (this.$content.innerHeight() / 2);\n    };\n\n    this.moveDown = function () {\n      var $current = this.$content.find('.note-hint-item.active');\n      var $next = $current.next();\n\n      if ($next.length) {\n        this.selectItem($next);\n      } else {\n        var $nextGroup = $current.parent().next();\n\n        if (!$nextGroup.length) {\n          $nextGroup = this.$content.find('.note-hint-group').first();\n        }\n\n        this.selectItem($nextGroup.find('.note-hint-item').first());\n      }\n    };\n\n    this.moveUp = function () {\n      var $current = this.$content.find('.note-hint-item.active');\n      var $prev = $current.prev();\n\n      if ($prev.length) {\n        this.selectItem($prev);\n      } else {\n        var $prevGroup = $current.parent().prev();\n\n        if (!$prevGroup.length) {\n          $prevGroup = this.$content.find('.note-hint-group').last();\n        }\n\n        this.selectItem($prevGroup.find('.note-hint-item').last());\n      }\n    };\n\n    this.replace = function () {\n      var $item = this.$content.find('.note-hint-item.active');\n\n      if ($item.length) {\n        var node = this.nodeFromItem($item);\n        this.lastWordRange.insertNode(node);\n        range.createFromNode(node).collapse().select();\n\n        this.lastWordRange = null;\n        this.hide();\n        context.invoke('editor.focus');\n      }\n\n    };\n\n    this.nodeFromItem = function ($item) {\n      var hint = hints[$item.data('index')];\n      var item = $item.data('item');\n      var node = hint.content ? hint.content(item) : item;\n      if (typeof node === 'string') {\n        node = dom.createText(node);\n      }\n      return node;\n    };\n\n    this.createItemTemplates = function (hintIdx, items) {\n      var hint = hints[hintIdx];\n      return items.map(function (item, idx) {\n        var $item = $('<div class=\"note-hint-item\"/>');\n        $item.append(hint.template ? hint.template(item) : item + '');\n        $item.data({\n          'index': hintIdx,\n          'item': item\n        });\n\n        if (hintIdx === 0 && idx === 0) {\n          $item.addClass('active');\n        }\n        return $item;\n      });\n    };\n\n    this.handleKeydown = function (e) {\n      if (!this.$popover.is(':visible')) {\n        return;\n      }\n\n      if (e.keyCode === key.code.ENTER) {\n        e.preventDefault();\n        this.replace();\n      } else if (e.keyCode === key.code.UP) {\n        e.preventDefault();\n        this.moveUp();\n      } else if (e.keyCode === key.code.DOWN) {\n        e.preventDefault();\n        this.moveDown();\n      }\n    };\n\n    this.searchKeyword = function (index, keyword, callback) {\n      var hint = hints[index];\n      if (hint && hint.match.test(keyword) && hint.search) {\n        var matches = hint.match.exec(keyword);\n        hint.search(matches[1], callback);\n      } else {\n        callback();\n      }\n    };\n\n    this.createGroup = function (idx, keyword) {\n      var $group = $('<div class=\"note-hint-group note-hint-group-' + idx + '\"/>');\n      this.searchKeyword(idx, keyword, function (items) {\n        items = items || [];\n        if (items.length) {\n          $group.html(self.createItemTemplates(idx, items));\n          self.show();\n        }\n      });\n\n      return $group;\n    };\n\n    this.handleKeyup = function (e) {\n      if (list.contains([key.code.ENTER, key.code.UP, key.code.DOWN], e.keyCode)) {\n        if (e.keyCode === key.code.ENTER) {\n          if (this.$popover.is(':visible')) {\n            return;\n          }\n        }\n      } else {\n        var wordRange = context.invoke('editor.createRange').getWordRange();\n        var keyword = wordRange.toString();\n        if (hints.length && keyword) {\n          this.$content.empty();\n\n          var bnd = func.rect2bnd(list.last(wordRange.getClientRects()));\n          if (bnd) {\n\n            this.$popover.hide();\n\n            this.lastWordRange = wordRange;\n\n            hints.forEach(function (hint, idx) {\n              if (hint.match.test(keyword)) {\n                self.createGroup(idx, keyword).appendTo(self.$content);\n              }\n            });\n\n            // set position for popover after group is created\n            if (direction === 'top') {\n              this.$popover.css({\n                left: bnd.left,\n                top: bnd.top - this.$popover.outerHeight() - POPOVER_DIST\n              });\n            } else {\n              this.$popover.css({\n                left: bnd.left,\n                top: bnd.top + bnd.height + POPOVER_DIST\n              });\n            }\n\n          }\n        } else {\n          this.hide();\n        }\n      }\n    };\n\n    this.show = function () {\n      this.$popover.show();\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n\n  $.summernote = $.extend($.summernote, {\n    version: '0.8.1',\n    ui: ui,\n\n    plugins: {},\n\n    options: {\n      modules: {\n        'editor': Editor,\n        'clipboard': Clipboard,\n        'dropzone': Dropzone,\n        'codeview': Codeview,\n        'statusbar': Statusbar,\n        'fullscreen': Fullscreen,\n        'handle': Handle,\n        // FIXME: HintPopover must be front of autolink\n        //  - Script error about range when Enter key is pressed on hint popover\n        'hintPopover': HintPopover,\n        'autoLink': AutoLink,\n        'autoSync': AutoSync,\n        'placeholder': Placeholder,\n        'buttons': Buttons,\n        'toolbar': Toolbar,\n        'linkDialog': LinkDialog,\n        'linkPopover': LinkPopover,\n        'imageDialog': ImageDialog,\n        'imagePopover': ImagePopover,\n        'videoDialog': VideoDialog,\n        'helpDialog': HelpDialog,\n        'airPopover': AirPopover\n      },\n\n      buttons: {},\n      \n      lang: 'en-US',\n\n      // toolbar\n      toolbar: [\n        ['style', ['style']],\n        ['font', ['bold', 'underline', 'clear']],\n        ['fontname', ['fontname']],\n        ['color', ['color']],\n        ['para', ['ul', 'ol', 'paragraph']],\n        ['table', ['table']],\n        ['insert', ['link', 'picture', 'video']],\n        ['view', ['fullscreen', 'codeview', 'help']]\n      ],\n\n      // popover\n      popover: {\n        image: [\n          ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],\n          ['float', ['floatLeft', 'floatRight', 'floatNone']],\n          ['remove', ['removeMedia']]\n        ],\n        link: [\n          ['link', ['linkDialogShow', 'unlink']]\n        ],\n        air: [\n          ['color', ['color']],\n          ['font', ['bold', 'underline', 'clear']],\n          ['para', ['ul', 'paragraph']],\n          ['table', ['table']],\n          ['insert', ['link', 'picture']]\n        ]\n      },\n\n      // air mode: inline editor\n      airMode: false,\n\n      width: null,\n      height: null,\n\n      focus: false,\n      tabSize: 4,\n      styleWithSpan: true,\n      shortcuts: true,\n      textareaAutoSync: true,\n      direction: null,\n\n      styleTags: ['p', 'blockquote', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\n\n      fontNames: [\n        'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New',\n        'Helvetica Neue', 'Helvetica', 'Impact', 'Lucida Grande',\n        'Tahoma', 'Times New Roman', 'Verdana'\n      ],\n\n      fontSizes: ['8', '9', '10', '11', '12', '14', '18', '24', '36'],\n\n      // pallete colors(n x n)\n      colors: [\n        ['#000000', '#424242', '#636363', '#9C9C94', '#CEC6CE', '#EFEFEF', '#F7F7F7', '#FFFFFF'],\n        ['#FF0000', '#FF9C00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#9C00FF', '#FF00FF'],\n        ['#F7C6CE', '#FFE7CE', '#FFEFC6', '#D6EFD6', '#CEDEE7', '#CEE7F7', '#D6D6E7', '#E7D6DE'],\n        ['#E79C9C', '#FFC69C', '#FFE79C', '#B5D6A5', '#A5C6CE', '#9CC6EF', '#B5A5D6', '#D6A5BD'],\n        ['#E76363', '#F7AD6B', '#FFD663', '#94BD7B', '#73A5AD', '#6BADDE', '#8C7BC6', '#C67BA5'],\n        ['#CE0000', '#E79439', '#EFC631', '#6BA54A', '#4A7B8C', '#3984C6', '#634AA5', '#A54A7B'],\n        ['#9C0000', '#B56308', '#BD9400', '#397B21', '#104A5A', '#085294', '#311873', '#731842'],\n        ['#630000', '#7B3900', '#846300', '#295218', '#083139', '#003163', '#21104A', '#4A1031']\n      ],\n\n      lineHeights: ['1.0', '1.2', '1.4', '1.5', '1.6', '1.8', '2.0', '3.0'],\n\n      tableClassName: 'table table-bordered',\n\n      insertTableMaxSize: {\n        col: 10,\n        row: 10\n      },\n\n      dialogsInBody: false,\n      dialogsFade: false,\n\n      maximumImageFileSize: null,\n\n      callbacks: {\n        onInit: null,\n        onFocus: null,\n        onBlur: null,\n        onEnter: null,\n        onKeyup: null,\n        onKeydown: null,\n        onSubmit: null,\n        onImageUpload: null,\n        onImageUploadError: null\n      },\n\n      codemirror: {\n        mode: 'text/html',\n        htmlMode: true,\n        lineNumbers: true\n      },\n\n      keyMap: {\n        pc: {\n          'ENTER': 'insertParagraph',\n          'CTRL+Z': 'undo',\n          'CTRL+Y': 'redo',\n          'TAB': 'tab',\n          'SHIFT+TAB': 'untab',\n          'CTRL+B': 'bold',\n          'CTRL+I': 'italic',\n          'CTRL+U': 'underline',\n          'CTRL+SHIFT+S': 'strikethrough',\n          'CTRL+BACKSLASH': 'removeFormat',\n          'CTRL+SHIFT+L': 'justifyLeft',\n          'CTRL+SHIFT+E': 'justifyCenter',\n          'CTRL+SHIFT+R': 'justifyRight',\n          'CTRL+SHIFT+J': 'justifyFull',\n          'CTRL+SHIFT+NUM7': 'insertUnorderedList',\n          'CTRL+SHIFT+NUM8': 'insertOrderedList',\n          'CTRL+LEFTBRACKET': 'outdent',\n          'CTRL+RIGHTBRACKET': 'indent',\n          'CTRL+NUM0': 'formatPara',\n          'CTRL+NUM1': 'formatH1',\n          'CTRL+NUM2': 'formatH2',\n          'CTRL+NUM3': 'formatH3',\n          'CTRL+NUM4': 'formatH4',\n          'CTRL+NUM5': 'formatH5',\n          'CTRL+NUM6': 'formatH6',\n          'CTRL+ENTER': 'insertHorizontalRule',\n          'CTRL+K': 'linkDialog.show'\n        },\n\n        mac: {\n          'ENTER': 'insertParagraph',\n          'CMD+Z': 'undo',\n          'CMD+SHIFT+Z': 'redo',\n          'TAB': 'tab',\n          'SHIFT+TAB': 'untab',\n          'CMD+B': 'bold',\n          'CMD+I': 'italic',\n          'CMD+U': 'underline',\n          'CMD+SHIFT+S': 'strikethrough',\n          'CMD+BACKSLASH': 'removeFormat',\n          'CMD+SHIFT+L': 'justifyLeft',\n          'CMD+SHIFT+E': 'justifyCenter',\n          'CMD+SHIFT+R': 'justifyRight',\n          'CMD+SHIFT+J': 'justifyFull',\n          'CMD+SHIFT+NUM7': 'insertUnorderedList',\n          'CMD+SHIFT+NUM8': 'insertOrderedList',\n          'CMD+LEFTBRACKET': 'outdent',\n          'CMD+RIGHTBRACKET': 'indent',\n          'CMD+NUM0': 'formatPara',\n          'CMD+NUM1': 'formatH1',\n          'CMD+NUM2': 'formatH2',\n          'CMD+NUM3': 'formatH3',\n          'CMD+NUM4': 'formatH4',\n          'CMD+NUM5': 'formatH5',\n          'CMD+NUM6': 'formatH6',\n          'CMD+ENTER': 'insertHorizontalRule',\n          'CMD+K': 'linkDialog.show'\n        }\n      },\n      icons: {\n        'align': 'note-icon-align',\n        'alignCenter': 'note-icon-align-center',\n        'alignJustify': 'note-icon-align-justify',\n        'alignLeft': 'note-icon-align-left',\n        'alignRight': 'note-icon-align-right',\n        'indent': 'note-icon-align-indent',\n        'outdent': 'note-icon-align-outdent',\n        'arrowsAlt': 'note-icon-arrows-alt',\n        'bold': 'note-icon-bold',\n        'caret': 'note-icon-caret',\n        'circle': 'note-icon-circle',\n        'close': 'note-icon-close',\n        'code': 'note-icon-code',\n        'eraser': 'note-icon-eraser',\n        'font': 'note-icon-font',\n        'frame': 'note-icon-frame',\n        'italic': 'note-icon-italic',\n        'link': 'note-icon-link',\n        'unlink': 'note-icon-chain-broken',\n        'magic': 'note-icon-magic',\n        'menuCheck': 'note-icon-check',\n        'minus': 'note-icon-minus',\n        'orderedlist': 'note-icon-orderedlist',\n        'pencil': 'note-icon-pencil',\n        'picture': 'note-icon-picture',\n        'question': 'note-icon-question',\n        'redo': 'note-icon-redo',\n        'square': 'note-icon-square',\n        'strikethrough': 'note-icon-strikethrough',\n        'subscript': 'note-icon-subscript',\n        'superscript': 'note-icon-superscript',\n        'table': 'note-icon-table',\n        'textHeight': 'note-icon-text-height',\n        'trash': 'note-icon-trash',\n        'underline': 'note-icon-underline',\n        'undo': 'note-icon-undo',\n        'unorderedlist': 'note-icon-unorderedlist',\n        'video': 'note-icon-video'\n      }\n    }\n  });\n\n}));\n\n\n/***/ }),\n\n/***/ 180:\n/***/ (function(module, exports) {\n\n/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// 3.js","import sn from 'summernote-webpack';\n\nclass SummerNote {\n    constructor() {\n        $('.summernote').summernote({\n            height: 400\n        });\n    }\n}\n\nexport default SummerNote;\n\n\n\n// WEBPACK FOOTER //\n// ./www/src/js/summernote.js","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// This is CodeMirror (http://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.CodeMirror = factory());\n}(this, (function () { 'use strict';\n\n// Kludges for bugs and behavior differences that can't be feature\n// detected are enabled based on userAgent etc sniffing.\nvar userAgent = navigator.userAgent;\nvar platform = navigator.platform;\n\nvar gecko = /gecko\\/\\d/i.test(userAgent);\nvar ie_upto10 = /MSIE \\d/.test(userAgent);\nvar ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\nvar edge = /Edge\\/(\\d+)/.exec(userAgent);\nvar ie = ie_upto10 || ie_11up || edge;\nvar ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\nvar webkit = !edge && /WebKit\\//.test(userAgent);\nvar qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\nvar chrome = !edge && /Chrome\\//.test(userAgent);\nvar presto = /Opera\\//.test(userAgent);\nvar safari = /Apple Computer/.test(navigator.vendor);\nvar mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\nvar phantom = /PhantomJS/.test(userAgent);\n\nvar ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\nvar android = /Android/.test(userAgent);\n// This is woefully incomplete. Suggestions for alternative methods welcome.\nvar mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\nvar mac = ios || /Mac/.test(platform);\nvar chromeOS = /\\bCrOS\\b/.test(userAgent);\nvar windows = /win/i.test(platform);\n\nvar presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\nif (presto_version) { presto_version = Number(presto_version[1]); }\nif (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n// Some browsers use the wrong event properties to signal cmd/ctrl on OS X\nvar flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\nvar captureRightClick = gecko || (ie && ie_version >= 9);\n\nfunction classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\n\nvar rmClass = function(node, cls) {\n  var current = node.className;\n  var match = classTest(cls).exec(current);\n  if (match) {\n    var after = current.slice(match.index + match[0].length);\n    node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n  }\n};\n\nfunction removeChildren(e) {\n  for (var count = e.childNodes.length; count > 0; --count)\n    { e.removeChild(e.firstChild); }\n  return e\n}\n\nfunction removeChildrenAndAdd(parent, e) {\n  return removeChildren(parent).appendChild(e)\n}\n\nfunction elt(tag, content, className, style) {\n  var e = document.createElement(tag);\n  if (className) { e.className = className; }\n  if (style) { e.style.cssText = style; }\n  if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\n  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\n  return e\n}\n// wrapper for elt, which removes the elt from the accessibility tree\nfunction eltP(tag, content, className, style) {\n  var e = elt(tag, content, className, style);\n  e.setAttribute(\"role\", \"presentation\");\n  return e\n}\n\nvar range;\nif (document.createRange) { range = function(node, start, end, endNode) {\n  var r = document.createRange();\n  r.setEnd(endNode || node, end);\n  r.setStart(node, start);\n  return r\n}; }\nelse { range = function(node, start, end) {\n  var r = document.body.createTextRange();\n  try { r.moveToElementText(node.parentNode); }\n  catch(e) { return r }\n  r.collapse(true);\n  r.moveEnd(\"character\", end);\n  r.moveStart(\"character\", start);\n  return r\n}; }\n\nfunction contains(parent, child) {\n  if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n    { child = child.parentNode; }\n  if (parent.contains)\n    { return parent.contains(child) }\n  do {\n    if (child.nodeType == 11) { child = child.host; }\n    if (child == parent) { return true }\n  } while (child = child.parentNode)\n}\n\nfunction activeElt() {\n  // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n  // IE < 10 will throw when accessed while the page is loading or in an iframe.\n  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n  var activeElement;\n  try {\n    activeElement = document.activeElement;\n  } catch(e) {\n    activeElement = document.body || null;\n  }\n  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n    { activeElement = activeElement.shadowRoot.activeElement; }\n  return activeElement\n}\n\nfunction addClass(node, cls) {\n  var current = node.className;\n  if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\n}\nfunction joinClasses(a, b) {\n  var as = a.split(\" \");\n  for (var i = 0; i < as.length; i++)\n    { if (as[i] && !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\n  return b\n}\n\nvar selectInput = function(node) { node.select(); };\nif (ios) // Mobile Safari apparently has a bug where select() is broken.\n  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\nelse if (ie) // Suppress mysterious IE10 errors\n  { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\n\nfunction bind(f) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return function(){return f.apply(null, args)}\n}\n\nfunction copyObj(obj, target, overwrite) {\n  if (!target) { target = {}; }\n  for (var prop in obj)\n    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n      { target[prop] = obj[prop]; } }\n  return target\n}\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countColumn(string, end, tabSize, startIndex, startValue) {\n  if (end == null) {\n    end = string.search(/[^\\s\\u00a0]/);\n    if (end == -1) { end = string.length; }\n  }\n  for (var i = startIndex || 0, n = startValue || 0;;) {\n    var nextTab = string.indexOf(\"\\t\", i);\n    if (nextTab < 0 || nextTab >= end)\n      { return n + (end - i) }\n    n += nextTab - i;\n    n += tabSize - (n % tabSize);\n    i = nextTab + 1;\n  }\n}\n\nvar Delayed = function() {this.id = null;};\nDelayed.prototype.set = function (ms, f) {\n  clearTimeout(this.id);\n  this.id = setTimeout(f, ms);\n};\n\nfunction indexOf(array, elt) {\n  for (var i = 0; i < array.length; ++i)\n    { if (array[i] == elt) { return i } }\n  return -1\n}\n\n// Number of pixels added to scroller and sizer to hide scrollbar\nvar scrollerGap = 30;\n\n// Returned or thrown by various protocols to signal 'I'm not\n// handling this'.\nvar Pass = {toString: function(){return \"CodeMirror.Pass\"}};\n\n// Reused option objects for setSelection & friends\nvar sel_dontScroll = {scroll: false};\nvar sel_mouse = {origin: \"*mouse\"};\nvar sel_move = {origin: \"+move\"};\n\n// The inverse of countColumn -- find the offset that corresponds to\n// a particular column.\nfunction findColumn(string, goal, tabSize) {\n  for (var pos = 0, col = 0;;) {\n    var nextTab = string.indexOf(\"\\t\", pos);\n    if (nextTab == -1) { nextTab = string.length; }\n    var skipped = nextTab - pos;\n    if (nextTab == string.length || col + skipped >= goal)\n      { return pos + Math.min(skipped, goal - col) }\n    col += nextTab - pos;\n    col += tabSize - (col % tabSize);\n    pos = nextTab + 1;\n    if (col >= goal) { return pos }\n  }\n}\n\nvar spaceStrs = [\"\"];\nfunction spaceStr(n) {\n  while (spaceStrs.length <= n)\n    { spaceStrs.push(lst(spaceStrs) + \" \"); }\n  return spaceStrs[n]\n}\n\nfunction lst(arr) { return arr[arr.length-1] }\n\nfunction map(array, f) {\n  var out = [];\n  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\n  return out\n}\n\nfunction insertSorted(array, value, score) {\n  var pos = 0, priority = score(value);\n  while (pos < array.length && score(array[pos]) <= priority) { pos++; }\n  array.splice(pos, 0, value);\n}\n\nfunction nothing() {}\n\nfunction createObj(base, props) {\n  var inst;\n  if (Object.create) {\n    inst = Object.create(base);\n  } else {\n    nothing.prototype = base;\n    inst = new nothing();\n  }\n  if (props) { copyObj(props, inst); }\n  return inst\n}\n\nvar nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nfunction isWordCharBasic(ch) {\n  return /\\w/.test(ch) || ch > \"\\x80\" &&\n    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n}\nfunction isWordChar(ch, helper) {\n  if (!helper) { return isWordCharBasic(ch) }\n  if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) { return true }\n  return helper.test(ch)\n}\n\nfunction isEmpty(obj) {\n  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\n  return true\n}\n\n// Extending unicode characters. A series of a non-extending char +\n// any number of extending chars is treated as a single unit as far\n// as editing and measuring is concerned. This is not fully correct,\n// since some scripts/fonts/browsers also treat other configurations\n// of code points as a group.\nvar extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\nfunction isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\n\n// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\nfunction skipExtendingChars(str, pos, dir) {\n  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\n  return pos\n}\n\n// Returns the value from the range [`from`; `to`] that satisfies\n// `pred` and is closest to `from`. Assumes that at least `to` satisfies `pred`.\nfunction findFirst(pred, from, to) {\n  for (;;) {\n    if (Math.abs(from - to) <= 1) { return pred(from) ? from : to }\n    var mid = Math.floor((from + to) / 2);\n    if (pred(mid)) { to = mid; }\n    else { from = mid; }\n  }\n}\n\n// The display handles the DOM integration, both for input reading\n// and content drawing. It holds references to DOM nodes and\n// display-related state.\n\nfunction Display(place, doc, input) {\n  var d = this;\n  this.input = input;\n\n  // Covers bottom-right square when both scrollbars are present.\n  d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n  d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n  // Covers bottom of gutter when coverGutterNextToScrollbar is on\n  // and h scrollbar is present.\n  d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n  d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n  // Will contain the actual code, positioned to cover the viewport.\n  d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\n  // Elements are added to these to represent selection and cursors.\n  d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n  d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n  // A visibility: hidden element used to find the size of things.\n  d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n  // When lines outside of the viewport are measured, they are drawn in this.\n  d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n  // Wraps everything that needs to exist inside the vertically-padded coordinate system\n  d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                    null, \"position: relative; outline: none\");\n  var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\n  // Moved around its parent to cover visible view.\n  d.mover = elt(\"div\", [lines], null, \"position: relative\");\n  // Set to the height of the document, allowing scrolling.\n  d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n  d.sizerWidth = null;\n  // Behavior of elts with overflow: auto and padding is\n  // inconsistent across browsers. This is used to ensure the\n  // scrollable area is big enough.\n  d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n  // Will contain the gutters, if any.\n  d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n  d.lineGutter = null;\n  // Actual scrollable element.\n  d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n  d.scroller.setAttribute(\"tabIndex\", \"-1\");\n  // The element in which the editor lives.\n  d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\n\n  if (place) {\n    if (place.appendChild) { place.appendChild(d.wrapper); }\n    else { place(d.wrapper); }\n  }\n\n  // Current rendered range (may be bigger than the view window).\n  d.viewFrom = d.viewTo = doc.first;\n  d.reportedViewFrom = d.reportedViewTo = doc.first;\n  // Information about the rendered lines.\n  d.view = [];\n  d.renderedView = null;\n  // Holds info about a single rendered line when it was rendered\n  // for measurement, while not in view.\n  d.externalMeasured = null;\n  // Empty space (in pixels) above the view\n  d.viewOffset = 0;\n  d.lastWrapHeight = d.lastWrapWidth = 0;\n  d.updateLineNumbers = null;\n\n  d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n  d.scrollbarsClipped = false;\n\n  // Used to only resize the line number gutter when necessary (when\n  // the amount of lines crosses a boundary that makes its width change)\n  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n  // Set to true when a non-horizontal-scrolling line widget is\n  // added. As an optimization, line widget aligning is skipped when\n  // this is false.\n  d.alignWidgets = false;\n\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n  // Tracks the maximum line length so that the horizontal scrollbar\n  // can be kept static when scrolling.\n  d.maxLine = null;\n  d.maxLineLength = 0;\n  d.maxLineChanged = false;\n\n  // Used for measuring wheel scrolling granularity\n  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n  // True when shift is held down.\n  d.shift = false;\n\n  // Used to track whether anything happened since the context menu\n  // was opened.\n  d.selForContextMenu = null;\n\n  d.activeTouch = null;\n\n  input.init(d);\n}\n\n// Find the line object corresponding to the given line number.\nfunction getLine(doc, n) {\n  n -= doc.first;\n  if (n < 0 || n >= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\n  var chunk = doc;\n  while (!chunk.lines) {\n    for (var i = 0;; ++i) {\n      var child = chunk.children[i], sz = child.chunkSize();\n      if (n < sz) { chunk = child; break }\n      n -= sz;\n    }\n  }\n  return chunk.lines[n]\n}\n\n// Get the part of a document between two positions, as an array of\n// strings.\nfunction getBetween(doc, start, end) {\n  var out = [], n = start.line;\n  doc.iter(start.line, end.line + 1, function (line) {\n    var text = line.text;\n    if (n == end.line) { text = text.slice(0, end.ch); }\n    if (n == start.line) { text = text.slice(start.ch); }\n    out.push(text);\n    ++n;\n  });\n  return out\n}\n// Get the lines between from and to, as array of strings.\nfunction getLines(doc, from, to) {\n  var out = [];\n  doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\n  return out\n}\n\n// Update the height of a line, propagating the height change\n// upwards to parent nodes.\nfunction updateLineHeight(line, height) {\n  var diff = height - line.height;\n  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\n}\n\n// Given a line object, find its line number by walking up through\n// its parent links.\nfunction lineNo(line) {\n  if (line.parent == null) { return null }\n  var cur = line.parent, no = indexOf(cur.lines, line);\n  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n    for (var i = 0;; ++i) {\n      if (chunk.children[i] == cur) { break }\n      no += chunk.children[i].chunkSize();\n    }\n  }\n  return no + cur.first\n}\n\n// Find the line at the given vertical position, using the height\n// information in the document tree.\nfunction lineAtHeight(chunk, h) {\n  var n = chunk.first;\n  outer: do {\n    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n      var child = chunk.children[i$1], ch = child.height;\n      if (h < ch) { chunk = child; continue outer }\n      h -= ch;\n      n += child.chunkSize();\n    }\n    return n\n  } while (!chunk.lines)\n  var i = 0;\n  for (; i < chunk.lines.length; ++i) {\n    var line = chunk.lines[i], lh = line.height;\n    if (h < lh) { break }\n    h -= lh;\n  }\n  return n + i\n}\n\nfunction isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\n\nfunction lineNumberFor(options, i) {\n  return String(options.lineNumberFormatter(i + options.firstLineNumber))\n}\n\n// A Pos instance represents a position within the text.\nfunction Pos(line, ch, sticky) {\n  if ( sticky === void 0 ) sticky = null;\n\n  if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\n  this.line = line;\n  this.ch = ch;\n  this.sticky = sticky;\n}\n\n// Compare two positions, return 0 if they are the same, a negative\n// number when a is less, and a positive number otherwise.\nfunction cmp(a, b) { return a.line - b.line || a.ch - b.ch }\n\nfunction equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\n\nfunction copyPos(x) {return Pos(x.line, x.ch)}\nfunction maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\nfunction minPos(a, b) { return cmp(a, b) < 0 ? a : b }\n\n// Most of the external API clips given positions to make sure they\n// actually exist within the document.\nfunction clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\nfunction clipPos(doc, pos) {\n  if (pos.line < doc.first) { return Pos(doc.first, 0) }\n  var last = doc.first + doc.size - 1;\n  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\n  return clipToLen(pos, getLine(doc, pos.line).text.length)\n}\nfunction clipToLen(pos, linelen) {\n  var ch = pos.ch;\n  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\n  else if (ch < 0) { return Pos(pos.line, 0) }\n  else { return pos }\n}\nfunction clipPosArray(doc, array) {\n  var out = [];\n  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\n  return out\n}\n\n// Optimize some code when these features are not used.\nvar sawReadOnlySpans = false;\nvar sawCollapsedSpans = false;\n\nfunction seeReadOnlySpans() {\n  sawReadOnlySpans = true;\n}\n\nfunction seeCollapsedSpans() {\n  sawCollapsedSpans = true;\n}\n\n// TEXTMARKER SPANS\n\nfunction MarkedSpan(marker, from, to) {\n  this.marker = marker;\n  this.from = from; this.to = to;\n}\n\n// Search an array of spans for a span matching the given marker.\nfunction getMarkedSpanFor(spans, marker) {\n  if (spans) { for (var i = 0; i < spans.length; ++i) {\n    var span = spans[i];\n    if (span.marker == marker) { return span }\n  } }\n}\n// Remove a span from an array, returning undefined if no spans are\n// left (we don't store arrays for lines without spans).\nfunction removeMarkedSpan(spans, span) {\n  var r;\n  for (var i = 0; i < spans.length; ++i)\n    { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\n  return r\n}\n// Add a span to a line.\nfunction addMarkedSpan(line, span) {\n  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n  span.marker.attachLine(line);\n}\n\n// Used for the algorithm that adjusts markers for a change in the\n// document. These functions cut an array of spans at a given\n// character position, returning an array of remaining chunks (or\n// undefined if nothing remains).\nfunction markedSpansBefore(old, startCh, isInsert) {\n  var nw;\n  if (old) { for (var i = 0; i < old.length; ++i) {\n    var span = old[i], marker = span.marker;\n    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n    if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n    }\n  } }\n  return nw\n}\nfunction markedSpansAfter(old, endCh, isInsert) {\n  var nw;\n  if (old) { for (var i = 0; i < old.length; ++i) {\n    var span = old[i], marker = span.marker;\n    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n    if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                            span.to == null ? null : span.to - endCh));\n    }\n  } }\n  return nw\n}\n\n// Given a change object, compute the new set of marker spans that\n// cover the line in which the change took place. Removes spans\n// entirely within the change, reconnects spans belonging to the\n// same marker that appear on both sides of the change, and cuts off\n// spans partially within the change. Returns an array of span\n// arrays with one element for each line in (after) the change.\nfunction stretchSpansOverChange(doc, change) {\n  if (change.full) { return null }\n  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n  if (!oldFirst && !oldLast) { return null }\n\n  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n  // Get the spans that 'stick out' on both sides\n  var first = markedSpansBefore(oldFirst, startCh, isInsert);\n  var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n  // Next, merge those two ends\n  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n  if (first) {\n    // Fix up .to properties of first\n    for (var i = 0; i < first.length; ++i) {\n      var span = first[i];\n      if (span.to == null) {\n        var found = getMarkedSpanFor(last, span.marker);\n        if (!found) { span.to = startCh; }\n        else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\n      }\n    }\n  }\n  if (last) {\n    // Fix up .from in last (or move them into first in case of sameLine)\n    for (var i$1 = 0; i$1 < last.length; ++i$1) {\n      var span$1 = last[i$1];\n      if (span$1.to != null) { span$1.to += offset; }\n      if (span$1.from == null) {\n        var found$1 = getMarkedSpanFor(first, span$1.marker);\n        if (!found$1) {\n          span$1.from = offset;\n          if (sameLine) { (first || (first = [])).push(span$1); }\n        }\n      } else {\n        span$1.from += offset;\n        if (sameLine) { (first || (first = [])).push(span$1); }\n      }\n    }\n  }\n  // Make sure we didn't create any zero-length spans\n  if (first) { first = clearEmptySpans(first); }\n  if (last && last != first) { last = clearEmptySpans(last); }\n\n  var newMarkers = [first];\n  if (!sameLine) {\n    // Fill gap with whole-line-spans\n    var gap = change.text.length - 2, gapMarkers;\n    if (gap > 0 && first)\n      { for (var i$2 = 0; i$2 < first.length; ++i$2)\n        { if (first[i$2].to == null)\n          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\n    for (var i$3 = 0; i$3 < gap; ++i$3)\n      { newMarkers.push(gapMarkers); }\n    newMarkers.push(last);\n  }\n  return newMarkers\n}\n\n// Remove spans that are empty and don't have a clearWhenEmpty\n// option of false.\nfunction clearEmptySpans(spans) {\n  for (var i = 0; i < spans.length; ++i) {\n    var span = spans[i];\n    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n      { spans.splice(i--, 1); }\n  }\n  if (!spans.length) { return null }\n  return spans\n}\n\n// Used to 'clip' out readOnly ranges when making a change.\nfunction removeReadOnlyRanges(doc, from, to) {\n  var markers = null;\n  doc.iter(from.line, to.line + 1, function (line) {\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n      var mark = line.markedSpans[i].marker;\n      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n        { (markers || (markers = [])).push(mark); }\n    } }\n  });\n  if (!markers) { return null }\n  var parts = [{from: from, to: to}];\n  for (var i = 0; i < markers.length; ++i) {\n    var mk = markers[i], m = mk.find(0);\n    for (var j = 0; j < parts.length; ++j) {\n      var p = parts[j];\n      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\n      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n        { newParts.push({from: p.from, to: m.from}); }\n      if (dto > 0 || !mk.inclusiveRight && !dto)\n        { newParts.push({from: m.to, to: p.to}); }\n      parts.splice.apply(parts, newParts);\n      j += newParts.length - 3;\n    }\n  }\n  return parts\n}\n\n// Connect or disconnect spans from a line.\nfunction detachMarkedSpans(line) {\n  var spans = line.markedSpans;\n  if (!spans) { return }\n  for (var i = 0; i < spans.length; ++i)\n    { spans[i].marker.detachLine(line); }\n  line.markedSpans = null;\n}\nfunction attachMarkedSpans(line, spans) {\n  if (!spans) { return }\n  for (var i = 0; i < spans.length; ++i)\n    { spans[i].marker.attachLine(line); }\n  line.markedSpans = spans;\n}\n\n// Helpers used when computing which overlapping collapsed span\n// counts as the larger one.\nfunction extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\nfunction extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\n\n// Returns a number indicating which of two overlapping collapsed\n// spans is larger (and thus includes the other). Falls back to\n// comparing ids when the spans cover exactly the same range.\nfunction compareCollapsedMarkers(a, b) {\n  var lenDiff = a.lines.length - b.lines.length;\n  if (lenDiff != 0) { return lenDiff }\n  var aPos = a.find(), bPos = b.find();\n  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n  if (fromCmp) { return -fromCmp }\n  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n  if (toCmp) { return toCmp }\n  return b.id - a.id\n}\n\n// Find out whether a line ends or starts in a collapsed span. If\n// so, return the marker for that span.\nfunction collapsedSpanAtSide(line, start) {\n  var sps = sawCollapsedSpans && line.markedSpans, found;\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n    sp = sps[i];\n    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n        (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n      { found = sp.marker; }\n  } }\n  return found\n}\nfunction collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\nfunction collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\n\n// Test whether there exists a collapsed span that partially\n// overlaps (covers the start or end, but not both) of a new span.\n// Such overlap is not allowed.\nfunction conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {\n  var line = getLine(doc, lineNo$$1);\n  var sps = sawCollapsedSpans && line.markedSpans;\n  if (sps) { for (var i = 0; i < sps.length; ++i) {\n    var sp = sps[i];\n    if (!sp.marker.collapsed) { continue }\n    var found = sp.marker.find(0);\n    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\n    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n      { return true }\n  } }\n}\n\n// A visual line is a line as drawn on the screen. Folding, for\n// example, can cause multiple logical lines to appear on the same\n// visual line. This finds the start of the visual line that the\n// given line is part of (usually that is the line itself).\nfunction visualLine(line) {\n  var merged;\n  while (merged = collapsedSpanAtStart(line))\n    { line = merged.find(-1, true).line; }\n  return line\n}\n\nfunction visualLineEnd(line) {\n  var merged;\n  while (merged = collapsedSpanAtEnd(line))\n    { line = merged.find(1, true).line; }\n  return line\n}\n\n// Returns an array of logical lines that continue the visual line\n// started by the argument, or undefined if there are no such lines.\nfunction visualLineContinued(line) {\n  var merged, lines;\n  while (merged = collapsedSpanAtEnd(line)) {\n    line = merged.find(1, true).line\n    ;(lines || (lines = [])).push(line);\n  }\n  return lines\n}\n\n// Get the line number of the start of the visual line that the\n// given line number is part of.\nfunction visualLineNo(doc, lineN) {\n  var line = getLine(doc, lineN), vis = visualLine(line);\n  if (line == vis) { return lineN }\n  return lineNo(vis)\n}\n\n// Get the line number of the start of the next visual line after\n// the given line.\nfunction visualLineEndNo(doc, lineN) {\n  if (lineN > doc.lastLine()) { return lineN }\n  var line = getLine(doc, lineN), merged;\n  if (!lineIsHidden(doc, line)) { return lineN }\n  while (merged = collapsedSpanAtEnd(line))\n    { line = merged.find(1, true).line; }\n  return lineNo(line) + 1\n}\n\n// Compute whether a line is hidden. Lines count as hidden when they\n// are part of a visual line that starts with another line, or when\n// they are entirely covered by collapsed, non-widget span.\nfunction lineIsHidden(doc, line) {\n  var sps = sawCollapsedSpans && line.markedSpans;\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n    sp = sps[i];\n    if (!sp.marker.collapsed) { continue }\n    if (sp.from == null) { return true }\n    if (sp.marker.widgetNode) { continue }\n    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n      { return true }\n  } }\n}\nfunction lineIsHiddenInner(doc, line, span) {\n  if (span.to == null) {\n    var end = span.marker.find(1, true);\n    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\n  }\n  if (span.marker.inclusiveRight && span.to == line.text.length)\n    { return true }\n  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\n    sp = line.markedSpans[i];\n    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n        (sp.to == null || sp.to != span.from) &&\n        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n        lineIsHiddenInner(doc, line, sp)) { return true }\n  }\n}\n\n// Find the height above the given line.\nfunction heightAtLine(lineObj) {\n  lineObj = visualLine(lineObj);\n\n  var h = 0, chunk = lineObj.parent;\n  for (var i = 0; i < chunk.lines.length; ++i) {\n    var line = chunk.lines[i];\n    if (line == lineObj) { break }\n    else { h += line.height; }\n  }\n  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n      var cur = p.children[i$1];\n      if (cur == chunk) { break }\n      else { h += cur.height; }\n    }\n  }\n  return h\n}\n\n// Compute the character length of a line, taking into account\n// collapsed ranges (see markText) that might hide parts, and join\n// other lines onto it.\nfunction lineLength(line) {\n  if (line.height == 0) { return 0 }\n  var len = line.text.length, merged, cur = line;\n  while (merged = collapsedSpanAtStart(cur)) {\n    var found = merged.find(0, true);\n    cur = found.from.line;\n    len += found.from.ch - found.to.ch;\n  }\n  cur = line;\n  while (merged = collapsedSpanAtEnd(cur)) {\n    var found$1 = merged.find(0, true);\n    len -= cur.text.length - found$1.from.ch;\n    cur = found$1.to.line;\n    len += cur.text.length - found$1.to.ch;\n  }\n  return len\n}\n\n// Find the longest line in the document.\nfunction findMaxLine(cm) {\n  var d = cm.display, doc = cm.doc;\n  d.maxLine = getLine(doc, doc.first);\n  d.maxLineLength = lineLength(d.maxLine);\n  d.maxLineChanged = true;\n  doc.iter(function (line) {\n    var len = lineLength(line);\n    if (len > d.maxLineLength) {\n      d.maxLineLength = len;\n      d.maxLine = line;\n    }\n  });\n}\n\n// BIDI HELPERS\n\nfunction iterateBidiSections(order, from, to, f) {\n  if (!order) { return f(from, to, \"ltr\") }\n  var found = false;\n  for (var i = 0; i < order.length; ++i) {\n    var part = order[i];\n    if (part.from < to && part.to > from || from == to && part.to == from) {\n      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n      found = true;\n    }\n  }\n  if (!found) { f(from, to, \"ltr\"); }\n}\n\nvar bidiOther = null;\nfunction getBidiPartAt(order, ch, sticky) {\n  var found;\n  bidiOther = null;\n  for (var i = 0; i < order.length; ++i) {\n    var cur = order[i];\n    if (cur.from < ch && cur.to > ch) { return i }\n    if (cur.to == ch) {\n      if (cur.from != cur.to && sticky == \"before\") { found = i; }\n      else { bidiOther = i; }\n    }\n    if (cur.from == ch) {\n      if (cur.from != cur.to && sticky != \"before\") { found = i; }\n      else { bidiOther = i; }\n    }\n  }\n  return found != null ? found : bidiOther\n}\n\n// Bidirectional ordering algorithm\n// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n// that this (partially) implements.\n\n// One-char codes used for character types:\n// L (L):   Left-to-Right\n// R (R):   Right-to-Left\n// r (AL):  Right-to-Left Arabic\n// 1 (EN):  European Number\n// + (ES):  European Number Separator\n// % (ET):  European Number Terminator\n// n (AN):  Arabic Number\n// , (CS):  Common Number Separator\n// m (NSM): Non-Spacing Mark\n// b (BN):  Boundary Neutral\n// s (B):   Paragraph Separator\n// t (S):   Segment Separator\n// w (WS):  Whitespace\n// N (ON):  Other Neutrals\n\n// Returns null if characters are ordered as they appear\n// (left-to-right), or an array of sections ({from, to, level}\n// objects) in the order in which they occur visually.\nvar bidiOrdering = (function() {\n  // Character types for codepoints 0 to 0xff\n  var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n  // Character types for codepoints 0x600 to 0x6f9\n  var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n  function charType(code) {\n    if (code <= 0xf7) { return lowTypes.charAt(code) }\n    else if (0x590 <= code && code <= 0x5f4) { return \"R\" }\n    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\n    else if (0x6ee <= code && code <= 0x8ac) { return \"r\" }\n    else if (0x2000 <= code && code <= 0x200b) { return \"w\" }\n    else if (code == 0x200c) { return \"b\" }\n    else { return \"L\" }\n  }\n\n  var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\n  function BidiSpan(level, from, to) {\n    this.level = level;\n    this.from = from; this.to = to;\n  }\n\n  return function(str, direction) {\n    var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n    if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) { return false }\n    var len = str.length, types = [];\n    for (var i = 0; i < len; ++i)\n      { types.push(charType(str.charCodeAt(i))); }\n\n    // W1. Examine each non-spacing mark (NSM) in the level run, and\n    // change the type of the NSM to the type of the previous\n    // character. If the NSM is at the start of the level run, it will\n    // get the type of sor.\n    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n      var type = types[i$1];\n      if (type == \"m\") { types[i$1] = prev; }\n      else { prev = type; }\n    }\n\n    // W2. Search backwards from each instance of a European number\n    // until the first strong type (R, L, AL, or sor) is found. If an\n    // AL is found, change the type of the European number to Arabic\n    // number.\n    // W3. Change all ALs to R.\n    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n      var type$1 = types[i$2];\n      if (type$1 == \"1\" && cur == \"r\") { types[i$2] = \"n\"; }\n      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\n    }\n\n    // W4. A single European separator between two European numbers\n    // changes to a European number. A single common separator between\n    // two numbers of the same type changes to that type.\n    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n      var type$2 = types[i$3];\n      if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\n      else if (type$2 == \",\" && prev$1 == types[i$3+1] &&\n               (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\n      prev$1 = type$2;\n    }\n\n    // W5. A sequence of European terminators adjacent to European\n    // numbers changes to all European numbers.\n    // W6. Otherwise, separators and terminators change to Other\n    // Neutral.\n    for (var i$4 = 0; i$4 < len; ++i$4) {\n      var type$3 = types[i$4];\n      if (type$3 == \",\") { types[i$4] = \"N\"; }\n      else if (type$3 == \"%\") {\n        var end = (void 0);\n        for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\n        var replace = (i$4 && types[i$4-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n        for (var j = i$4; j < end; ++j) { types[j] = replace; }\n        i$4 = end - 1;\n      }\n    }\n\n    // W7. Search backwards from each instance of a European number\n    // until the first strong type (R, L, or sor) is found. If an L is\n    // found, then change the type of the European number to L.\n    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n      var type$4 = types[i$5];\n      if (cur$1 == \"L\" && type$4 == \"1\") { types[i$5] = \"L\"; }\n      else if (isStrong.test(type$4)) { cur$1 = type$4; }\n    }\n\n    // N1. A sequence of neutrals takes the direction of the\n    // surrounding strong text if the text on both sides has the same\n    // direction. European and Arabic numbers act as if they were R in\n    // terms of their influence on neutrals. Start-of-level-run (sor)\n    // and end-of-level-run (eor) are used at level run boundaries.\n    // N2. Any remaining neutrals take the embedding direction.\n    for (var i$6 = 0; i$6 < len; ++i$6) {\n      if (isNeutral.test(types[i$6])) {\n        var end$1 = (void 0);\n        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n        var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\n        var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n        var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\n        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\n        i$6 = end$1 - 1;\n      }\n    }\n\n    // Here we depart from the documented algorithm, in order to avoid\n    // building up an actual levels array. Since there are only three\n    // levels (0, 1, 2) in an implementation that doesn't take\n    // explicit embedding into account, we can build up the order on\n    // the fly, without following the level-based algorithm.\n    var order = [], m;\n    for (var i$7 = 0; i$7 < len;) {\n      if (countsAsLeft.test(types[i$7])) {\n        var start = i$7;\n        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n        order.push(new BidiSpan(0, start, i$7));\n      } else {\n        var pos = i$7, at = order.length;\n        for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\n        for (var j$2 = pos; j$2 < i$7;) {\n          if (countsAsNum.test(types[j$2])) {\n            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }\n            var nstart = j$2;\n            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n            order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n            pos = j$2;\n          } else { ++j$2; }\n        }\n        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\n      }\n    }\n    if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n      order[0].from = m[0].length;\n      order.unshift(new BidiSpan(0, 0, m[0].length));\n    }\n    if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n      lst(order).to -= m[0].length;\n      order.push(new BidiSpan(0, len - m[0].length, len));\n    }\n\n    return direction == \"rtl\" ? order.reverse() : order\n  }\n})();\n\n// Get the bidi ordering for the given line (and cache it). Returns\n// false for lines that are fully left-to-right, and an array of\n// BidiSpan objects otherwise.\nfunction getOrder(line, direction) {\n  var order = line.order;\n  if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\n  return order\n}\n\nfunction moveCharLogically(line, ch, dir) {\n  var target = skipExtendingChars(line.text, ch + dir, dir);\n  return target < 0 || target > line.text.length ? null : target\n}\n\nfunction moveLogically(line, start, dir) {\n  var ch = moveCharLogically(line, start.ch, dir);\n  return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\")\n}\n\nfunction endOfLine(visually, cm, lineObj, lineNo, dir) {\n  if (visually) {\n    var order = getOrder(lineObj, cm.doc.direction);\n    if (order) {\n      var part = dir < 0 ? lst(order) : order[0];\n      var moveInStorageOrder = (dir < 0) == (part.level == 1);\n      var sticky = moveInStorageOrder ? \"after\" : \"before\";\n      var ch;\n      // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n      // it could be that the last bidi part is not on the last visual line,\n      // since visual lines contain content order-consecutive chunks.\n      // Thus, in rtl, we are looking for the first (content-order) character\n      // in the rtl chunk that is on the last line (that is, the same line\n      // as the last (content-order) character).\n      if (part.level > 0) {\n        var prep = prepareMeasureForLine(cm, lineObj);\n        ch = dir < 0 ? lineObj.text.length - 1 : 0;\n        var targetTop = measureCharPrepared(cm, prep, ch).top;\n        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\n        if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\n      } else { ch = dir < 0 ? part.to : part.from; }\n      return new Pos(lineNo, ch, sticky)\n    }\n  }\n  return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\")\n}\n\nfunction moveVisually(cm, line, start, dir) {\n  var bidi = getOrder(line, cm.doc.direction);\n  if (!bidi) { return moveLogically(line, start, dir) }\n  if (start.ch >= line.text.length) {\n    start.ch = line.text.length;\n    start.sticky = \"before\";\n  } else if (start.ch <= 0) {\n    start.ch = 0;\n    start.sticky = \"after\";\n  }\n  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n  if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n    // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n    // nothing interesting happens.\n    return moveLogically(line, start, dir)\n  }\n\n  var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\n  var prep;\n  var getWrappedLineExtent = function (ch) {\n    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\n    prep = prep || prepareMeasureForLine(cm, line);\n    return wrappedLineExtentChar(cm, line, prep, ch)\n  };\n  var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n  if (cm.doc.direction == \"rtl\" || part.level == 1) {\n    var moveInStorageOrder = (part.level == 1) == (dir < 0);\n    var ch = mv(start, moveInStorageOrder ? 1 : -1);\n    if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n      // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n      var sticky = moveInStorageOrder ? \"before\" : \"after\";\n      return new Pos(start.line, ch, sticky)\n    }\n  }\n\n  // Case 3: Could not move within this bidi part in this visual line, so leave\n  // the current bidi part\n\n  var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\n    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\n      ? new Pos(start.line, mv(ch, 1), \"before\")\n      : new Pos(start.line, ch, \"after\"); };\n\n    for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n      var part = bidi[partPos];\n      var moveInStorageOrder = (dir > 0) == (part.level != 1);\n      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n      if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\n      ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n      if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\n    }\n  };\n\n  // Case 3a: Look for other bidi parts on the same visual line\n  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n  if (res) { return res }\n\n  // Case 3b: Look for other bidi parts on the next visual line\n  var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n    if (res) { return res }\n  }\n\n  // Case 4: Nowhere to move\n  return null\n}\n\n// EVENT HANDLING\n\n// Lightweight event framework. on/off also work on DOM nodes,\n// registering native DOM handlers.\n\nvar noHandlers = [];\n\nvar on = function(emitter, type, f) {\n  if (emitter.addEventListener) {\n    emitter.addEventListener(type, f, false);\n  } else if (emitter.attachEvent) {\n    emitter.attachEvent(\"on\" + type, f);\n  } else {\n    var map$$1 = emitter._handlers || (emitter._handlers = {});\n    map$$1[type] = (map$$1[type] || noHandlers).concat(f);\n  }\n};\n\nfunction getHandlers(emitter, type) {\n  return emitter._handlers && emitter._handlers[type] || noHandlers\n}\n\nfunction off(emitter, type, f) {\n  if (emitter.removeEventListener) {\n    emitter.removeEventListener(type, f, false);\n  } else if (emitter.detachEvent) {\n    emitter.detachEvent(\"on\" + type, f);\n  } else {\n    var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];\n    if (arr) {\n      var index = indexOf(arr, f);\n      if (index > -1)\n        { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\n    }\n  }\n}\n\nfunction signal(emitter, type /*, values...*/) {\n  var handlers = getHandlers(emitter, type);\n  if (!handlers.length) { return }\n  var args = Array.prototype.slice.call(arguments, 2);\n  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\n}\n\n// The DOM events that CodeMirror handles can be overridden by\n// registering a (non-DOM) handler on the editor for the event name,\n// and preventDefault-ing the event in that handler.\nfunction signalDOMEvent(cm, e, override) {\n  if (typeof e == \"string\")\n    { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\n  signal(cm, override || e.type, cm, e);\n  return e_defaultPrevented(e) || e.codemirrorIgnore\n}\n\nfunction signalCursorActivity(cm) {\n  var arr = cm._handlers && cm._handlers.cursorActivity;\n  if (!arr) { return }\n  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\n    { set.push(arr[i]); } }\n}\n\nfunction hasHandler(emitter, type) {\n  return getHandlers(emitter, type).length > 0\n}\n\n// Add on and off methods to a constructor's prototype, to make\n// registering events on such objects more convenient.\nfunction eventMixin(ctor) {\n  ctor.prototype.on = function(type, f) {on(this, type, f);};\n  ctor.prototype.off = function(type, f) {off(this, type, f);};\n}\n\n// Due to the fact that we still support jurassic IE versions, some\n// compatibility wrappers are needed.\n\nfunction e_preventDefault(e) {\n  if (e.preventDefault) { e.preventDefault(); }\n  else { e.returnValue = false; }\n}\nfunction e_stopPropagation(e) {\n  if (e.stopPropagation) { e.stopPropagation(); }\n  else { e.cancelBubble = true; }\n}\nfunction e_defaultPrevented(e) {\n  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\n}\nfunction e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n\nfunction e_target(e) {return e.target || e.srcElement}\nfunction e_button(e) {\n  var b = e.which;\n  if (b == null) {\n    if (e.button & 1) { b = 1; }\n    else if (e.button & 2) { b = 3; }\n    else if (e.button & 4) { b = 2; }\n  }\n  if (mac && e.ctrlKey && b == 1) { b = 3; }\n  return b\n}\n\n// Detect drag-and-drop\nvar dragAndDrop = function() {\n  // There is *some* kind of drag-and-drop support in IE6-8, but I\n  // couldn't get it to work yet.\n  if (ie && ie_version < 9) { return false }\n  var div = elt('div');\n  return \"draggable\" in div || \"dragDrop\" in div\n}();\n\nvar zwspSupported;\nfunction zeroWidthElement(measure) {\n  if (zwspSupported == null) {\n    var test = elt(\"span\", \"\\u200b\");\n    removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n    if (measure.firstChild.offsetHeight != 0)\n      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\n  }\n  var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n    elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n  node.setAttribute(\"cm-text\", \"\");\n  return node\n}\n\n// Feature-detect IE's crummy client rect reporting for bidi text\nvar badBidiRects;\nfunction hasBadBidiRects(measure) {\n  if (badBidiRects != null) { return badBidiRects }\n  var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n  var r0 = range(txt, 0, 1).getBoundingClientRect();\n  var r1 = range(txt, 1, 2).getBoundingClientRect();\n  removeChildren(measure);\n  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\n  return badBidiRects = (r1.right - r0.right < 3)\n}\n\n// See if \"\".split is the broken IE version, if so, provide an\n// alternative way to split lines.\nvar splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n  var pos = 0, result = [], l = string.length;\n  while (pos <= l) {\n    var nl = string.indexOf(\"\\n\", pos);\n    if (nl == -1) { nl = string.length; }\n    var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n    var rt = line.indexOf(\"\\r\");\n    if (rt != -1) {\n      result.push(line.slice(0, rt));\n      pos += rt + 1;\n    } else {\n      result.push(line);\n      pos = nl + 1;\n    }\n  }\n  return result\n} : function (string) { return string.split(/\\r\\n?|\\n/); };\n\nvar hasSelection = window.getSelection ? function (te) {\n  try { return te.selectionStart != te.selectionEnd }\n  catch(e) { return false }\n} : function (te) {\n  var range$$1;\n  try {range$$1 = te.ownerDocument.selection.createRange();}\n  catch(e) {}\n  if (!range$$1 || range$$1.parentElement() != te) { return false }\n  return range$$1.compareEndPoints(\"StartToEnd\", range$$1) != 0\n};\n\nvar hasCopyEvent = (function () {\n  var e = elt(\"div\");\n  if (\"oncopy\" in e) { return true }\n  e.setAttribute(\"oncopy\", \"return;\");\n  return typeof e.oncopy == \"function\"\n})();\n\nvar badZoomedRects = null;\nfunction hasBadZoomedRects(measure) {\n  if (badZoomedRects != null) { return badZoomedRects }\n  var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n  var normal = node.getBoundingClientRect();\n  var fromRange = range(node, 0, 1).getBoundingClientRect();\n  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\n}\n\n// Known modes, by name and by MIME\nvar modes = {};\nvar mimeModes = {};\n\n// Extra arguments are stored as the mode's dependencies, which is\n// used by (legacy) mechanisms like loadmode.js to automatically\n// load a mode. (Preferred mechanism is the require/define calls.)\nfunction defineMode(name, mode) {\n  if (arguments.length > 2)\n    { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\n  modes[name] = mode;\n}\n\nfunction defineMIME(mime, spec) {\n  mimeModes[mime] = spec;\n}\n\n// Given a MIME type, a {name, ...options} config object, or a name\n// string, return a mode config object.\nfunction resolveMode(spec) {\n  if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n    spec = mimeModes[spec];\n  } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n    var found = mimeModes[spec.name];\n    if (typeof found == \"string\") { found = {name: found}; }\n    spec = createObj(found, spec);\n    spec.name = found.name;\n  } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n    return resolveMode(\"application/xml\")\n  } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n    return resolveMode(\"application/json\")\n  }\n  if (typeof spec == \"string\") { return {name: spec} }\n  else { return spec || {name: \"null\"} }\n}\n\n// Given a mode spec (anything that resolveMode accepts), find and\n// initialize an actual mode object.\nfunction getMode(options, spec) {\n  spec = resolveMode(spec);\n  var mfactory = modes[spec.name];\n  if (!mfactory) { return getMode(options, \"text/plain\") }\n  var modeObj = mfactory(options, spec);\n  if (modeExtensions.hasOwnProperty(spec.name)) {\n    var exts = modeExtensions[spec.name];\n    for (var prop in exts) {\n      if (!exts.hasOwnProperty(prop)) { continue }\n      if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\n      modeObj[prop] = exts[prop];\n    }\n  }\n  modeObj.name = spec.name;\n  if (spec.helperType) { modeObj.helperType = spec.helperType; }\n  if (spec.modeProps) { for (var prop$1 in spec.modeProps)\n    { modeObj[prop$1] = spec.modeProps[prop$1]; } }\n\n  return modeObj\n}\n\n// This can be used to attach properties to mode objects from\n// outside the actual mode definition.\nvar modeExtensions = {};\nfunction extendMode(mode, properties) {\n  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n  copyObj(properties, exts);\n}\n\nfunction copyState(mode, state) {\n  if (state === true) { return state }\n  if (mode.copyState) { return mode.copyState(state) }\n  var nstate = {};\n  for (var n in state) {\n    var val = state[n];\n    if (val instanceof Array) { val = val.concat([]); }\n    nstate[n] = val;\n  }\n  return nstate\n}\n\n// Given a mode and a state (for that mode), find the inner mode and\n// state at the position that the state refers to.\nfunction innerMode(mode, state) {\n  var info;\n  while (mode.innerMode) {\n    info = mode.innerMode(state);\n    if (!info || info.mode == mode) { break }\n    state = info.state;\n    mode = info.mode;\n  }\n  return info || {mode: mode, state: state}\n}\n\nfunction startState(mode, a1, a2) {\n  return mode.startState ? mode.startState(a1, a2) : true\n}\n\n// STRING STREAM\n\n// Fed to the mode parsers, provides helper functions to make\n// parsers more succinct.\n\nvar StringStream = function(string, tabSize, lineOracle) {\n  this.pos = this.start = 0;\n  this.string = string;\n  this.tabSize = tabSize || 8;\n  this.lastColumnPos = this.lastColumnValue = 0;\n  this.lineStart = 0;\n  this.lineOracle = lineOracle;\n};\n\nStringStream.prototype.eol = function () {return this.pos >= this.string.length};\nStringStream.prototype.sol = function () {return this.pos == this.lineStart};\nStringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\nStringStream.prototype.next = function () {\n  if (this.pos < this.string.length)\n    { return this.string.charAt(this.pos++) }\n};\nStringStream.prototype.eat = function (match) {\n  var ch = this.string.charAt(this.pos);\n  var ok;\n  if (typeof match == \"string\") { ok = ch == match; }\n  else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\n  if (ok) {++this.pos; return ch}\n};\nStringStream.prototype.eatWhile = function (match) {\n  var start = this.pos;\n  while (this.eat(match)){}\n  return this.pos > start\n};\nStringStream.prototype.eatSpace = function () {\n    var this$1 = this;\n\n  var start = this.pos;\n  while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }\n  return this.pos > start\n};\nStringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\nStringStream.prototype.skipTo = function (ch) {\n  var found = this.string.indexOf(ch, this.pos);\n  if (found > -1) {this.pos = found; return true}\n};\nStringStream.prototype.backUp = function (n) {this.pos -= n;};\nStringStream.prototype.column = function () {\n  if (this.lastColumnPos < this.start) {\n    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n    this.lastColumnPos = this.start;\n  }\n  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n};\nStringStream.prototype.indentation = function () {\n  return countColumn(this.string, null, this.tabSize) -\n    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n};\nStringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n  if (typeof pattern == \"string\") {\n    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n    var substr = this.string.substr(this.pos, pattern.length);\n    if (cased(substr) == cased(pattern)) {\n      if (consume !== false) { this.pos += pattern.length; }\n      return true\n    }\n  } else {\n    var match = this.string.slice(this.pos).match(pattern);\n    if (match && match.index > 0) { return null }\n    if (match && consume !== false) { this.pos += match[0].length; }\n    return match\n  }\n};\nStringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\nStringStream.prototype.hideFirstChars = function (n, inner) {\n  this.lineStart += n;\n  try { return inner() }\n  finally { this.lineStart -= n; }\n};\nStringStream.prototype.lookAhead = function (n) {\n  var oracle = this.lineOracle;\n  return oracle && oracle.lookAhead(n)\n};\n\nvar SavedContext = function(state, lookAhead) {\n  this.state = state;\n  this.lookAhead = lookAhead;\n};\n\nvar Context = function(doc, state, line, lookAhead) {\n  this.state = state;\n  this.doc = doc;\n  this.line = line;\n  this.maxLookAhead = lookAhead || 0;\n};\n\nContext.prototype.lookAhead = function (n) {\n  var line = this.doc.getLine(this.line + n);\n  if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }\n  return line\n};\n\nContext.prototype.nextLine = function () {\n  this.line++;\n  if (this.maxLookAhead > 0) { this.maxLookAhead--; }\n};\n\nContext.fromSaved = function (doc, saved, line) {\n  if (saved instanceof SavedContext)\n    { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }\n  else\n    { return new Context(doc, copyState(doc.mode, saved), line) }\n};\n\nContext.prototype.save = function (copy) {\n  var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n  return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state\n};\n\n\n// Compute a style array (an array starting with a mode generation\n// -- for invalidation -- followed by pairs of end positions and\n// style strings), which is used to highlight the tokens on the\n// line.\nfunction highlightLine(cm, line, context, forceToEnd) {\n  // A styles array always starts with a number identifying the\n  // mode/overlays that it is based on (for easy invalidation).\n  var st = [cm.state.modeGen], lineClasses = {};\n  // Compute the base array of styles\n  runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },\n          lineClasses, forceToEnd);\n  var state = context.state;\n\n  // Run overlays, adjust style array.\n  var loop = function ( o ) {\n    var overlay = cm.state.overlays[o], i = 1, at = 0;\n    context.state = true;\n    runMode(cm, line.text, overlay.mode, context, function (end, style) {\n      var start = i;\n      // Ensure there's a token end at the current position, and that i points at it\n      while (at < end) {\n        var i_end = st[i];\n        if (i_end > end)\n          { st.splice(i, 1, end, st[i+1], i_end); }\n        i += 2;\n        at = Math.min(end, i_end);\n      }\n      if (!style) { return }\n      if (overlay.opaque) {\n        st.splice(start, i - start, end, \"overlay \" + style);\n        i = start + 2;\n      } else {\n        for (; start < i; start += 2) {\n          var cur = st[start+1];\n          st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n        }\n      }\n    }, lineClasses);\n  };\n\n  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\n  context.state = state;\n\n  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\n}\n\nfunction getLineStyles(cm, line, updateFrontier) {\n  if (!line.styles || line.styles[0] != cm.state.modeGen) {\n    var context = getContextBefore(cm, lineNo(line));\n    var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n    var result = highlightLine(cm, line, context);\n    if (resetState) { context.state = resetState; }\n    line.stateAfter = context.save(!resetState);\n    line.styles = result.styles;\n    if (result.classes) { line.styleClasses = result.classes; }\n    else if (line.styleClasses) { line.styleClasses = null; }\n    if (updateFrontier === cm.doc.highlightFrontier)\n      { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }\n  }\n  return line.styles\n}\n\nfunction getContextBefore(cm, n, precise) {\n  var doc = cm.doc, display = cm.display;\n  if (!doc.mode.startState) { return new Context(doc, true, n) }\n  var start = findStartLine(cm, n, precise);\n  var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n  var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n\n  doc.iter(start, n, function (line) {\n    processLine(cm, line.text, context);\n    var pos = context.line;\n    line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n    context.nextLine();\n  });\n  if (precise) { doc.modeFrontier = context.line; }\n  return context\n}\n\n// Lightweight form of highlight -- proceed over this line and\n// update state, but don't save a style array. Used for lines that\n// aren't currently visible.\nfunction processLine(cm, text, context, startAt) {\n  var mode = cm.doc.mode;\n  var stream = new StringStream(text, cm.options.tabSize, context);\n  stream.start = stream.pos = startAt || 0;\n  if (text == \"\") { callBlankLine(mode, context.state); }\n  while (!stream.eol()) {\n    readToken(mode, stream, context.state);\n    stream.start = stream.pos;\n  }\n}\n\nfunction callBlankLine(mode, state) {\n  if (mode.blankLine) { return mode.blankLine(state) }\n  if (!mode.innerMode) { return }\n  var inner = innerMode(mode, state);\n  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\n}\n\nfunction readToken(mode, stream, state, inner) {\n  for (var i = 0; i < 10; i++) {\n    if (inner) { inner[0] = innerMode(mode, state).mode; }\n    var style = mode.token(stream, state);\n    if (stream.pos > stream.start) { return style }\n  }\n  throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\n}\n\nvar Token = function(stream, type, state) {\n  this.start = stream.start; this.end = stream.pos;\n  this.string = stream.current();\n  this.type = type || null;\n  this.state = state;\n};\n\n// Utility for getTokenAt and getLineTokens\nfunction takeToken(cm, pos, precise, asArray) {\n  var doc = cm.doc, mode = doc.mode, style;\n  pos = clipPos(doc, pos);\n  var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n  var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n  if (asArray) { tokens = []; }\n  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n    stream.start = stream.pos;\n    style = readToken(mode, stream, context.state);\n    if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }\n  }\n  return asArray ? tokens : new Token(stream, style, context.state)\n}\n\nfunction extractLineClasses(type, output) {\n  if (type) { for (;;) {\n    var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n    if (!lineClass) { break }\n    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n    var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n    if (output[prop] == null)\n      { output[prop] = lineClass[2]; }\n    else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n      { output[prop] += \" \" + lineClass[2]; }\n  } }\n  return type\n}\n\n// Run the given mode's parser over a line, calling f for each token.\nfunction runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n  var flattenSpans = mode.flattenSpans;\n  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\n  var curStart = 0, curStyle = null;\n  var stream = new StringStream(text, cm.options.tabSize, context), style;\n  var inner = cm.options.addModeClass && [null];\n  if (text == \"\") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }\n  while (!stream.eol()) {\n    if (stream.pos > cm.options.maxHighlightLength) {\n      flattenSpans = false;\n      if (forceToEnd) { processLine(cm, text, context, stream.pos); }\n      stream.pos = text.length;\n      style = null;\n    } else {\n      style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n    }\n    if (inner) {\n      var mName = inner[0].name;\n      if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\n    }\n    if (!flattenSpans || curStyle != style) {\n      while (curStart < stream.start) {\n        curStart = Math.min(stream.start, curStart + 5000);\n        f(curStart, curStyle);\n      }\n      curStyle = style;\n    }\n    stream.start = stream.pos;\n  }\n  while (curStart < stream.pos) {\n    // Webkit seems to refuse to render text nodes longer than 57444\n    // characters, and returns inaccurate measurements in nodes\n    // starting around 5000 chars.\n    var pos = Math.min(stream.pos, curStart + 5000);\n    f(pos, curStyle);\n    curStart = pos;\n  }\n}\n\n// Finds the line to start with when starting a parse. Tries to\n// find a line with a stateAfter, so that it can start with a\n// valid state. If that fails, it returns the line with the\n// smallest indentation, which tends to need the least context to\n// parse correctly.\nfunction findStartLine(cm, n, precise) {\n  var minindent, minline, doc = cm.doc;\n  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n  for (var search = n; search > lim; --search) {\n    if (search <= doc.first) { return doc.first }\n    var line = getLine(doc, search - 1), after = line.stateAfter;\n    if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))\n      { return search }\n    var indented = countColumn(line.text, null, cm.options.tabSize);\n    if (minline == null || minindent > indented) {\n      minline = search - 1;\n      minindent = indented;\n    }\n  }\n  return minline\n}\n\nfunction retreatFrontier(doc, n) {\n  doc.modeFrontier = Math.min(doc.modeFrontier, n);\n  if (doc.highlightFrontier < n - 10) { return }\n  var start = doc.first;\n  for (var line = n - 1; line > start; line--) {\n    var saved = getLine(doc, line).stateAfter;\n    // change is on 3\n    // state on line 1 looked ahead 2 -- so saw 3\n    // test 1 + 2 < 3 should cover this\n    if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n      start = line + 1;\n      break\n    }\n  }\n  doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n}\n\n// LINE DATA STRUCTURE\n\n// Line objects. These hold state related to a line, including\n// highlighting info (the styles array).\nvar Line = function(text, markedSpans, estimateHeight) {\n  this.text = text;\n  attachMarkedSpans(this, markedSpans);\n  this.height = estimateHeight ? estimateHeight(this) : 1;\n};\n\nLine.prototype.lineNo = function () { return lineNo(this) };\neventMixin(Line);\n\n// Change the content (text, markers) of a line. Automatically\n// invalidates cached information and tries to re-estimate the\n// line's height.\nfunction updateLine(line, text, markedSpans, estimateHeight) {\n  line.text = text;\n  if (line.stateAfter) { line.stateAfter = null; }\n  if (line.styles) { line.styles = null; }\n  if (line.order != null) { line.order = null; }\n  detachMarkedSpans(line);\n  attachMarkedSpans(line, markedSpans);\n  var estHeight = estimateHeight ? estimateHeight(line) : 1;\n  if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n}\n\n// Detach a line from the document tree and its markers.\nfunction cleanUpLine(line) {\n  line.parent = null;\n  detachMarkedSpans(line);\n}\n\n// Convert a style as returned by a mode (either null, or a string\n// containing one or more styles) to a CSS style. This is cached,\n// and also looks for line-wide styles.\nvar styleToClassCache = {};\nvar styleToClassCacheWithMode = {};\nfunction interpretTokenStyle(style, options) {\n  if (!style || /^\\s*$/.test(style)) { return null }\n  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n  return cache[style] ||\n    (cache[style] = style.replace(/\\S+/g, \"cm-$&\"))\n}\n\n// Render the DOM representation of the text of a line. Also builds\n// up a 'line map', which points at the DOM nodes that represent\n// specific stretches of text, and is used by the measuring code.\n// The returned object contains the DOM node, this map, and\n// information about line-wide styles that were set by the mode.\nfunction buildLineContent(cm, lineView) {\n  // The padding-right forces the element to have a 'border', which\n  // is needed on Webkit to be able to get line-level bounding\n  // rectangles for it (in measureChar).\n  var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n  var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                 col: 0, pos: 0, cm: cm,\n                 trailingSpace: false,\n                 splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\n  lineView.measure = {};\n\n  // Iterate over the logical lines that make up this visual line.\n  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\n    builder.pos = 0;\n    builder.addToken = buildToken;\n    // Optionally wire in some hacks into the token-rendering\n    // algorithm, to deal with browser quirks.\n    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\n      { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\n    builder.map = [];\n    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n    if (line.styleClasses) {\n      if (line.styleClasses.bgClass)\n        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\n      if (line.styleClasses.textClass)\n        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\n    }\n\n    // Ensure at least a single node is present, for measuring.\n    if (builder.map.length == 0)\n      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\n\n    // Store the map and a cache object for the current logical line\n    if (i == 0) {\n      lineView.measure.map = builder.map;\n      lineView.measure.cache = {};\n    } else {\n      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\n      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\n    }\n  }\n\n  // See issue #2901\n  if (webkit) {\n    var last = builder.content.lastChild;\n    if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n      { builder.content.className = \"cm-tab-wrap-hack\"; }\n  }\n\n  signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n  if (builder.pre.className)\n    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\n\n  return builder\n}\n\nfunction defaultSpecialCharPlaceholder(ch) {\n  var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n  token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n  token.setAttribute(\"aria-label\", token.title);\n  return token\n}\n\n// Build up the DOM representation for a single token, and add it to\n// the line map. Takes care to render special characters separately.\nfunction buildToken(builder, text, style, startStyle, endStyle, title, css) {\n  if (!text) { return }\n  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n  var special = builder.cm.state.specialChars, mustWrap = false;\n  var content;\n  if (!special.test(text)) {\n    builder.col += text.length;\n    content = document.createTextNode(displayText);\n    builder.map.push(builder.pos, builder.pos + text.length, content);\n    if (ie && ie_version < 9) { mustWrap = true; }\n    builder.pos += text.length;\n  } else {\n    content = document.createDocumentFragment();\n    var pos = 0;\n    while (true) {\n      special.lastIndex = pos;\n      var m = special.exec(text);\n      var skipped = m ? m.index - pos : text.length - pos;\n      if (skipped) {\n        var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n        if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt])); }\n        else { content.appendChild(txt); }\n        builder.map.push(builder.pos, builder.pos + skipped, txt);\n        builder.col += skipped;\n        builder.pos += skipped;\n      }\n      if (!m) { break }\n      pos += skipped + 1;\n      var txt$1 = (void 0);\n      if (m[0] == \"\\t\") {\n        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n        txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n        txt$1.setAttribute(\"role\", \"presentation\");\n        txt$1.setAttribute(\"cm-text\", \"\\t\");\n        builder.col += tabWidth;\n      } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n        txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n        txt$1.setAttribute(\"cm-text\", m[0]);\n        builder.col += 1;\n      } else {\n        txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n        txt$1.setAttribute(\"cm-text\", m[0]);\n        if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt$1])); }\n        else { content.appendChild(txt$1); }\n        builder.col += 1;\n      }\n      builder.map.push(builder.pos, builder.pos + 1, txt$1);\n      builder.pos++;\n    }\n  }\n  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n  if (style || startStyle || endStyle || mustWrap || css) {\n    var fullStyle = style || \"\";\n    if (startStyle) { fullStyle += startStyle; }\n    if (endStyle) { fullStyle += endStyle; }\n    var token = elt(\"span\", [content], fullStyle, css);\n    if (title) { token.title = title; }\n    return builder.content.appendChild(token)\n  }\n  builder.content.appendChild(content);\n}\n\nfunction splitSpaces(text, trailingBefore) {\n  if (text.length > 1 && !/  /.test(text)) { return text }\n  var spaceBefore = trailingBefore, result = \"\";\n  for (var i = 0; i < text.length; i++) {\n    var ch = text.charAt(i);\n    if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n      { ch = \"\\u00a0\"; }\n    result += ch;\n    spaceBefore = ch == \" \";\n  }\n  return result\n}\n\n// Work around nonsense dimensions being reported for stretches of\n// right-to-left text.\nfunction buildTokenBadBidi(inner, order) {\n  return function (builder, text, style, startStyle, endStyle, title, css) {\n    style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n    var start = builder.pos, end = start + text.length;\n    for (;;) {\n      // Find the part that overlaps with the start of this text\n      var part = (void 0);\n      for (var i = 0; i < order.length; i++) {\n        part = order[i];\n        if (part.to > start && part.from <= start) { break }\n      }\n      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }\n      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\n      startStyle = null;\n      text = text.slice(part.to - start);\n      start = part.to;\n    }\n  }\n}\n\nfunction buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n  var widget = !ignoreWidget && marker.widgetNode;\n  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\n  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n    if (!widget)\n      { widget = builder.content.appendChild(document.createElement(\"span\")); }\n    widget.setAttribute(\"cm-marker\", marker.id);\n  }\n  if (widget) {\n    builder.cm.display.input.setUneditable(widget);\n    builder.content.appendChild(widget);\n  }\n  builder.pos += size;\n  builder.trailingSpace = false;\n}\n\n// Outputs a number of spans to make up a line, taking highlighting\n// and marked text into account.\nfunction insertLineContent(line, builder, styles) {\n  var spans = line.markedSpans, allText = line.text, at = 0;\n  if (!spans) {\n    for (var i$1 = 1; i$1 < styles.length; i$1+=2)\n      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\n    return\n  }\n\n  var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n  for (;;) {\n    if (nextChange == pos) { // Update current marker set\n      spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\n      collapsed = null; nextChange = Infinity;\n      var foundBookmarks = [], endStyles = (void 0);\n      for (var j = 0; j < spans.length; ++j) {\n        var sp = spans[j], m = sp.marker;\n        if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n          foundBookmarks.push(m);\n        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n          if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n            nextChange = sp.to;\n            spanEndStyle = \"\";\n          }\n          if (m.className) { spanStyle += \" \" + m.className; }\n          if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\n          if (m.startStyle && sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\n          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\n          if (m.title && !title) { title = m.title; }\n          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n            { collapsed = sp; }\n        } else if (sp.from > pos && nextChange > sp.from) {\n          nextChange = sp.from;\n        }\n      }\n      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\n        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\n\n      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\n        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\n      if (collapsed && (collapsed.from || 0) == pos) {\n        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                           collapsed.marker, collapsed.from == null);\n        if (collapsed.to == null) { return }\n        if (collapsed.to == pos) { collapsed = false; }\n      }\n    }\n    if (pos >= len) { break }\n\n    var upto = Math.min(len, nextChange);\n    while (true) {\n      if (text) {\n        var end = pos + text.length;\n        if (!collapsed) {\n          var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\n        }\n        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\n        pos = end;\n        spanStartStyle = \"\";\n      }\n      text = allText.slice(at, at = styles[i++]);\n      style = interpretTokenStyle(styles[i++], builder.cm.options);\n    }\n  }\n}\n\n\n// These objects are used to represent the visible (currently drawn)\n// part of the document. A LineView may correspond to multiple\n// logical lines, if those are connected by collapsed ranges.\nfunction LineView(doc, line, lineN) {\n  // The starting line\n  this.line = line;\n  // Continuing lines, if any\n  this.rest = visualLineContinued(line);\n  // Number of logical lines in this visual line\n  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n  this.node = this.text = null;\n  this.hidden = lineIsHidden(doc, line);\n}\n\n// Create a range of LineView objects for the given lines.\nfunction buildViewArray(cm, from, to) {\n  var array = [], nextPos;\n  for (var pos = from; pos < to; pos = nextPos) {\n    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n    nextPos = pos + view.size;\n    array.push(view);\n  }\n  return array\n}\n\nvar operationGroup = null;\n\nfunction pushOperation(op) {\n  if (operationGroup) {\n    operationGroup.ops.push(op);\n  } else {\n    op.ownsGroup = operationGroup = {\n      ops: [op],\n      delayedCallbacks: []\n    };\n  }\n}\n\nfunction fireCallbacksForOps(group) {\n  // Calls delayed callbacks and cursorActivity handlers until no\n  // new ones appear\n  var callbacks = group.delayedCallbacks, i = 0;\n  do {\n    for (; i < callbacks.length; i++)\n      { callbacks[i].call(null); }\n    for (var j = 0; j < group.ops.length; j++) {\n      var op = group.ops[j];\n      if (op.cursorActivityHandlers)\n        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\n    }\n  } while (i < callbacks.length)\n}\n\nfunction finishOperation(op, endCb) {\n  var group = op.ownsGroup;\n  if (!group) { return }\n\n  try { fireCallbacksForOps(group); }\n  finally {\n    operationGroup = null;\n    endCb(group);\n  }\n}\n\nvar orphanDelayedCallbacks = null;\n\n// Often, we want to signal events at a point where we are in the\n// middle of some work, but don't want the handler to start calling\n// other methods on the editor, which might be in an inconsistent\n// state or simply not expect any other events to happen.\n// signalLater looks whether there are any handlers, and schedules\n// them to be executed when the last operation ends, or, if no\n// operation is active, when a timeout fires.\nfunction signalLater(emitter, type /*, values...*/) {\n  var arr = getHandlers(emitter, type);\n  if (!arr.length) { return }\n  var args = Array.prototype.slice.call(arguments, 2), list;\n  if (operationGroup) {\n    list = operationGroup.delayedCallbacks;\n  } else if (orphanDelayedCallbacks) {\n    list = orphanDelayedCallbacks;\n  } else {\n    list = orphanDelayedCallbacks = [];\n    setTimeout(fireOrphanDelayed, 0);\n  }\n  var loop = function ( i ) {\n    list.push(function () { return arr[i].apply(null, args); });\n  };\n\n  for (var i = 0; i < arr.length; ++i)\n    loop( i );\n}\n\nfunction fireOrphanDelayed() {\n  var delayed = orphanDelayedCallbacks;\n  orphanDelayedCallbacks = null;\n  for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\n}\n\n// When an aspect of a line changes, a string is added to\n// lineView.changes. This updates the relevant part of the line's\n// DOM structure.\nfunction updateLineForChanges(cm, lineView, lineN, dims) {\n  for (var j = 0; j < lineView.changes.length; j++) {\n    var type = lineView.changes[j];\n    if (type == \"text\") { updateLineText(cm, lineView); }\n    else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\n    else if (type == \"class\") { updateLineClasses(cm, lineView); }\n    else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\n  }\n  lineView.changes = null;\n}\n\n// Lines with gutter elements, widgets or a background class need to\n// be wrapped, and have the extra elements added to the wrapper div\nfunction ensureLineWrapped(lineView) {\n  if (lineView.node == lineView.text) {\n    lineView.node = elt(\"div\", null, null, \"position: relative\");\n    if (lineView.text.parentNode)\n      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\n    lineView.node.appendChild(lineView.text);\n    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\n  }\n  return lineView.node\n}\n\nfunction updateLineBackground(cm, lineView) {\n  var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n  if (cls) { cls += \" CodeMirror-linebackground\"; }\n  if (lineView.background) {\n    if (cls) { lineView.background.className = cls; }\n    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n  } else if (cls) {\n    var wrap = ensureLineWrapped(lineView);\n    lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n    cm.display.input.setUneditable(lineView.background);\n  }\n}\n\n// Wrapper around buildLineContent which will reuse the structure\n// in display.externalMeasured when possible.\nfunction getLineContent(cm, lineView) {\n  var ext = cm.display.externalMeasured;\n  if (ext && ext.line == lineView.line) {\n    cm.display.externalMeasured = null;\n    lineView.measure = ext.measure;\n    return ext.built\n  }\n  return buildLineContent(cm, lineView)\n}\n\n// Redraw the line's text. Interacts with the background and text\n// classes because the mode may output tokens that influence these\n// classes.\nfunction updateLineText(cm, lineView) {\n  var cls = lineView.text.className;\n  var built = getLineContent(cm, lineView);\n  if (lineView.text == lineView.node) { lineView.node = built.pre; }\n  lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n  lineView.text = built.pre;\n  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n    lineView.bgClass = built.bgClass;\n    lineView.textClass = built.textClass;\n    updateLineClasses(cm, lineView);\n  } else if (cls) {\n    lineView.text.className = cls;\n  }\n}\n\nfunction updateLineClasses(cm, lineView) {\n  updateLineBackground(cm, lineView);\n  if (lineView.line.wrapClass)\n    { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\n  else if (lineView.node != lineView.text)\n    { lineView.node.className = \"\"; }\n  var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n  lineView.text.className = textClass || \"\";\n}\n\nfunction updateLineGutter(cm, lineView, lineN, dims) {\n  if (lineView.gutter) {\n    lineView.node.removeChild(lineView.gutter);\n    lineView.gutter = null;\n  }\n  if (lineView.gutterBackground) {\n    lineView.node.removeChild(lineView.gutterBackground);\n    lineView.gutterBackground = null;\n  }\n  if (lineView.line.gutterClass) {\n    var wrap = ensureLineWrapped(lineView);\n    lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                    (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\n    cm.display.input.setUneditable(lineView.gutterBackground);\n    wrap.insertBefore(lineView.gutterBackground, lineView.text);\n  }\n  var markers = lineView.line.gutterMarkers;\n  if (cm.options.lineNumbers || markers) {\n    var wrap$1 = ensureLineWrapped(lineView);\n    var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\n    cm.display.input.setUneditable(gutterWrap);\n    wrap$1.insertBefore(gutterWrap, lineView.text);\n    if (lineView.line.gutterClass)\n      { gutterWrap.className += \" \" + lineView.line.gutterClass; }\n    if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n      { lineView.lineNumber = gutterWrap.appendChild(\n        elt(\"div\", lineNumberFor(cm.options, lineN),\n            \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n            (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\n    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {\n      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n      if (found)\n        { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\n                                   (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\n    } }\n  }\n}\n\nfunction updateLineWidgets(cm, lineView, dims) {\n  if (lineView.alignable) { lineView.alignable = null; }\n  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\n    next = node.nextSibling;\n    if (node.className == \"CodeMirror-linewidget\")\n      { lineView.node.removeChild(node); }\n  }\n  insertLineWidgets(cm, lineView, dims);\n}\n\n// Build a line's DOM representation from scratch\nfunction buildLineElement(cm, lineView, lineN, dims) {\n  var built = getLineContent(cm, lineView);\n  lineView.text = lineView.node = built.pre;\n  if (built.bgClass) { lineView.bgClass = built.bgClass; }\n  if (built.textClass) { lineView.textClass = built.textClass; }\n\n  updateLineClasses(cm, lineView);\n  updateLineGutter(cm, lineView, lineN, dims);\n  insertLineWidgets(cm, lineView, dims);\n  return lineView.node\n}\n\n// A lineView may contain multiple logical lines (when merged by\n// collapsed spans). The widgets for all of them need to be drawn.\nfunction insertLineWidgets(cm, lineView, dims) {\n  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\n}\n\nfunction insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n  if (!line.widgets) { return }\n  var wrap = ensureLineWrapped(lineView);\n  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n    var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n    if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\n    positionLineWidget(widget, node, lineView, dims);\n    cm.display.input.setUneditable(node);\n    if (allowAbove && widget.above)\n      { wrap.insertBefore(node, lineView.gutter || lineView.text); }\n    else\n      { wrap.appendChild(node); }\n    signalLater(widget, \"redraw\");\n  }\n}\n\nfunction positionLineWidget(widget, node, lineView, dims) {\n  if (widget.noHScroll) {\n    (lineView.alignable || (lineView.alignable = [])).push(node);\n    var width = dims.wrapperWidth;\n    node.style.left = dims.fixedPos + \"px\";\n    if (!widget.coverGutter) {\n      width -= dims.gutterTotalWidth;\n      node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n    }\n    node.style.width = width + \"px\";\n  }\n  if (widget.coverGutter) {\n    node.style.zIndex = 5;\n    node.style.position = \"relative\";\n    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\n  }\n}\n\nfunction widgetHeight(widget) {\n  if (widget.height != null) { return widget.height }\n  var cm = widget.doc.cm;\n  if (!cm) { return 0 }\n  if (!contains(document.body, widget.node)) {\n    var parentStyle = \"position: relative;\";\n    if (widget.coverGutter)\n      { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\n    if (widget.noHScroll)\n      { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\n    removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n  }\n  return widget.height = widget.node.parentNode.offsetHeight\n}\n\n// Return true when the given mouse event happened in a widget\nfunction eventInWidget(display, e) {\n  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n    if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n        (n.parentNode == display.sizer && n != display.mover))\n      { return true }\n  }\n}\n\n// POSITION MEASUREMENT\n\nfunction paddingTop(display) {return display.lineSpace.offsetTop}\nfunction paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\nfunction paddingH(display) {\n  if (display.cachedPaddingH) { return display.cachedPaddingH }\n  var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\n  return data\n}\n\nfunction scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\nfunction displayWidth(cm) {\n  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\n}\nfunction displayHeight(cm) {\n  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\n}\n\n// Ensure the lineView.wrapping.heights array is populated. This is\n// an array of bottom offsets for the lines that make up a drawn\n// line. When lineWrapping is on, there might be more than one\n// height.\nfunction ensureLineHeights(cm, lineView, rect) {\n  var wrapping = cm.options.lineWrapping;\n  var curWidth = wrapping && displayWidth(cm);\n  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n    var heights = lineView.measure.heights = [];\n    if (wrapping) {\n      lineView.measure.width = curWidth;\n      var rects = lineView.text.firstChild.getClientRects();\n      for (var i = 0; i < rects.length - 1; i++) {\n        var cur = rects[i], next = rects[i + 1];\n        if (Math.abs(cur.bottom - next.bottom) > 2)\n          { heights.push((cur.bottom + next.top) / 2 - rect.top); }\n      }\n    }\n    heights.push(rect.bottom - rect.top);\n  }\n}\n\n// Find a line map (mapping character offsets to text nodes) and a\n// measurement cache for the given line number. (A line view might\n// contain multiple lines when collapsed ranges are present.)\nfunction mapFromLineView(lineView, line, lineN) {\n  if (lineView.line == line)\n    { return {map: lineView.measure.map, cache: lineView.measure.cache} }\n  for (var i = 0; i < lineView.rest.length; i++)\n    { if (lineView.rest[i] == line)\n      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\n  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\n    { if (lineNo(lineView.rest[i$1]) > lineN)\n      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\n}\n\n// Render a line into the hidden node display.externalMeasured. Used\n// when measurement is needed for a line that's not in the viewport.\nfunction updateExternalMeasurement(cm, line) {\n  line = visualLine(line);\n  var lineN = lineNo(line);\n  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n  view.lineN = lineN;\n  var built = view.built = buildLineContent(cm, view);\n  view.text = built.pre;\n  removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n  return view\n}\n\n// Get a {top, bottom, left, right} box (in line-local coordinates)\n// for a given character.\nfunction measureChar(cm, line, ch, bias) {\n  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\n}\n\n// Find a line view that corresponds to the given line number.\nfunction findViewForLine(cm, lineN) {\n  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n    { return cm.display.view[findViewIndex(cm, lineN)] }\n  var ext = cm.display.externalMeasured;\n  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n    { return ext }\n}\n\n// Measurement can be split in two steps, the set-up work that\n// applies to the whole line, and the measurement of the actual\n// character. Functions like coordsChar, that need to do a lot of\n// measurements in a row, can thus ensure that the set-up work is\n// only done once.\nfunction prepareMeasureForLine(cm, line) {\n  var lineN = lineNo(line);\n  var view = findViewForLine(cm, lineN);\n  if (view && !view.text) {\n    view = null;\n  } else if (view && view.changes) {\n    updateLineForChanges(cm, view, lineN, getDimensions(cm));\n    cm.curOp.forceUpdate = true;\n  }\n  if (!view)\n    { view = updateExternalMeasurement(cm, line); }\n\n  var info = mapFromLineView(view, line, lineN);\n  return {\n    line: line, view: view, rect: null,\n    map: info.map, cache: info.cache, before: info.before,\n    hasHeights: false\n  }\n}\n\n// Given a prepared measurement object, measures the position of an\n// actual character (or fetches it from the cache).\nfunction measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n  if (prepared.before) { ch = -1; }\n  var key = ch + (bias || \"\"), found;\n  if (prepared.cache.hasOwnProperty(key)) {\n    found = prepared.cache[key];\n  } else {\n    if (!prepared.rect)\n      { prepared.rect = prepared.view.text.getBoundingClientRect(); }\n    if (!prepared.hasHeights) {\n      ensureLineHeights(cm, prepared.view, prepared.rect);\n      prepared.hasHeights = true;\n    }\n    found = measureCharInner(cm, prepared, ch, bias);\n    if (!found.bogus) { prepared.cache[key] = found; }\n  }\n  return {left: found.left, right: found.right,\n          top: varHeight ? found.rtop : found.top,\n          bottom: varHeight ? found.rbottom : found.bottom}\n}\n\nvar nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\nfunction nodeAndOffsetInLineMap(map$$1, ch, bias) {\n  var node, start, end, collapse, mStart, mEnd;\n  // First, search the line map for the text node corresponding to,\n  // or closest to, the target character.\n  for (var i = 0; i < map$$1.length; i += 3) {\n    mStart = map$$1[i];\n    mEnd = map$$1[i + 1];\n    if (ch < mStart) {\n      start = 0; end = 1;\n      collapse = \"left\";\n    } else if (ch < mEnd) {\n      start = ch - mStart;\n      end = start + 1;\n    } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {\n      end = mEnd - mStart;\n      start = end - 1;\n      if (ch >= mEnd) { collapse = \"right\"; }\n    }\n    if (start != null) {\n      node = map$$1[i + 2];\n      if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n        { collapse = bias; }\n      if (bias == \"left\" && start == 0)\n        { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {\n          node = map$$1[(i -= 3) + 2];\n          collapse = \"left\";\n        } }\n      if (bias == \"right\" && start == mEnd - mStart)\n        { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {\n          node = map$$1[(i += 3) + 2];\n          collapse = \"right\";\n        } }\n      break\n    }\n  }\n  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\n}\n\nfunction getUsefulRect(rects, bias) {\n  var rect = nullRect;\n  if (bias == \"left\") { for (var i = 0; i < rects.length; i++) {\n    if ((rect = rects[i]).left != rect.right) { break }\n  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n    if ((rect = rects[i$1]).left != rect.right) { break }\n  } }\n  return rect\n}\n\nfunction measureCharInner(cm, prepared, ch, bias) {\n  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n  var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n  var rect;\n  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\n      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\n      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n        { rect = node.parentNode.getBoundingClientRect(); }\n      else\n        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\n      if (rect.left || rect.right || start == 0) { break }\n      end = start;\n      start = start - 1;\n      collapse = \"right\";\n    }\n    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\n  } else { // If it is a widget, simply get the box for the whole widget.\n    if (start > 0) { collapse = bias = \"right\"; }\n    var rects;\n    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n      { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\n    else\n      { rect = node.getBoundingClientRect(); }\n  }\n  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n    var rSpan = node.parentNode.getClientRects()[0];\n    if (rSpan)\n      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\n    else\n      { rect = nullRect; }\n  }\n\n  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n  var mid = (rtop + rbot) / 2;\n  var heights = prepared.view.measure.heights;\n  var i = 0;\n  for (; i < heights.length - 1; i++)\n    { if (mid < heights[i]) { break } }\n  var top = i ? heights[i - 1] : 0, bot = heights[i];\n  var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                top: top, bottom: bot};\n  if (!rect.left && !rect.right) { result.bogus = true; }\n  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n  return result\n}\n\n// Work around problem with bounding client rects on ranges being\n// returned incorrectly when zoomed on IE10 and below.\nfunction maybeUpdateRectForZooming(measure, rect) {\n  if (!window.screen || screen.logicalXDPI == null ||\n      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n    { return rect }\n  var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n  var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n  return {left: rect.left * scaleX, right: rect.right * scaleX,\n          top: rect.top * scaleY, bottom: rect.bottom * scaleY}\n}\n\nfunction clearLineMeasurementCacheFor(lineView) {\n  if (lineView.measure) {\n    lineView.measure.cache = {};\n    lineView.measure.heights = null;\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n      { lineView.measure.caches[i] = {}; } }\n  }\n}\n\nfunction clearLineMeasurementCache(cm) {\n  cm.display.externalMeasure = null;\n  removeChildren(cm.display.lineMeasure);\n  for (var i = 0; i < cm.display.view.length; i++)\n    { clearLineMeasurementCacheFor(cm.display.view[i]); }\n}\n\nfunction clearCaches(cm) {\n  clearLineMeasurementCache(cm);\n  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\n  cm.display.lineNumChars = null;\n}\n\nfunction pageScrollX() {\n  // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n  // which causes page_Offset and bounding client rects to use\n  // different reference viewports and invalidate our calculations.\n  if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\n  return window.pageXOffset || (document.documentElement || document.body).scrollLeft\n}\nfunction pageScrollY() {\n  if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\n  return window.pageYOffset || (document.documentElement || document.body).scrollTop\n}\n\n// Converts a {top, bottom, left, right} box from line-local\n// coordinates into another coordinate system. Context may be one of\n// \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n// or \"page\".\nfunction intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n  if (!includeWidgets && lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above) {\n    var size = widgetHeight(lineObj.widgets[i]);\n    rect.top += size; rect.bottom += size;\n  } } }\n  if (context == \"line\") { return rect }\n  if (!context) { context = \"local\"; }\n  var yOff = heightAtLine(lineObj);\n  if (context == \"local\") { yOff += paddingTop(cm.display); }\n  else { yOff -= cm.display.viewOffset; }\n  if (context == \"page\" || context == \"window\") {\n    var lOff = cm.display.lineSpace.getBoundingClientRect();\n    yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n    var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n    rect.left += xOff; rect.right += xOff;\n  }\n  rect.top += yOff; rect.bottom += yOff;\n  return rect\n}\n\n// Coverts a box from \"div\" coords to another coordinate system.\n// Context may be \"window\", \"page\", \"div\", or \"local\"./null.\nfunction fromCoordSystem(cm, coords, context) {\n  if (context == \"div\") { return coords }\n  var left = coords.left, top = coords.top;\n  // First move into \"page\" coordinate system\n  if (context == \"page\") {\n    left -= pageScrollX();\n    top -= pageScrollY();\n  } else if (context == \"local\" || !context) {\n    var localBox = cm.display.sizer.getBoundingClientRect();\n    left += localBox.left;\n    top += localBox.top;\n  }\n\n  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\n}\n\nfunction charCoords(cm, pos, context, lineObj, bias) {\n  if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\n  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\n}\n\n// Returns a box for a given cursor position, which may have an\n// 'other' property containing the position of the secondary cursor\n// on a bidi boundary.\n// A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n// and after `char - 1` in writing order of `char - 1`\n// A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n// and before `char` in writing order of `char`\n// Examples (upper-case letters are RTL, lower-case are LTR):\n//     Pos(0, 1, ...)\n//     before   after\n// ab     a|b     a|b\n// aB     a|B     aB|\n// Ab     |Ab     A|b\n// AB     B|A     B|A\n// Every position after the last character on a line is considered to stick\n// to the last character on the line.\nfunction cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n  lineObj = lineObj || getLine(cm.doc, pos.line);\n  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n  function get(ch, right) {\n    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n    if (right) { m.left = m.right; } else { m.right = m.left; }\n    return intoCoordSystem(cm, lineObj, m, context)\n  }\n  var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n  if (ch >= lineObj.text.length) {\n    ch = lineObj.text.length;\n    sticky = \"before\";\n  } else if (ch <= 0) {\n    ch = 0;\n    sticky = \"after\";\n  }\n  if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\n\n  function getBidi(ch, partPos, invert) {\n    var part = order[partPos], right = (part.level % 2) != 0;\n    return get(invert ? ch - 1 : ch, right != invert)\n  }\n  var partPos = getBidiPartAt(order, ch, sticky);\n  var other = bidiOther;\n  var val = getBidi(ch, partPos, sticky == \"before\");\n  if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\n  return val\n}\n\n// Used to cheaply estimate the coordinates for a position. Used for\n// intermediate scroll updates.\nfunction estimateCoords(cm, pos) {\n  var left = 0;\n  pos = clipPos(cm.doc, pos);\n  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\n  var lineObj = getLine(cm.doc, pos.line);\n  var top = heightAtLine(lineObj) + paddingTop(cm.display);\n  return {left: left, right: left, top: top, bottom: top + lineObj.height}\n}\n\n// Positions returned by coordsChar contain some extra information.\n// xRel is the relative x position of the input coordinates compared\n// to the found position (so xRel > 0 means the coordinates are to\n// the right of the character position, for example). When outside\n// is true, that means the coordinates lie outside the line's\n// vertical range.\nfunction PosWithInfo(line, ch, sticky, outside, xRel) {\n  var pos = Pos(line, ch, sticky);\n  pos.xRel = xRel;\n  if (outside) { pos.outside = true; }\n  return pos\n}\n\n// Compute the character position closest to the given coordinates.\n// Input must be lineSpace-local (\"div\" coordinate system).\nfunction coordsChar(cm, x, y) {\n  var doc = cm.doc;\n  y += cm.display.viewOffset;\n  if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }\n  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n  if (lineN > last)\n    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }\n  if (x < 0) { x = 0; }\n\n  var lineObj = getLine(doc, lineN);\n  for (;;) {\n    var found = coordsCharInner(cm, lineObj, lineN, x, y);\n    var merged = collapsedSpanAtEnd(lineObj);\n    var mergedPos = merged && merged.find(0, true);\n    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n      { lineN = lineNo(lineObj = mergedPos.to.line); }\n    else\n      { return found }\n  }\n}\n\nfunction wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n  var measure = function (ch) { return intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), \"line\"); };\n  var end = lineObj.text.length;\n  var begin = findFirst(function (ch) { return measure(ch - 1).bottom <= y; }, end, 0);\n  end = findFirst(function (ch) { return measure(ch).top > y; }, begin, end);\n  return {begin: begin, end: end}\n}\n\nfunction wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n  var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\n}\n\nfunction coordsCharInner(cm, lineObj, lineNo$$1, x, y) {\n  y -= heightAtLine(lineObj);\n  var begin = 0, end = lineObj.text.length;\n  var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n  var pos;\n  var order = getOrder(lineObj, cm.doc.direction);\n  if (order) {\n    if (cm.options.lineWrapping) {\n      var assign;\n      ((assign = wrappedLineExtent(cm, lineObj, preparedMeasure, y), begin = assign.begin, end = assign.end, assign));\n    }\n    pos = new Pos(lineNo$$1, Math.floor(begin + (end - begin) / 2));\n    var beginLeft = cursorCoords(cm, pos, \"line\", lineObj, preparedMeasure).left;\n    var dir = beginLeft < x ? 1 : -1;\n    var prevDiff, diff = beginLeft - x, prevPos;\n    var steps = Math.ceil((end - begin) / 4);\n    outer: do {\n      prevDiff = diff;\n      prevPos = pos;\n      var i = 0;\n      for (; i < steps; ++i) {\n        var prevPos$1 = pos;\n        pos = moveVisually(cm, lineObj, pos, dir);\n        if (pos == null || pos.ch < begin || end <= (pos.sticky == \"before\" ? pos.ch - 1 : pos.ch)) {\n          pos = prevPos$1;\n          break outer\n        }\n      }\n      diff = cursorCoords(cm, pos, \"line\", lineObj, preparedMeasure).left - x;\n      if (steps > 1) {\n        var diff_change_per_step = Math.abs(diff - prevDiff) / steps;\n        steps = Math.min(steps, Math.ceil(Math.abs(diff) / diff_change_per_step));\n        dir = diff < 0 ? 1 : -1;\n      }\n    } while (diff != 0 && (steps > 1 || ((dir < 0) != (diff < 0) && (Math.abs(diff) <= Math.abs(prevDiff)))))\n    if (Math.abs(diff) > Math.abs(prevDiff)) {\n      if ((diff < 0) == (prevDiff < 0)) { throw new Error(\"Broke out of infinite loop in coordsCharInner\") }\n      pos = prevPos;\n    }\n  } else {\n    var ch = findFirst(function (ch) {\n      var box = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), \"line\");\n      if (box.top > y) {\n        // For the cursor stickiness\n        end = Math.min(ch, end);\n        return true\n      }\n      else if (box.bottom <= y) { return false }\n      else if (box.left > x) { return true }\n      else if (box.right < x) { return false }\n      else { return (x - box.left < box.right - x) }\n    }, begin, end);\n    ch = skipExtendingChars(lineObj.text, ch, 1);\n    pos = new Pos(lineNo$$1, ch, ch == end ? \"before\" : \"after\");\n  }\n  var coords = cursorCoords(cm, pos, \"line\", lineObj, preparedMeasure);\n  if (y < coords.top || coords.bottom < y) { pos.outside = true; }\n  pos.xRel = x < coords.left ? -1 : (x > coords.right ? 1 : 0);\n  return pos\n}\n\nvar measureText;\n// Compute the default text height.\nfunction textHeight(display) {\n  if (display.cachedTextHeight != null) { return display.cachedTextHeight }\n  if (measureText == null) {\n    measureText = elt(\"pre\");\n    // Measure a bunch of lines, for browsers that compute\n    // fractional heights.\n    for (var i = 0; i < 49; ++i) {\n      measureText.appendChild(document.createTextNode(\"x\"));\n      measureText.appendChild(elt(\"br\"));\n    }\n    measureText.appendChild(document.createTextNode(\"x\"));\n  }\n  removeChildrenAndAdd(display.measure, measureText);\n  var height = measureText.offsetHeight / 50;\n  if (height > 3) { display.cachedTextHeight = height; }\n  removeChildren(display.measure);\n  return height || 1\n}\n\n// Compute the default character width.\nfunction charWidth(display) {\n  if (display.cachedCharWidth != null) { return display.cachedCharWidth }\n  var anchor = elt(\"span\", \"xxxxxxxxxx\");\n  var pre = elt(\"pre\", [anchor]);\n  removeChildrenAndAdd(display.measure, pre);\n  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n  if (width > 2) { display.cachedCharWidth = width; }\n  return width || 10\n}\n\n// Do a bulk-read of the DOM positions and sizes needed to draw the\n// view, so that we don't interleave reading and writing to the DOM.\nfunction getDimensions(cm) {\n  var d = cm.display, left = {}, width = {};\n  var gutterLeft = d.gutters.clientLeft;\n  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n    width[cm.options.gutters[i]] = n.clientWidth;\n  }\n  return {fixedPos: compensateForHScroll(d),\n          gutterTotalWidth: d.gutters.offsetWidth,\n          gutterLeft: left,\n          gutterWidth: width,\n          wrapperWidth: d.wrapper.clientWidth}\n}\n\n// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n// but using getBoundingClientRect to get a sub-pixel-accurate\n// result.\nfunction compensateForHScroll(display) {\n  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\n}\n\n// Returns a function that estimates the height of a line, to use as\n// first approximation until the line becomes visible (and is thus\n// properly measurable).\nfunction estimateHeight(cm) {\n  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n  return function (line) {\n    if (lineIsHidden(cm.doc, line)) { return 0 }\n\n    var widgetsHeight = 0;\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\n      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\n    } }\n\n    if (wrapping)\n      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\n    else\n      { return widgetsHeight + th }\n  }\n}\n\nfunction estimateLineHeights(cm) {\n  var doc = cm.doc, est = estimateHeight(cm);\n  doc.iter(function (line) {\n    var estHeight = est(line);\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n  });\n}\n\n// Given a mouse event, find the corresponding position. If liberal\n// is false, it checks whether a gutter or scrollbar was clicked,\n// and returns null if it was. forRect is used by rectangular\n// selections, and tries to estimate a character position even for\n// coordinates beyond the right of the text.\nfunction posFromMouse(cm, e, liberal, forRect) {\n  var display = cm.display;\n  if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\n\n  var x, y, space = display.lineSpace.getBoundingClientRect();\n  // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n  try { x = e.clientX - space.left; y = e.clientY - space.top; }\n  catch (e) { return null }\n  var coords = coordsChar(cm, x, y), line;\n  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n  }\n  return coords\n}\n\n// Find the view element corresponding to a given line. Return null\n// when the line isn't visible.\nfunction findViewIndex(cm, n) {\n  if (n >= cm.display.viewTo) { return null }\n  n -= cm.display.viewFrom;\n  if (n < 0) { return null }\n  var view = cm.display.view;\n  for (var i = 0; i < view.length; i++) {\n    n -= view[i].size;\n    if (n < 0) { return i }\n  }\n}\n\nfunction updateSelection(cm) {\n  cm.display.input.showSelection(cm.display.input.prepareSelection());\n}\n\nfunction prepareSelection(cm, primary) {\n  var doc = cm.doc, result = {};\n  var curFragment = result.cursors = document.createDocumentFragment();\n  var selFragment = result.selection = document.createDocumentFragment();\n\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\n    if (primary === false && i == doc.sel.primIndex) { continue }\n    var range$$1 = doc.sel.ranges[i];\n    if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }\n    var collapsed = range$$1.empty();\n    if (collapsed || cm.options.showCursorWhenSelecting)\n      { drawSelectionCursor(cm, range$$1.head, curFragment); }\n    if (!collapsed)\n      { drawSelectionRange(cm, range$$1, selFragment); }\n  }\n  return result\n}\n\n// Draws a cursor for the given range\nfunction drawSelectionCursor(cm, head, output) {\n  var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n  var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n  cursor.style.left = pos.left + \"px\";\n  cursor.style.top = pos.top + \"px\";\n  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n  if (pos.other) {\n    // Secondary cursor, shown when on a 'jump' in bi-directional text\n    var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n    otherCursor.style.display = \"\";\n    otherCursor.style.left = pos.other.left + \"px\";\n    otherCursor.style.top = pos.other.top + \"px\";\n    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n  }\n}\n\n// Draws the given range as a highlighted selection\nfunction drawSelectionRange(cm, range$$1, output) {\n  var display = cm.display, doc = cm.doc;\n  var fragment = document.createDocumentFragment();\n  var padding = paddingH(cm.display), leftSide = padding.left;\n  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n\n  function add(left, top, width, bottom) {\n    if (top < 0) { top = 0; }\n    top = Math.round(top);\n    bottom = Math.round(bottom);\n    fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\n  }\n\n  function drawForLine(line, fromArg, toArg) {\n    var lineObj = getLine(doc, line);\n    var lineLen = lineObj.text.length;\n    var start, end;\n    function coords(ch, bias) {\n      return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\n    }\n\n    iterateBidiSections(getOrder(lineObj, doc.direction), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {\n      var leftPos = coords(from, \"left\"), rightPos, left, right;\n      if (from == to) {\n        rightPos = leftPos;\n        left = right = leftPos.left;\n      } else {\n        rightPos = coords(to - 1, \"right\");\n        if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n        left = leftPos.left;\n        right = rightPos.right;\n      }\n      if (fromArg == null && from == 0) { left = leftSide; }\n      if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n        add(left, leftPos.top, null, leftPos.bottom);\n        left = leftSide;\n        if (leftPos.bottom < rightPos.top) { add(left, leftPos.bottom, null, rightPos.top); }\n      }\n      if (toArg == null && to == lineLen) { right = rightSide; }\n      if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n        { start = leftPos; }\n      if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n        { end = rightPos; }\n      if (left < leftSide + 1) { left = leftSide; }\n      add(left, rightPos.top, right - left, rightPos.bottom);\n    });\n    return {start: start, end: end}\n  }\n\n  var sFrom = range$$1.from(), sTo = range$$1.to();\n  if (sFrom.line == sTo.line) {\n    drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n  } else {\n    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n    var singleVLine = visualLine(fromLine) == visualLine(toLine);\n    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n    if (singleVLine) {\n      if (leftEnd.top < rightStart.top - 2) {\n        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n      } else {\n        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n      }\n    }\n    if (leftEnd.bottom < rightStart.top)\n      { add(leftSide, leftEnd.bottom, null, rightStart.top); }\n  }\n\n  output.appendChild(fragment);\n}\n\n// Cursor-blinking\nfunction restartBlink(cm) {\n  if (!cm.state.focused) { return }\n  var display = cm.display;\n  clearInterval(display.blinker);\n  var on = true;\n  display.cursorDiv.style.visibility = \"\";\n  if (cm.options.cursorBlinkRate > 0)\n    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\"; },\n      cm.options.cursorBlinkRate); }\n  else if (cm.options.cursorBlinkRate < 0)\n    { display.cursorDiv.style.visibility = \"hidden\"; }\n}\n\nfunction ensureFocus(cm) {\n  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n}\n\nfunction delayBlurEvent(cm) {\n  cm.state.delayingBlurEvent = true;\n  setTimeout(function () { if (cm.state.delayingBlurEvent) {\n    cm.state.delayingBlurEvent = false;\n    onBlur(cm);\n  } }, 100);\n}\n\nfunction onFocus(cm, e) {\n  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }\n\n  if (cm.options.readOnly == \"nocursor\") { return }\n  if (!cm.state.focused) {\n    signal(cm, \"focus\", cm, e);\n    cm.state.focused = true;\n    addClass(cm.display.wrapper, \"CodeMirror-focused\");\n    // This test prevents this from firing when a context\n    // menu is closed (since the input reset would kill the\n    // select-all detection hack)\n    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n      cm.display.input.reset();\n      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\n    }\n    cm.display.input.receivedFocus();\n  }\n  restartBlink(cm);\n}\nfunction onBlur(cm, e) {\n  if (cm.state.delayingBlurEvent) { return }\n\n  if (cm.state.focused) {\n    signal(cm, \"blur\", cm, e);\n    cm.state.focused = false;\n    rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n  }\n  clearInterval(cm.display.blinker);\n  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\n}\n\n// Read the actual heights of the rendered lines, and update their\n// stored heights to match.\nfunction updateHeightsInViewport(cm) {\n  var display = cm.display;\n  var prevBottom = display.lineDiv.offsetTop;\n  for (var i = 0; i < display.view.length; i++) {\n    var cur = display.view[i], height = (void 0);\n    if (cur.hidden) { continue }\n    if (ie && ie_version < 8) {\n      var bot = cur.node.offsetTop + cur.node.offsetHeight;\n      height = bot - prevBottom;\n      prevBottom = bot;\n    } else {\n      var box = cur.node.getBoundingClientRect();\n      height = box.bottom - box.top;\n    }\n    var diff = cur.line.height - height;\n    if (height < 2) { height = textHeight(display); }\n    if (diff > .005 || diff < -.005) {\n      updateLineHeight(cur.line, height);\n      updateWidgetHeight(cur.line);\n      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\n        { updateWidgetHeight(cur.rest[j]); } }\n    }\n  }\n}\n\n// Read and store the height of line widgets associated with the\n// given line.\nfunction updateWidgetHeight(line) {\n  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i)\n    { line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight; } }\n}\n\n// Compute the lines that are visible in a given viewport (defaults\n// the the current scroll position). viewport may contain top,\n// height, and ensure (see op.scrollToPos) properties.\nfunction visibleLines(display, doc, viewport) {\n  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n  top = Math.floor(top - paddingTop(display));\n  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n  // forces those lines into the viewport (if possible).\n  if (viewport && viewport.ensure) {\n    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n    if (ensureFrom < from) {\n      from = ensureFrom;\n      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n      to = ensureTo;\n    }\n  }\n  return {from: from, to: Math.max(to, from + 1)}\n}\n\n// Re-align line numbers and gutter marks to compensate for\n// horizontal scrolling.\nfunction alignHorizontally(cm) {\n  var display = cm.display, view = display.view;\n  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\n  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n  var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\n    if (cm.options.fixedGutter) {\n      if (view[i].gutter)\n        { view[i].gutter.style.left = left; }\n      if (view[i].gutterBackground)\n        { view[i].gutterBackground.style.left = left; }\n    }\n    var align = view[i].alignable;\n    if (align) { for (var j = 0; j < align.length; j++)\n      { align[j].style.left = left; } }\n  } }\n  if (cm.options.fixedGutter)\n    { display.gutters.style.left = (comp + gutterW) + \"px\"; }\n}\n\n// Used to ensure that the line number gutter is still the right\n// size for the current document size. Returns true when an update\n// is needed.\nfunction maybeUpdateLineNumberWidth(cm) {\n  if (!cm.options.lineNumbers) { return false }\n  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n  if (last.length != display.lineNumChars) {\n    var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                               \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n    display.lineGutter.style.width = \"\";\n    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n    display.lineNumWidth = display.lineNumInnerWidth + padding;\n    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n    display.lineGutter.style.width = display.lineNumWidth + \"px\";\n    updateGutterSpace(cm);\n    return true\n  }\n  return false\n}\n\n// SCROLLING THINGS INTO VIEW\n\n// If an editor sits on the top or bottom of the window, partially\n// scrolled out of view, this ensures that the cursor is visible.\nfunction maybeScrollWindow(cm, rect) {\n  if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\n\n  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n  if (rect.top + box.top < 0) { doScroll = true; }\n  else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\n  if (doScroll != null && !phantom) {\n    var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\n    cm.display.lineSpace.appendChild(scrollNode);\n    scrollNode.scrollIntoView(doScroll);\n    cm.display.lineSpace.removeChild(scrollNode);\n  }\n}\n\n// Scroll a given position into view (immediately), verifying that\n// it actually became visible (as line heights are accurately\n// measured, the position of something may 'drift' during drawing).\nfunction scrollPosIntoView(cm, pos, end, margin) {\n  if (margin == null) { margin = 0; }\n  var rect;\n  if (!cm.options.lineWrapping && pos == end) {\n    // Set pos and end to the cursor positions around the character pos sticks to\n    // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\n    // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\n    pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n    end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n  }\n  for (var limit = 0; limit < 5; limit++) {\n    var changed = false;\n    var coords = cursorCoords(cm, pos);\n    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n    rect = {left: Math.min(coords.left, endCoords.left),\n            top: Math.min(coords.top, endCoords.top) - margin,\n            right: Math.max(coords.left, endCoords.left),\n            bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\n    var scrollPos = calculateScrollPos(cm, rect);\n    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n    if (scrollPos.scrollTop != null) {\n      updateScrollTop(cm, scrollPos.scrollTop);\n      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\n    }\n    if (scrollPos.scrollLeft != null) {\n      setScrollLeft(cm, scrollPos.scrollLeft);\n      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\n    }\n    if (!changed) { break }\n  }\n  return rect\n}\n\n// Scroll a given set of coordinates into view (immediately).\nfunction scrollIntoView(cm, rect) {\n  var scrollPos = calculateScrollPos(cm, rect);\n  if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\n  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\n}\n\n// Calculate a new scroll position needed to scroll the given\n// rectangle into view. Returns an object with scrollTop and\n// scrollLeft properties. When these are undefined, the\n// vertical/horizontal position does not need to be adjusted.\nfunction calculateScrollPos(cm, rect) {\n  var display = cm.display, snapMargin = textHeight(cm.display);\n  if (rect.top < 0) { rect.top = 0; }\n  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n  var screen = displayHeight(cm), result = {};\n  if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\n  var docBottom = cm.doc.height + paddingVert(display);\n  var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n  if (rect.top < screentop) {\n    result.scrollTop = atTop ? 0 : rect.top;\n  } else if (rect.bottom > screentop + screen) {\n    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n    if (newTop != screentop) { result.scrollTop = newTop; }\n  }\n\n  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n  var tooWide = rect.right - rect.left > screenw;\n  if (tooWide) { rect.right = rect.left + screenw; }\n  if (rect.left < 10)\n    { result.scrollLeft = 0; }\n  else if (rect.left < screenleft)\n    { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }\n  else if (rect.right > screenw + screenleft - 3)\n    { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\n  return result\n}\n\n// Store a relative adjustment to the scroll position in the current\n// operation (to be applied when the operation finishes).\nfunction addToScrollTop(cm, top) {\n  if (top == null) { return }\n  resolveScrollToPos(cm);\n  cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n}\n\n// Make sure that at the end of the operation the current cursor is\n// shown.\nfunction ensureCursorVisible(cm) {\n  resolveScrollToPos(cm);\n  var cur = cm.getCursor();\n  cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};\n}\n\nfunction scrollToCoords(cm, x, y) {\n  if (x != null || y != null) { resolveScrollToPos(cm); }\n  if (x != null) { cm.curOp.scrollLeft = x; }\n  if (y != null) { cm.curOp.scrollTop = y; }\n}\n\nfunction scrollToRange(cm, range$$1) {\n  resolveScrollToPos(cm);\n  cm.curOp.scrollToPos = range$$1;\n}\n\n// When an operation has its scrollToPos property set, and another\n// scroll action is applied before the end of the operation, this\n// 'simulates' scrolling that position into view in a cheap way, so\n// that the effect of intermediate scroll commands is not ignored.\nfunction resolveScrollToPos(cm) {\n  var range$$1 = cm.curOp.scrollToPos;\n  if (range$$1) {\n    cm.curOp.scrollToPos = null;\n    var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);\n    scrollToCoordsRange(cm, from, to, range$$1.margin);\n  }\n}\n\nfunction scrollToCoordsRange(cm, from, to, margin) {\n  var sPos = calculateScrollPos(cm, {\n    left: Math.min(from.left, to.left),\n    top: Math.min(from.top, to.top) - margin,\n    right: Math.max(from.right, to.right),\n    bottom: Math.max(from.bottom, to.bottom) + margin\n  });\n  scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n}\n\n// Sync the scrollable area and scrollbars, ensure the viewport\n// covers the visible area.\nfunction updateScrollTop(cm, val) {\n  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\n  if (!gecko) { updateDisplaySimple(cm, {top: val}); }\n  setScrollTop(cm, val, true);\n  if (gecko) { updateDisplaySimple(cm); }\n  startWorker(cm, 100);\n}\n\nfunction setScrollTop(cm, val, forceScroll) {\n  val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);\n  if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\n  cm.doc.scrollTop = val;\n  cm.display.scrollbars.setScrollTop(val);\n  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\n}\n\n// Sync scroller and scrollbar, ensure the gutter elements are\n// aligned.\nfunction setScrollLeft(cm, val, isScroller, forceScroll) {\n  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n  if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\n  cm.doc.scrollLeft = val;\n  alignHorizontally(cm);\n  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\n  cm.display.scrollbars.setScrollLeft(val);\n}\n\n// SCROLLBARS\n\n// Prepare DOM reads needed to update the scrollbars. Done in one\n// shot to minimize update/measure roundtrips.\nfunction measureForScrollbars(cm) {\n  var d = cm.display, gutterW = d.gutters.offsetWidth;\n  var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n  return {\n    clientHeight: d.scroller.clientHeight,\n    viewHeight: d.wrapper.clientHeight,\n    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n    viewWidth: d.wrapper.clientWidth,\n    barLeft: cm.options.fixedGutter ? gutterW : 0,\n    docHeight: docH,\n    scrollHeight: docH + scrollGap(cm) + d.barHeight,\n    nativeBarWidth: d.nativeBarWidth,\n    gutterWidth: gutterW\n  }\n}\n\nvar NativeScrollbars = function(place, scroll, cm) {\n  this.cm = cm;\n  var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n  var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n  place(vert); place(horiz);\n\n  on(vert, \"scroll\", function () {\n    if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\n  });\n  on(horiz, \"scroll\", function () {\n    if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\n  });\n\n  this.checkedZeroWidth = false;\n  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\n};\n\nNativeScrollbars.prototype.update = function (measure) {\n  var needsH = measure.scrollWidth > measure.clientWidth + 1;\n  var needsV = measure.scrollHeight > measure.clientHeight + 1;\n  var sWidth = measure.nativeBarWidth;\n\n  if (needsV) {\n    this.vert.style.display = \"block\";\n    this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n    // A bug in IE8 can cause this value to be negative, so guard it.\n    this.vert.firstChild.style.height =\n      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n  } else {\n    this.vert.style.display = \"\";\n    this.vert.firstChild.style.height = \"0\";\n  }\n\n  if (needsH) {\n    this.horiz.style.display = \"block\";\n    this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n    this.horiz.style.left = measure.barLeft + \"px\";\n    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n    this.horiz.firstChild.style.width =\n      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n  } else {\n    this.horiz.style.display = \"\";\n    this.horiz.firstChild.style.width = \"0\";\n  }\n\n  if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n    if (sWidth == 0) { this.zeroWidthHack(); }\n    this.checkedZeroWidth = true;\n  }\n\n  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\n};\n\nNativeScrollbars.prototype.setScrollLeft = function (pos) {\n  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\n  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\n};\n\nNativeScrollbars.prototype.setScrollTop = function (pos) {\n  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\n  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\n};\n\nNativeScrollbars.prototype.zeroWidthHack = function () {\n  var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n  this.horiz.style.height = this.vert.style.width = w;\n  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n  this.disableHoriz = new Delayed;\n  this.disableVert = new Delayed;\n};\n\nNativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n  bar.style.pointerEvents = \"auto\";\n  function maybeDisable() {\n    // To find out whether the scrollbar is still visible, we\n    // check whether the element under the pixel in the bottom\n    // right corner of the scrollbar box is the scrollbar box\n    // itself (when the bar is still visible) or its filler child\n    // (when the bar is hidden). If it is still visible, we keep\n    // it enabled, if it's hidden, we disable pointer events.\n    var box = bar.getBoundingClientRect();\n    var elt$$1 = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\n        : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n    if (elt$$1 != bar) { bar.style.pointerEvents = \"none\"; }\n    else { delay.set(1000, maybeDisable); }\n  }\n  delay.set(1000, maybeDisable);\n};\n\nNativeScrollbars.prototype.clear = function () {\n  var parent = this.horiz.parentNode;\n  parent.removeChild(this.horiz);\n  parent.removeChild(this.vert);\n};\n\nvar NullScrollbars = function () {};\n\nNullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\nNullScrollbars.prototype.setScrollLeft = function () {};\nNullScrollbars.prototype.setScrollTop = function () {};\nNullScrollbars.prototype.clear = function () {};\n\nfunction updateScrollbars(cm, measure) {\n  if (!measure) { measure = measureForScrollbars(cm); }\n  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n  updateScrollbarsInner(cm, measure);\n  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n      { updateHeightsInViewport(cm); }\n    updateScrollbarsInner(cm, measureForScrollbars(cm));\n    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n  }\n}\n\n// Re-synchronize the fake scrollbars with the actual size of the\n// content.\nfunction updateScrollbarsInner(cm, measure) {\n  var d = cm.display;\n  var sizes = d.scrollbars.update(measure);\n\n  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n  d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n  if (sizes.right && sizes.bottom) {\n    d.scrollbarFiller.style.display = \"block\";\n    d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n    d.scrollbarFiller.style.width = sizes.right + \"px\";\n  } else { d.scrollbarFiller.style.display = \"\"; }\n  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n    d.gutterFiller.style.display = \"block\";\n    d.gutterFiller.style.height = sizes.bottom + \"px\";\n    d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n  } else { d.gutterFiller.style.display = \"\"; }\n}\n\nvar scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\nfunction initScrollbars(cm) {\n  if (cm.display.scrollbars) {\n    cm.display.scrollbars.clear();\n    if (cm.display.scrollbars.addClass)\n      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n  }\n\n  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n    // Prevent clicks in the scrollbars from killing focus\n    on(node, \"mousedown\", function () {\n      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\n    });\n    node.setAttribute(\"cm-not-content\", \"true\");\n  }, function (pos, axis) {\n    if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\n    else { updateScrollTop(cm, pos); }\n  }, cm);\n  if (cm.display.scrollbars.addClass)\n    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n}\n\n// Operations are used to wrap a series of changes to the editor\n// state in such a way that each change won't have to update the\n// cursor and display (which would be awkward, slow, and\n// error-prone). Instead, display updates are batched and then all\n// combined and executed at once.\n\nvar nextOpId = 0;\n// Start a new operation.\nfunction startOperation(cm) {\n  cm.curOp = {\n    cm: cm,\n    viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n    startHeight: cm.doc.height, // Used to detect need to update scrollbar\n    forceUpdate: false,      // Used to force a redraw\n    updateInput: null,       // Whether to reset the input textarea\n    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n    changeObjs: null,        // Accumulated changes, for firing change events\n    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n    selectionChanged: false, // Whether the selection needs to be redrawn\n    updateMaxLine: false,    // Set when the widest line needs to be determined anew\n    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n    scrollToPos: null,       // Used to scroll to a specific position\n    focus: false,\n    id: ++nextOpId           // Unique ID\n  };\n  pushOperation(cm.curOp);\n}\n\n// Finish an operation, updating the display and signalling delayed events\nfunction endOperation(cm) {\n  var op = cm.curOp;\n  finishOperation(op, function (group) {\n    for (var i = 0; i < group.ops.length; i++)\n      { group.ops[i].cm.curOp = null; }\n    endOperations(group);\n  });\n}\n\n// The DOM updates done when an operation finishes are batched so\n// that the minimum number of relayouts are required.\nfunction endOperations(group) {\n  var ops = group.ops;\n  for (var i = 0; i < ops.length; i++) // Read DOM\n    { endOperation_R1(ops[i]); }\n  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n    { endOperation_W1(ops[i$1]); }\n  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n    { endOperation_R2(ops[i$2]); }\n  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n    { endOperation_W2(ops[i$3]); }\n  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n    { endOperation_finish(ops[i$4]); }\n}\n\nfunction endOperation_R1(op) {\n  var cm = op.cm, display = cm.display;\n  maybeClipScrollbars(cm);\n  if (op.updateMaxLine) { findMaxLine(cm); }\n\n  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                       op.scrollToPos.to.line >= display.viewTo) ||\n    display.maxLineChanged && cm.options.lineWrapping;\n  op.update = op.mustUpdate &&\n    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n}\n\nfunction endOperation_W1(op) {\n  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n}\n\nfunction endOperation_R2(op) {\n  var cm = op.cm, display = cm.display;\n  if (op.updatedDisplay) { updateHeightsInViewport(cm); }\n\n  op.barMeasure = measureForScrollbars(cm);\n\n  // If the max line changed since it was last measured, measure it,\n  // and ensure the document's width matches it.\n  // updateDisplay_W2 will use these properties to do the actual resizing\n  if (display.maxLineChanged && !cm.options.lineWrapping) {\n    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n    cm.display.sizerWidth = op.adjustWidthTo;\n    op.barMeasure.scrollWidth =\n      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n  }\n\n  if (op.updatedDisplay || op.selectionChanged)\n    { op.preparedSelection = display.input.prepareSelection(op.focus); }\n}\n\nfunction endOperation_W2(op) {\n  var cm = op.cm;\n\n  if (op.adjustWidthTo != null) {\n    cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n    if (op.maxScrollLeft < cm.doc.scrollLeft)\n      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\n    cm.display.maxLineChanged = false;\n  }\n\n  var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus());\n  if (op.preparedSelection)\n    { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\n  if (op.updatedDisplay || op.startHeight != cm.doc.height)\n    { updateScrollbars(cm, op.barMeasure); }\n  if (op.updatedDisplay)\n    { setDocumentHeight(cm, op.barMeasure); }\n\n  if (op.selectionChanged) { restartBlink(cm); }\n\n  if (cm.state.focused && op.updateInput)\n    { cm.display.input.reset(op.typing); }\n  if (takeFocus) { ensureFocus(op.cm); }\n}\n\nfunction endOperation_finish(op) {\n  var cm = op.cm, display = cm.display, doc = cm.doc;\n\n  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\n\n  // Abort mouse wheel delta measurement, when scrolling explicitly\n  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n    { display.wheelStartX = display.wheelStartY = null; }\n\n  // Propagate the scroll position to the actual DOM scroller\n  if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\n\n  if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\n  // If we need to scroll a specific position into view, do so.\n  if (op.scrollToPos) {\n    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                 clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n    maybeScrollWindow(cm, rect);\n  }\n\n  // Fire events for markers that are hidden/unidden by editing or\n  // undoing\n  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n  if (hidden) { for (var i = 0; i < hidden.length; ++i)\n    { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\n  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\n    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\n\n  if (display.wrapper.offsetHeight)\n    { doc.scrollTop = cm.display.scroller.scrollTop; }\n\n  // Fire change events, and delayed event handlers\n  if (op.changeObjs)\n    { signal(cm, \"changes\", cm, op.changeObjs); }\n  if (op.update)\n    { op.update.finish(); }\n}\n\n// Run the given function in an operation\nfunction runInOp(cm, f) {\n  if (cm.curOp) { return f() }\n  startOperation(cm);\n  try { return f() }\n  finally { endOperation(cm); }\n}\n// Wraps a function in an operation. Returns the wrapped function.\nfunction operation(cm, f) {\n  return function() {\n    if (cm.curOp) { return f.apply(cm, arguments) }\n    startOperation(cm);\n    try { return f.apply(cm, arguments) }\n    finally { endOperation(cm); }\n  }\n}\n// Used to add methods to editor and doc instances, wrapping them in\n// operations.\nfunction methodOp(f) {\n  return function() {\n    if (this.curOp) { return f.apply(this, arguments) }\n    startOperation(this);\n    try { return f.apply(this, arguments) }\n    finally { endOperation(this); }\n  }\n}\nfunction docMethodOp(f) {\n  return function() {\n    var cm = this.cm;\n    if (!cm || cm.curOp) { return f.apply(this, arguments) }\n    startOperation(cm);\n    try { return f.apply(this, arguments) }\n    finally { endOperation(cm); }\n  }\n}\n\n// Updates the display.view data structure for a given change to the\n// document. From and to are in pre-change coordinates. Lendiff is\n// the amount of lines added or subtracted by the change. This is\n// used for changes that span multiple lines, or change the way\n// lines are divided into visual lines. regLineChange (below)\n// registers single-line changes.\nfunction regChange(cm, from, to, lendiff) {\n  if (from == null) { from = cm.doc.first; }\n  if (to == null) { to = cm.doc.first + cm.doc.size; }\n  if (!lendiff) { lendiff = 0; }\n\n  var display = cm.display;\n  if (lendiff && to < display.viewTo &&\n      (display.updateLineNumbers == null || display.updateLineNumbers > from))\n    { display.updateLineNumbers = from; }\n\n  cm.curOp.viewChanged = true;\n\n  if (from >= display.viewTo) { // Change after\n    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n      { resetView(cm); }\n  } else if (to <= display.viewFrom) { // Change before\n    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n      resetView(cm);\n    } else {\n      display.viewFrom += lendiff;\n      display.viewTo += lendiff;\n    }\n  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n    resetView(cm);\n  } else if (from <= display.viewFrom) { // Top overlap\n    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n    if (cut) {\n      display.view = display.view.slice(cut.index);\n      display.viewFrom = cut.lineN;\n      display.viewTo += lendiff;\n    } else {\n      resetView(cm);\n    }\n  } else if (to >= display.viewTo) { // Bottom overlap\n    var cut$1 = viewCuttingPoint(cm, from, from, -1);\n    if (cut$1) {\n      display.view = display.view.slice(0, cut$1.index);\n      display.viewTo = cut$1.lineN;\n    } else {\n      resetView(cm);\n    }\n  } else { // Gap in the middle\n    var cutTop = viewCuttingPoint(cm, from, from, -1);\n    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n    if (cutTop && cutBot) {\n      display.view = display.view.slice(0, cutTop.index)\n        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n        .concat(display.view.slice(cutBot.index));\n      display.viewTo += lendiff;\n    } else {\n      resetView(cm);\n    }\n  }\n\n  var ext = display.externalMeasured;\n  if (ext) {\n    if (to < ext.lineN)\n      { ext.lineN += lendiff; }\n    else if (from < ext.lineN + ext.size)\n      { display.externalMeasured = null; }\n  }\n}\n\n// Register a change to a single line. Type must be one of \"text\",\n// \"gutter\", \"class\", \"widget\"\nfunction regLineChange(cm, line, type) {\n  cm.curOp.viewChanged = true;\n  var display = cm.display, ext = cm.display.externalMeasured;\n  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n    { display.externalMeasured = null; }\n\n  if (line < display.viewFrom || line >= display.viewTo) { return }\n  var lineView = display.view[findViewIndex(cm, line)];\n  if (lineView.node == null) { return }\n  var arr = lineView.changes || (lineView.changes = []);\n  if (indexOf(arr, type) == -1) { arr.push(type); }\n}\n\n// Clear the view.\nfunction resetView(cm) {\n  cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n  cm.display.view = [];\n  cm.display.viewOffset = 0;\n}\n\nfunction viewCuttingPoint(cm, oldN, newN, dir) {\n  var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n    { return {index: index, lineN: newN} }\n  var n = cm.display.viewFrom;\n  for (var i = 0; i < index; i++)\n    { n += view[i].size; }\n  if (n != oldN) {\n    if (dir > 0) {\n      if (index == view.length - 1) { return null }\n      diff = (n + view[index].size) - oldN;\n      index++;\n    } else {\n      diff = n - oldN;\n    }\n    oldN += diff; newN += diff;\n  }\n  while (visualLineNo(cm.doc, newN) != newN) {\n    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\n    newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n    index += dir;\n  }\n  return {index: index, lineN: newN}\n}\n\n// Force the view to cover a given range, adding empty view element\n// or clipping off existing ones as needed.\nfunction adjustView(cm, from, to) {\n  var display = cm.display, view = display.view;\n  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n    display.view = buildViewArray(cm, from, to);\n    display.viewFrom = from;\n  } else {\n    if (display.viewFrom > from)\n      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\n    else if (display.viewFrom < from)\n      { display.view = display.view.slice(findViewIndex(cm, from)); }\n    display.viewFrom = from;\n    if (display.viewTo < to)\n      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\n    else if (display.viewTo > to)\n      { display.view = display.view.slice(0, findViewIndex(cm, to)); }\n  }\n  display.viewTo = to;\n}\n\n// Count the number of lines in the view whose DOM representation is\n// out of date (or nonexistent).\nfunction countDirtyView(cm) {\n  var view = cm.display.view, dirty = 0;\n  for (var i = 0; i < view.length; i++) {\n    var lineView = view[i];\n    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\n  }\n  return dirty\n}\n\n// HIGHLIGHT WORKER\n\nfunction startWorker(cm, time) {\n  if (cm.doc.highlightFrontier < cm.display.viewTo)\n    { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\n}\n\nfunction highlightWorker(cm) {\n  var doc = cm.doc;\n  if (doc.highlightFrontier >= cm.display.viewTo) { return }\n  var end = +new Date + cm.options.workTime;\n  var context = getContextBefore(cm, doc.highlightFrontier);\n  var changedLines = [];\n\n  doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n    if (context.line >= cm.display.viewFrom) { // Visible\n      var oldStyles = line.styles;\n      var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n      var highlighted = highlightLine(cm, line, context, true);\n      if (resetState) { context.state = resetState; }\n      line.styles = highlighted.styles;\n      var oldCls = line.styleClasses, newCls = highlighted.classes;\n      if (newCls) { line.styleClasses = newCls; }\n      else if (oldCls) { line.styleClasses = null; }\n      var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\n      if (ischange) { changedLines.push(context.line); }\n      line.stateAfter = context.save();\n      context.nextLine();\n    } else {\n      if (line.text.length <= cm.options.maxHighlightLength)\n        { processLine(cm, line.text, context); }\n      line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n      context.nextLine();\n    }\n    if (+new Date > end) {\n      startWorker(cm, cm.options.workDelay);\n      return true\n    }\n  });\n  doc.highlightFrontier = context.line;\n  doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n  if (changedLines.length) { runInOp(cm, function () {\n    for (var i = 0; i < changedLines.length; i++)\n      { regLineChange(cm, changedLines[i], \"text\"); }\n  }); }\n}\n\n// DISPLAY DRAWING\n\nvar DisplayUpdate = function(cm, viewport, force) {\n  var display = cm.display;\n\n  this.viewport = viewport;\n  // Store some values that we'll need later (but don't want to force a relayout for)\n  this.visible = visibleLines(display, cm.doc, viewport);\n  this.editorIsHidden = !display.wrapper.offsetWidth;\n  this.wrapperHeight = display.wrapper.clientHeight;\n  this.wrapperWidth = display.wrapper.clientWidth;\n  this.oldDisplayWidth = displayWidth(cm);\n  this.force = force;\n  this.dims = getDimensions(cm);\n  this.events = [];\n};\n\nDisplayUpdate.prototype.signal = function (emitter, type) {\n  if (hasHandler(emitter, type))\n    { this.events.push(arguments); }\n};\nDisplayUpdate.prototype.finish = function () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.events.length; i++)\n    { signal.apply(null, this$1.events[i]); }\n};\n\nfunction maybeClipScrollbars(cm) {\n  var display = cm.display;\n  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n    display.heightForcer.style.height = scrollGap(cm) + \"px\";\n    display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n    display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n    display.scrollbarsClipped = true;\n  }\n}\n\nfunction selectionSnapshot(cm) {\n  if (cm.hasFocus()) { return null }\n  var active = activeElt();\n  if (!active || !contains(cm.display.lineDiv, active)) { return null }\n  var result = {activeElt: active};\n  if (window.getSelection) {\n    var sel = window.getSelection();\n    if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n      result.anchorNode = sel.anchorNode;\n      result.anchorOffset = sel.anchorOffset;\n      result.focusNode = sel.focusNode;\n      result.focusOffset = sel.focusOffset;\n    }\n  }\n  return result\n}\n\nfunction restoreSelection(snapshot) {\n  if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\n  snapshot.activeElt.focus();\n  if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n    var sel = window.getSelection(), range$$1 = document.createRange();\n    range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n    range$$1.collapse(false);\n    sel.removeAllRanges();\n    sel.addRange(range$$1);\n    sel.extend(snapshot.focusNode, snapshot.focusOffset);\n  }\n}\n\n// Does the actual updating of the line display. Bails out\n// (returning false) when there is nothing to be done and forced is\n// false.\nfunction updateDisplayIfNeeded(cm, update) {\n  var display = cm.display, doc = cm.doc;\n\n  if (update.editorIsHidden) {\n    resetView(cm);\n    return false\n  }\n\n  // Bail out if the visible area is already rendered and nothing changed.\n  if (!update.force &&\n      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n      display.renderedView == display.view && countDirtyView(cm) == 0)\n    { return false }\n\n  if (maybeUpdateLineNumberWidth(cm)) {\n    resetView(cm);\n    update.dims = getDimensions(cm);\n  }\n\n  // Compute a suitable new viewport (from & to)\n  var end = doc.first + doc.size;\n  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n  var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\n  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\n  if (sawCollapsedSpans) {\n    from = visualLineNo(cm.doc, from);\n    to = visualLineEndNo(cm.doc, to);\n  }\n\n  var different = from != display.viewFrom || to != display.viewTo ||\n    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n  adjustView(cm, from, to);\n\n  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n  // Position the mover div to align with the current scroll position\n  cm.display.mover.style.top = display.viewOffset + \"px\";\n\n  var toUpdate = countDirtyView(cm);\n  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n    { return false }\n\n  // For big changes, we hide the enclosing element during the\n  // update, since that speeds up the operations on most browsers.\n  var selSnapshot = selectionSnapshot(cm);\n  if (toUpdate > 4) { display.lineDiv.style.display = \"none\"; }\n  patchDisplay(cm, display.updateLineNumbers, update.dims);\n  if (toUpdate > 4) { display.lineDiv.style.display = \"\"; }\n  display.renderedView = display.view;\n  // There might have been a widget with a focused element that got\n  // hidden or updated, if so re-focus it.\n  restoreSelection(selSnapshot);\n\n  // Prevent selection and cursors from interfering with the scroll\n  // width and height.\n  removeChildren(display.cursorDiv);\n  removeChildren(display.selectionDiv);\n  display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n  if (different) {\n    display.lastWrapHeight = update.wrapperHeight;\n    display.lastWrapWidth = update.wrapperWidth;\n    startWorker(cm, 400);\n  }\n\n  display.updateLineNumbers = null;\n\n  return true\n}\n\nfunction postUpdateDisplay(cm, update) {\n  var viewport = update.viewport;\n\n  for (var first = true;; first = false) {\n    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n      // Clip forced viewport to actual scrollable area.\n      if (viewport && viewport.top != null)\n        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\n      // Updated line heights might result in the drawn area not\n      // actually covering the viewport. Keep looping until it does.\n      update.visible = visibleLines(cm.display, cm.doc, viewport);\n      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n        { break }\n    }\n    if (!updateDisplayIfNeeded(cm, update)) { break }\n    updateHeightsInViewport(cm);\n    var barMeasure = measureForScrollbars(cm);\n    updateSelection(cm);\n    updateScrollbars(cm, barMeasure);\n    setDocumentHeight(cm, barMeasure);\n    update.force = false;\n  }\n\n  update.signal(cm, \"update\", cm);\n  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n    update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n  }\n}\n\nfunction updateDisplaySimple(cm, viewport) {\n  var update = new DisplayUpdate(cm, viewport);\n  if (updateDisplayIfNeeded(cm, update)) {\n    updateHeightsInViewport(cm);\n    postUpdateDisplay(cm, update);\n    var barMeasure = measureForScrollbars(cm);\n    updateSelection(cm);\n    updateScrollbars(cm, barMeasure);\n    setDocumentHeight(cm, barMeasure);\n    update.finish();\n  }\n}\n\n// Sync the actual display DOM structure with display.view, removing\n// nodes for lines that are no longer in view, and creating the ones\n// that are not there yet, and updating the ones that are out of\n// date.\nfunction patchDisplay(cm, updateNumbersFrom, dims) {\n  var display = cm.display, lineNumbers = cm.options.lineNumbers;\n  var container = display.lineDiv, cur = container.firstChild;\n\n  function rm(node) {\n    var next = node.nextSibling;\n    // Works around a throw-scroll bug in OS X Webkit\n    if (webkit && mac && cm.display.currentWheelTarget == node)\n      { node.style.display = \"none\"; }\n    else\n      { node.parentNode.removeChild(node); }\n    return next\n  }\n\n  var view = display.view, lineN = display.viewFrom;\n  // Loop over the elements in the view, syncing cur (the DOM nodes\n  // in display.lineDiv) with the view as we go.\n  for (var i = 0; i < view.length; i++) {\n    var lineView = view[i];\n    if (lineView.hidden) {\n    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n      var node = buildLineElement(cm, lineView, lineN, dims);\n      container.insertBefore(node, cur);\n    } else { // Already drawn\n      while (cur != lineView.node) { cur = rm(cur); }\n      var updateNumber = lineNumbers && updateNumbersFrom != null &&\n        updateNumbersFrom <= lineN && lineView.lineNumber;\n      if (lineView.changes) {\n        if (indexOf(lineView.changes, \"gutter\") > -1) { updateNumber = false; }\n        updateLineForChanges(cm, lineView, lineN, dims);\n      }\n      if (updateNumber) {\n        removeChildren(lineView.lineNumber);\n        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n      }\n      cur = lineView.node.nextSibling;\n    }\n    lineN += lineView.size;\n  }\n  while (cur) { cur = rm(cur); }\n}\n\nfunction updateGutterSpace(cm) {\n  var width = cm.display.gutters.offsetWidth;\n  cm.display.sizer.style.marginLeft = width + \"px\";\n}\n\nfunction setDocumentHeight(cm, measure) {\n  cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n  cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n}\n\n// Rebuild the gutter elements, ensure the margin to the left of the\n// code matches their width.\nfunction updateGutters(cm) {\n  var gutters = cm.display.gutters, specs = cm.options.gutters;\n  removeChildren(gutters);\n  var i = 0;\n  for (; i < specs.length; ++i) {\n    var gutterClass = specs[i];\n    var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n    if (gutterClass == \"CodeMirror-linenumbers\") {\n      cm.display.lineGutter = gElt;\n      gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n    }\n  }\n  gutters.style.display = i ? \"\" : \"none\";\n  updateGutterSpace(cm);\n}\n\n// Make sure the gutters options contains the element\n// \"CodeMirror-linenumbers\" when the lineNumbers option is true.\nfunction setGuttersForLineNumbers(options) {\n  var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n  if (found == -1 && options.lineNumbers) {\n    options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n  } else if (found > -1 && !options.lineNumbers) {\n    options.gutters = options.gutters.slice(0);\n    options.gutters.splice(found, 1);\n  }\n}\n\n// Since the delta values reported on mouse wheel events are\n// unstandardized between browsers and even browser versions, and\n// generally horribly unpredictable, this code starts by measuring\n// the scroll effect that the first few mouse wheel events have,\n// and, from that, detects the way it can convert deltas to pixel\n// offsets afterwards.\n//\n// The reason we want to know the amount a wheel event will scroll\n// is that it gives us a chance to update the display before the\n// actual scrolling happens, reducing flickering.\n\nvar wheelSamples = 0;\nvar wheelPixelsPerUnit = null;\n// Fill in a browser-detected starting value on browsers where we\n// know one. These don't have to be accurate -- the result of them\n// being wrong would just be a slight flicker on the first wheel\n// scroll (if it is large enough).\nif (ie) { wheelPixelsPerUnit = -.53; }\nelse if (gecko) { wheelPixelsPerUnit = 15; }\nelse if (chrome) { wheelPixelsPerUnit = -.7; }\nelse if (safari) { wheelPixelsPerUnit = -1/3; }\n\nfunction wheelEventDelta(e) {\n  var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\n  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\n  else if (dy == null) { dy = e.wheelDelta; }\n  return {x: dx, y: dy}\n}\nfunction wheelEventPixels(e) {\n  var delta = wheelEventDelta(e);\n  delta.x *= wheelPixelsPerUnit;\n  delta.y *= wheelPixelsPerUnit;\n  return delta\n}\n\nfunction onScrollWheel(cm, e) {\n  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n  var display = cm.display, scroll = display.scroller;\n  // Quit if there's nothing to scroll here\n  var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n  var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n  if (!(dx && canScrollX || dy && canScrollY)) { return }\n\n  // Webkit browsers on OS X abort momentum scrolls when the target\n  // of the scroll event is removed from the scrollable element.\n  // This hack (see related code in patchDisplay) makes sure the\n  // element is kept around.\n  if (dy && mac && webkit) {\n    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n      for (var i = 0; i < view.length; i++) {\n        if (view[i].node == cur) {\n          cm.display.currentWheelTarget = cur;\n          break outer\n        }\n      }\n    }\n  }\n\n  // On some browsers, horizontal scrolling will cause redraws to\n  // happen before the gutter has been realigned, causing it to\n  // wriggle around in a most unseemly way. When we have an\n  // estimated pixels/delta value, we just handle horizontal\n  // scrolling entirely here. It'll be slightly off from native, but\n  // better than glitching out.\n  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n    if (dy && canScrollY)\n      { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\n    setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\n    // Only prevent default scrolling if vertical scrolling is\n    // actually possible. Otherwise, it causes vertical scroll\n    // jitter on OSX trackpads when deltaX is small and deltaY\n    // is large (issue #3579)\n    if (!dy || (dy && canScrollY))\n      { e_preventDefault(e); }\n    display.wheelStartX = null; // Abort measurement, if in progress\n    return\n  }\n\n  // 'Project' the visible viewport to cover the area that is being\n  // scrolled into view (if we know enough to estimate it).\n  if (dy && wheelPixelsPerUnit != null) {\n    var pixels = dy * wheelPixelsPerUnit;\n    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n    if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\n    else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\n    updateDisplaySimple(cm, {top: top, bottom: bot});\n  }\n\n  if (wheelSamples < 20) {\n    if (display.wheelStartX == null) {\n      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n      display.wheelDX = dx; display.wheelDY = dy;\n      setTimeout(function () {\n        if (display.wheelStartX == null) { return }\n        var movedX = scroll.scrollLeft - display.wheelStartX;\n        var movedY = scroll.scrollTop - display.wheelStartY;\n        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n          (movedX && display.wheelDX && movedX / display.wheelDX);\n        display.wheelStartX = display.wheelStartY = null;\n        if (!sample) { return }\n        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n        ++wheelSamples;\n      }, 200);\n    } else {\n      display.wheelDX += dx; display.wheelDY += dy;\n    }\n  }\n}\n\n// Selection objects are immutable. A new one is created every time\n// the selection changes. A selection is one or more non-overlapping\n// (and non-touching) ranges, sorted, and an integer that indicates\n// which one is the primary selection (the one that's scrolled into\n// view, that getCursor returns, etc).\nvar Selection = function(ranges, primIndex) {\n  this.ranges = ranges;\n  this.primIndex = primIndex;\n};\n\nSelection.prototype.primary = function () { return this.ranges[this.primIndex] };\n\nSelection.prototype.equals = function (other) {\n    var this$1 = this;\n\n  if (other == this) { return true }\n  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\n  for (var i = 0; i < this.ranges.length; i++) {\n    var here = this$1.ranges[i], there = other.ranges[i];\n    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\n  }\n  return true\n};\n\nSelection.prototype.deepCopy = function () {\n    var this$1 = this;\n\n  var out = [];\n  for (var i = 0; i < this.ranges.length; i++)\n    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }\n  return new Selection(out, this.primIndex)\n};\n\nSelection.prototype.somethingSelected = function () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.ranges.length; i++)\n    { if (!this$1.ranges[i].empty()) { return true } }\n  return false\n};\n\nSelection.prototype.contains = function (pos, end) {\n    var this$1 = this;\n\n  if (!end) { end = pos; }\n  for (var i = 0; i < this.ranges.length; i++) {\n    var range = this$1.ranges[i];\n    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n      { return i }\n  }\n  return -1\n};\n\nvar Range = function(anchor, head) {\n  this.anchor = anchor; this.head = head;\n};\n\nRange.prototype.from = function () { return minPos(this.anchor, this.head) };\nRange.prototype.to = function () { return maxPos(this.anchor, this.head) };\nRange.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\n\n// Take an unsorted, potentially overlapping set of ranges, and\n// build a selection out of it. 'Consumes' ranges array (modifying\n// it).\nfunction normalizeSelection(ranges, primIndex) {\n  var prim = ranges[primIndex];\n  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\n  primIndex = indexOf(ranges, prim);\n  for (var i = 1; i < ranges.length; i++) {\n    var cur = ranges[i], prev = ranges[i - 1];\n    if (cmp(prev.to(), cur.from()) >= 0) {\n      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n      if (i <= primIndex) { --primIndex; }\n      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n    }\n  }\n  return new Selection(ranges, primIndex)\n}\n\nfunction simpleSelection(anchor, head) {\n  return new Selection([new Range(anchor, head || anchor)], 0)\n}\n\n// Compute the position of the end of a change (its 'to' property\n// refers to the pre-change end).\nfunction changeEnd(change) {\n  if (!change.text) { return change.to }\n  return Pos(change.from.line + change.text.length - 1,\n             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\n}\n\n// Adjust a position to refer to the post-change position of the\n// same text, or the end of the change if the change covers it.\nfunction adjustForChange(pos, change) {\n  if (cmp(pos, change.from) < 0) { return pos }\n  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\n\n  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\n  return Pos(line, ch)\n}\n\nfunction computeSelAfterChange(doc, change) {\n  var out = [];\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\n    var range = doc.sel.ranges[i];\n    out.push(new Range(adjustForChange(range.anchor, change),\n                       adjustForChange(range.head, change)));\n  }\n  return normalizeSelection(out, doc.sel.primIndex)\n}\n\nfunction offsetPos(pos, old, nw) {\n  if (pos.line == old.line)\n    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\n  else\n    { return Pos(nw.line + (pos.line - old.line), pos.ch) }\n}\n\n// Used by replaceSelections to allow moving the selection to the\n// start or around the replaced test. Hint may be \"start\" or \"around\".\nfunction computeReplacedSel(doc, changes, hint) {\n  var out = [];\n  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n    var from = offsetPos(change.from, oldPrev, newPrev);\n    var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n    oldPrev = change.to;\n    newPrev = to;\n    if (hint == \"around\") {\n      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n      out[i] = new Range(inv ? to : from, inv ? from : to);\n    } else {\n      out[i] = new Range(from, from);\n    }\n  }\n  return new Selection(out, doc.sel.primIndex)\n}\n\n// Used to get the editor into a consistent state again when options change.\n\nfunction loadMode(cm) {\n  cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n  resetModeState(cm);\n}\n\nfunction resetModeState(cm) {\n  cm.doc.iter(function (line) {\n    if (line.stateAfter) { line.stateAfter = null; }\n    if (line.styles) { line.styles = null; }\n  });\n  cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n  startWorker(cm, 100);\n  cm.state.modeGen++;\n  if (cm.curOp) { regChange(cm); }\n}\n\n// DOCUMENT DATA STRUCTURE\n\n// By default, updates that start and end at the beginning of a line\n// are treated specially, in order to make the association of line\n// widgets and marker elements with the text behave more intuitive.\nfunction isWholeLineUpdate(doc, change) {\n  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\n}\n\n// Perform a change on the document data structure.\nfunction updateDoc(doc, change, markedSpans, estimateHeight$$1) {\n  function spansFor(n) {return markedSpans ? markedSpans[n] : null}\n  function update(line, text, spans) {\n    updateLine(line, text, spans, estimateHeight$$1);\n    signalLater(line, \"change\", line, change);\n  }\n  function linesFor(start, end) {\n    var result = [];\n    for (var i = start; i < end; ++i)\n      { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }\n    return result\n  }\n\n  var from = change.from, to = change.to, text = change.text;\n  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n  // Adjust the line structure\n  if (change.full) {\n    doc.insert(0, linesFor(0, text.length));\n    doc.remove(text.length, doc.size - text.length);\n  } else if (isWholeLineUpdate(doc, change)) {\n    // This is a whole-line replace. Treated specially to make\n    // sure line objects move the way they are supposed to.\n    var added = linesFor(0, text.length - 1);\n    update(lastLine, lastLine.text, lastSpans);\n    if (nlines) { doc.remove(from.line, nlines); }\n    if (added.length) { doc.insert(from.line, added); }\n  } else if (firstLine == lastLine) {\n    if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n    } else {\n      var added$1 = linesFor(1, text.length - 1);\n      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      doc.insert(from.line + 1, added$1);\n    }\n  } else if (text.length == 1) {\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n    doc.remove(from.line + 1, nlines);\n  } else {\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n    var added$2 = linesFor(1, text.length - 1);\n    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\n    doc.insert(from.line + 1, added$2);\n  }\n\n  signalLater(doc, \"change\", doc, change);\n}\n\n// Call f for all linked documents.\nfunction linkedDocs(doc, f, sharedHistOnly) {\n  function propagate(doc, skip, sharedHist) {\n    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\n      var rel = doc.linked[i];\n      if (rel.doc == skip) { continue }\n      var shared = sharedHist && rel.sharedHist;\n      if (sharedHistOnly && !shared) { continue }\n      f(rel.doc, shared);\n      propagate(rel.doc, doc, shared);\n    } }\n  }\n  propagate(doc, null, true);\n}\n\n// Attach a document to an editor.\nfunction attachDoc(cm, doc) {\n  if (doc.cm) { throw new Error(\"This document is already in use.\") }\n  cm.doc = doc;\n  doc.cm = cm;\n  estimateLineHeights(cm);\n  loadMode(cm);\n  setDirectionClass(cm);\n  if (!cm.options.lineWrapping) { findMaxLine(cm); }\n  cm.options.mode = doc.modeOption;\n  regChange(cm);\n}\n\nfunction setDirectionClass(cm) {\n  (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n}\n\nfunction directionChanged(cm) {\n  runInOp(cm, function () {\n    setDirectionClass(cm);\n    regChange(cm);\n  });\n}\n\nfunction History(startGen) {\n  // Arrays of change events and selections. Doing something adds an\n  // event to done and clears undo. Undoing moves events from done\n  // to undone, redoing moves them in the other direction.\n  this.done = []; this.undone = [];\n  this.undoDepth = Infinity;\n  // Used to track when changes can be merged into a single undo\n  // event\n  this.lastModTime = this.lastSelTime = 0;\n  this.lastOp = this.lastSelOp = null;\n  this.lastOrigin = this.lastSelOrigin = null;\n  // Used by the isClean() method\n  this.generation = this.maxGeneration = startGen || 1;\n}\n\n// Create a history change event from an updateDoc-style change\n// object.\nfunction historyChangeFromChange(doc, change) {\n  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\n  return histChange\n}\n\n// Pop all selection events off the end of a history array. Stop at\n// a change event.\nfunction clearSelectionEvents(array) {\n  while (array.length) {\n    var last = lst(array);\n    if (last.ranges) { array.pop(); }\n    else { break }\n  }\n}\n\n// Find the top change event in the history. Pop off selection\n// events that are in the way.\nfunction lastChangeEvent(hist, force) {\n  if (force) {\n    clearSelectionEvents(hist.done);\n    return lst(hist.done)\n  } else if (hist.done.length && !lst(hist.done).ranges) {\n    return lst(hist.done)\n  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n    hist.done.pop();\n    return lst(hist.done)\n  }\n}\n\n// Register a change in the history. Merges changes that are within\n// a single operation, or are close together with an origin that\n// allows merging (starting with \"+\") into a single event.\nfunction addChangeToHistory(doc, change, selAfter, opId) {\n  var hist = doc.history;\n  hist.undone.length = 0;\n  var time = +new Date, cur;\n  var last;\n\n  if ((hist.lastOp == opId ||\n       hist.lastOrigin == change.origin && change.origin &&\n       ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n        change.origin.charAt(0) == \"*\")) &&\n      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n    // Merge this change into the last event\n    last = lst(cur.changes);\n    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n      // Optimized case for simple insertion -- don't want to add\n      // new changesets for every character typed\n      last.to = changeEnd(change);\n    } else {\n      // Add new sub-event\n      cur.changes.push(historyChangeFromChange(doc, change));\n    }\n  } else {\n    // Can not be merged, start a new event.\n    var before = lst(hist.done);\n    if (!before || !before.ranges)\n      { pushSelectionToHistory(doc.sel, hist.done); }\n    cur = {changes: [historyChangeFromChange(doc, change)],\n           generation: hist.generation};\n    hist.done.push(cur);\n    while (hist.done.length > hist.undoDepth) {\n      hist.done.shift();\n      if (!hist.done[0].ranges) { hist.done.shift(); }\n    }\n  }\n  hist.done.push(selAfter);\n  hist.generation = ++hist.maxGeneration;\n  hist.lastModTime = hist.lastSelTime = time;\n  hist.lastOp = hist.lastSelOp = opId;\n  hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n  if (!last) { signal(doc, \"historyAdded\"); }\n}\n\nfunction selectionEventCanBeMerged(doc, origin, prev, sel) {\n  var ch = origin.charAt(0);\n  return ch == \"*\" ||\n    ch == \"+\" &&\n    prev.ranges.length == sel.ranges.length &&\n    prev.somethingSelected() == sel.somethingSelected() &&\n    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\n}\n\n// Called whenever the selection changes, sets the new selection as\n// the pending selection in the history, and pushes the old pending\n// selection into the 'done' array when it was significantly\n// different (in number of selected ranges, emptiness, or time).\nfunction addSelectionToHistory(doc, sel, opId, options) {\n  var hist = doc.history, origin = options && options.origin;\n\n  // A new event is started when the previous origin does not match\n  // the current, or the origins don't allow matching. Origins\n  // starting with * are always merged, those starting with + are\n  // merged when similar and close together in time.\n  if (opId == hist.lastSelOp ||\n      (origin && hist.lastSelOrigin == origin &&\n       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n    { hist.done[hist.done.length - 1] = sel; }\n  else\n    { pushSelectionToHistory(sel, hist.done); }\n\n  hist.lastSelTime = +new Date;\n  hist.lastSelOrigin = origin;\n  hist.lastSelOp = opId;\n  if (options && options.clearRedo !== false)\n    { clearSelectionEvents(hist.undone); }\n}\n\nfunction pushSelectionToHistory(sel, dest) {\n  var top = lst(dest);\n  if (!(top && top.ranges && top.equals(sel)))\n    { dest.push(sel); }\n}\n\n// Used to store marked span information in the history.\nfunction attachLocalSpans(doc, change, from, to) {\n  var existing = change[\"spans_\" + doc.id], n = 0;\n  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n    if (line.markedSpans)\n      { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\n    ++n;\n  });\n}\n\n// When un/re-doing restores text containing marked spans, those\n// that have been explicitly cleared should not be restored.\nfunction removeClearedSpans(spans) {\n  if (!spans) { return null }\n  var out;\n  for (var i = 0; i < spans.length; ++i) {\n    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\n    else if (out) { out.push(spans[i]); }\n  }\n  return !out ? spans : out.length ? out : null\n}\n\n// Retrieve and filter the old marked spans stored in a change event.\nfunction getOldSpans(doc, change) {\n  var found = change[\"spans_\" + doc.id];\n  if (!found) { return null }\n  var nw = [];\n  for (var i = 0; i < change.text.length; ++i)\n    { nw.push(removeClearedSpans(found[i])); }\n  return nw\n}\n\n// Used for un/re-doing changes from the history. Combines the\n// result of computing the existing spans with the set of spans that\n// existed in the history (so that deleting around a span and then\n// undoing brings back the span).\nfunction mergeOldSpans(doc, change) {\n  var old = getOldSpans(doc, change);\n  var stretched = stretchSpansOverChange(doc, change);\n  if (!old) { return stretched }\n  if (!stretched) { return old }\n\n  for (var i = 0; i < old.length; ++i) {\n    var oldCur = old[i], stretchCur = stretched[i];\n    if (oldCur && stretchCur) {\n      spans: for (var j = 0; j < stretchCur.length; ++j) {\n        var span = stretchCur[j];\n        for (var k = 0; k < oldCur.length; ++k)\n          { if (oldCur[k].marker == span.marker) { continue spans } }\n        oldCur.push(span);\n      }\n    } else if (stretchCur) {\n      old[i] = stretchCur;\n    }\n  }\n  return old\n}\n\n// Used both to provide a JSON-safe object in .getHistory, and, when\n// detaching a document, to split the history in two\nfunction copyHistoryArray(events, newGroup, instantiateSel) {\n  var copy = [];\n  for (var i = 0; i < events.length; ++i) {\n    var event = events[i];\n    if (event.ranges) {\n      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n      continue\n    }\n    var changes = event.changes, newChanges = [];\n    copy.push({changes: newChanges});\n    for (var j = 0; j < changes.length; ++j) {\n      var change = changes[j], m = (void 0);\n      newChanges.push({from: change.from, to: change.to, text: change.text});\n      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\n        if (indexOf(newGroup, Number(m[1])) > -1) {\n          lst(newChanges)[prop] = change[prop];\n          delete change[prop];\n        }\n      } } }\n    }\n  }\n  return copy\n}\n\n// The 'scroll' parameter given to many of these indicated whether\n// the new cursor position should be scrolled into view after\n// modifying the selection.\n\n// If shift is held or the extend flag is set, extends a range to\n// include a given position (and optionally a second position).\n// Otherwise, simply returns the range between the given positions.\n// Used for cursor motion and such.\nfunction extendRange(range, head, other, extend) {\n  if (extend) {\n    var anchor = range.anchor;\n    if (other) {\n      var posBefore = cmp(head, anchor) < 0;\n      if (posBefore != (cmp(other, anchor) < 0)) {\n        anchor = head;\n        head = other;\n      } else if (posBefore != (cmp(head, other) < 0)) {\n        head = other;\n      }\n    }\n    return new Range(anchor, head)\n  } else {\n    return new Range(other || head, head)\n  }\n}\n\n// Extend the primary selection range, discard the rest.\nfunction extendSelection(doc, head, other, options, extend) {\n  if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }\n  setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n}\n\n// Extend all selections (pos is an array of selections with length\n// equal the number of selections)\nfunction extendSelections(doc, heads, options) {\n  var out = [];\n  var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n  for (var i = 0; i < doc.sel.ranges.length; i++)\n    { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }\n  var newSel = normalizeSelection(out, doc.sel.primIndex);\n  setSelection(doc, newSel, options);\n}\n\n// Updates a single range in the selection.\nfunction replaceOneSelection(doc, i, range, options) {\n  var ranges = doc.sel.ranges.slice(0);\n  ranges[i] = range;\n  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n}\n\n// Reset the selection to a single range.\nfunction setSimpleSelection(doc, anchor, head, options) {\n  setSelection(doc, simpleSelection(anchor, head), options);\n}\n\n// Give beforeSelectionChange handlers a change to influence a\n// selection update.\nfunction filterSelectionChange(doc, sel, options) {\n  var obj = {\n    ranges: sel.ranges,\n    update: function(ranges) {\n      var this$1 = this;\n\n      this.ranges = [];\n      for (var i = 0; i < ranges.length; i++)\n        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                   clipPos(doc, ranges[i].head)); }\n    },\n    origin: options && options.origin\n  };\n  signal(doc, \"beforeSelectionChange\", doc, obj);\n  if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\n  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }\n  else { return sel }\n}\n\nfunction setSelectionReplaceHistory(doc, sel, options) {\n  var done = doc.history.done, last = lst(done);\n  if (last && last.ranges) {\n    done[done.length - 1] = sel;\n    setSelectionNoUndo(doc, sel, options);\n  } else {\n    setSelection(doc, sel, options);\n  }\n}\n\n// Set a new selection.\nfunction setSelection(doc, sel, options) {\n  setSelectionNoUndo(doc, sel, options);\n  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n}\n\nfunction setSelectionNoUndo(doc, sel, options) {\n  if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n    { sel = filterSelectionChange(doc, sel, options); }\n\n  var bias = options && options.bias ||\n    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n  if (!(options && options.scroll === false) && doc.cm)\n    { ensureCursorVisible(doc.cm); }\n}\n\nfunction setSelectionInner(doc, sel) {\n  if (sel.equals(doc.sel)) { return }\n\n  doc.sel = sel;\n\n  if (doc.cm) {\n    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n    signalCursorActivity(doc.cm);\n  }\n  signalLater(doc, \"cursorActivity\", doc);\n}\n\n// Verify that the selection does not partially select any atomic\n// marked ranges.\nfunction reCheckSelection(doc) {\n  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n}\n\n// Return a selection that does not partially select any atomic\n// ranges.\nfunction skipAtomicInSelection(doc, sel, bias, mayClear) {\n  var out;\n  for (var i = 0; i < sel.ranges.length; i++) {\n    var range = sel.ranges[i];\n    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n    if (out || newAnchor != range.anchor || newHead != range.head) {\n      if (!out) { out = sel.ranges.slice(0, i); }\n      out[i] = new Range(newAnchor, newHead);\n    }\n  }\n  return out ? normalizeSelection(out, sel.primIndex) : sel\n}\n\nfunction skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n  var line = getLine(doc, pos.line);\n  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n    var sp = line.markedSpans[i], m = sp.marker;\n    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n      if (mayClear) {\n        signal(m, \"beforeCursorEnter\");\n        if (m.explicitlyCleared) {\n          if (!line.markedSpans) { break }\n          else {--i; continue}\n        }\n      }\n      if (!m.atomic) { continue }\n\n      if (oldPos) {\n        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\n        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\n          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\n        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n          { return skipAtomicInner(doc, near, pos, dir, mayClear) }\n      }\n\n      var far = m.find(dir < 0 ? -1 : 1);\n      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\n        { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\n      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\n    }\n  } }\n  return pos\n}\n\n// Ensure a given position is not inside an atomic range.\nfunction skipAtomic(doc, pos, oldPos, bias, mayClear) {\n  var dir = bias || 1;\n  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n  if (!found) {\n    doc.cantEdit = true;\n    return Pos(doc.first, 0)\n  }\n  return found\n}\n\nfunction movePos(doc, pos, dir, line) {\n  if (dir < 0 && pos.ch == 0) {\n    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\n    else { return null }\n  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\n    else { return null }\n  } else {\n    return new Pos(pos.line, pos.ch + dir)\n  }\n}\n\nfunction selectAll(cm) {\n  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n}\n\n// UPDATING\n\n// Allow \"beforeChange\" event handlers to influence a change\nfunction filterChange(doc, change, update) {\n  var obj = {\n    canceled: false,\n    from: change.from,\n    to: change.to,\n    text: change.text,\n    origin: change.origin,\n    cancel: function () { return obj.canceled = true; }\n  };\n  if (update) { obj.update = function (from, to, text, origin) {\n    if (from) { obj.from = clipPos(doc, from); }\n    if (to) { obj.to = clipPos(doc, to); }\n    if (text) { obj.text = text; }\n    if (origin !== undefined) { obj.origin = origin; }\n  }; }\n  signal(doc, \"beforeChange\", doc, obj);\n  if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\n\n  if (obj.canceled) { return null }\n  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\n}\n\n// Apply a change to a document, and add it to the document's\n// history, and propagating it to all linked documents.\nfunction makeChange(doc, change, ignoreReadOnly) {\n  if (doc.cm) {\n    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\n    if (doc.cm.state.suppressEdits) { return }\n  }\n\n  if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n    change = filterChange(doc, change, true);\n    if (!change) { return }\n  }\n\n  // Possibly split or suppress the update based on the presence\n  // of read-only spans in its range.\n  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n  if (split) {\n    for (var i = split.length - 1; i >= 0; --i)\n      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text}); }\n  } else {\n    makeChangeInner(doc, change);\n  }\n}\n\nfunction makeChangeInner(doc, change) {\n  if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) { return }\n  var selAfter = computeSelAfterChange(doc, change);\n  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n  var rebased = [];\n\n  linkedDocs(doc, function (doc, sharedHist) {\n    if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n      rebaseHist(doc.history, change);\n      rebased.push(doc.history);\n    }\n    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n  });\n}\n\n// Revert a change stored in a document's history.\nfunction makeChangeFromHistory(doc, type, allowSelectionOnly) {\n  if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }\n\n  var hist = doc.history, event, selAfter = doc.sel;\n  var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n  // Verify that there is a useable event (so that ctrl-z won't\n  // needlessly clear selection events)\n  var i = 0;\n  for (; i < source.length; i++) {\n    event = source[i];\n    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n      { break }\n  }\n  if (i == source.length) { return }\n  hist.lastOrigin = hist.lastSelOrigin = null;\n\n  for (;;) {\n    event = source.pop();\n    if (event.ranges) {\n      pushSelectionToHistory(event, dest);\n      if (allowSelectionOnly && !event.equals(doc.sel)) {\n        setSelection(doc, event, {clearRedo: false});\n        return\n      }\n      selAfter = event;\n    }\n    else { break }\n  }\n\n  // Build up a reverse change object to add to the opposite history\n  // stack (redo when undoing, and vice versa).\n  var antiChanges = [];\n  pushSelectionToHistory(selAfter, dest);\n  dest.push({changes: antiChanges, generation: hist.generation});\n  hist.generation = event.generation || ++hist.maxGeneration;\n\n  var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n  var loop = function ( i ) {\n    var change = event.changes[i];\n    change.origin = type;\n    if (filter && !filterChange(doc, change, false)) {\n      source.length = 0;\n      return {}\n    }\n\n    antiChanges.push(historyChangeFromChange(doc, change));\n\n    var after = i ? computeSelAfterChange(doc, change) : lst(source);\n    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\n    var rebased = [];\n\n    // Propagate to the linked documents\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n    });\n  };\n\n  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n    var returned = loop( i$1 );\n\n    if ( returned ) return returned.v;\n  }\n}\n\n// Sub-views need their line numbers shifted when text is added\n// above or below them in the parent document.\nfunction shiftDoc(doc, distance) {\n  if (distance == 0) { return }\n  doc.first += distance;\n  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\n    Pos(range.anchor.line + distance, range.anchor.ch),\n    Pos(range.head.line + distance, range.head.ch)\n  ); }), doc.sel.primIndex);\n  if (doc.cm) {\n    regChange(doc.cm, doc.first, doc.first - distance, distance);\n    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n      { regLineChange(doc.cm, l, \"gutter\"); }\n  }\n}\n\n// More lower-level change function, handling only a single document\n// (not linked ones).\nfunction makeChangeSingleDoc(doc, change, selAfter, spans) {\n  if (doc.cm && !doc.cm.curOp)\n    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\n\n  if (change.to.line < doc.first) {\n    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n    return\n  }\n  if (change.from.line > doc.lastLine()) { return }\n\n  // Clip the change to the size of this doc\n  if (change.from.line < doc.first) {\n    var shift = change.text.length - 1 - (doc.first - change.from.line);\n    shiftDoc(doc, shift);\n    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n              text: [lst(change.text)], origin: change.origin};\n  }\n  var last = doc.lastLine();\n  if (change.to.line > last) {\n    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n              text: [change.text[0]], origin: change.origin};\n  }\n\n  change.removed = getBetween(doc, change.from, change.to);\n\n  if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\n  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\n  else { updateDoc(doc, change, spans); }\n  setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n}\n\n// Handle the interaction of a change to a document with the editor\n// that this document is part of.\nfunction makeChangeSingleDocInEditor(cm, change, spans) {\n  var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n  var recomputeMaxLength = false, checkWidthStart = from.line;\n  if (!cm.options.lineWrapping) {\n    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n    doc.iter(checkWidthStart, to.line + 1, function (line) {\n      if (line == display.maxLine) {\n        recomputeMaxLength = true;\n        return true\n      }\n    });\n  }\n\n  if (doc.sel.contains(change.from, change.to) > -1)\n    { signalCursorActivity(cm); }\n\n  updateDoc(doc, change, spans, estimateHeight(cm));\n\n  if (!cm.options.lineWrapping) {\n    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n      var len = lineLength(line);\n      if (len > display.maxLineLength) {\n        display.maxLine = line;\n        display.maxLineLength = len;\n        display.maxLineChanged = true;\n        recomputeMaxLength = false;\n      }\n    });\n    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\n  }\n\n  retreatFrontier(doc, from.line);\n  startWorker(cm, 400);\n\n  var lendiff = change.text.length - (to.line - from.line) - 1;\n  // Remember that these lines changed, for updating the display\n  if (change.full)\n    { regChange(cm); }\n  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n    { regLineChange(cm, from.line, \"text\"); }\n  else\n    { regChange(cm, from.line, to.line + 1, lendiff); }\n\n  var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n  if (changeHandler || changesHandler) {\n    var obj = {\n      from: from, to: to,\n      text: change.text,\n      removed: change.removed,\n      origin: change.origin\n    };\n    if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\n    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\n  }\n  cm.display.selForContextMenu = null;\n}\n\nfunction replaceRange(doc, code, from, to, origin) {\n  if (!to) { to = from; }\n  if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\n  if (typeof code == \"string\") { code = doc.splitLines(code); }\n  makeChange(doc, {from: from, to: to, text: code, origin: origin});\n}\n\n// Rebasing/resetting history to deal with externally-sourced changes\n\nfunction rebaseHistSelSingle(pos, from, to, diff) {\n  if (to < pos.line) {\n    pos.line += diff;\n  } else if (from < pos.line) {\n    pos.line = from;\n    pos.ch = 0;\n  }\n}\n\n// Tries to rebase an array of history events given a change in the\n// document. If the change touches the same lines as the event, the\n// event, and everything 'behind' it, is discarded. If the change is\n// before the event, the event's positions are updated. Uses a\n// copy-on-write scheme for the positions, to avoid having to\n// reallocate them all on every rebase, but also avoid problems with\n// shared position objects being unsafely updated.\nfunction rebaseHistArray(array, from, to, diff) {\n  for (var i = 0; i < array.length; ++i) {\n    var sub = array[i], ok = true;\n    if (sub.ranges) {\n      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n      for (var j = 0; j < sub.ranges.length; j++) {\n        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n      }\n      continue\n    }\n    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n      var cur = sub.changes[j$1];\n      if (to < cur.from.line) {\n        cur.from = Pos(cur.from.line + diff, cur.from.ch);\n        cur.to = Pos(cur.to.line + diff, cur.to.ch);\n      } else if (from <= cur.to.line) {\n        ok = false;\n        break\n      }\n    }\n    if (!ok) {\n      array.splice(0, i + 1);\n      i = 0;\n    }\n  }\n}\n\nfunction rebaseHist(hist, change) {\n  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n  rebaseHistArray(hist.done, from, to, diff);\n  rebaseHistArray(hist.undone, from, to, diff);\n}\n\n// Utility for applying a change to a line by handle or number,\n// returning the number and optionally registering the line as\n// changed.\nfunction changeLine(doc, handle, changeType, op) {\n  var no = handle, line = handle;\n  if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\n  else { no = lineNo(handle); }\n  if (no == null) { return null }\n  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\n  return line\n}\n\n// The document is represented as a BTree consisting of leaves, with\n// chunk of lines in them, and branches, with up to ten leaves or\n// other branch nodes below them. The top node is always a branch\n// node, and is the document object itself (meaning it has\n// additional methods and properties).\n//\n// All nodes have parent links. The tree is used both to go from\n// line numbers to line objects, and to go from objects to numbers.\n// It also indexes by height, and is used to convert between height\n// and line object, and to find the total height of the document.\n//\n// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\nfunction LeafChunk(lines) {\n  var this$1 = this;\n\n  this.lines = lines;\n  this.parent = null;\n  var height = 0;\n  for (var i = 0; i < lines.length; ++i) {\n    lines[i].parent = this$1;\n    height += lines[i].height;\n  }\n  this.height = height;\n}\n\nLeafChunk.prototype = {\n  chunkSize: function chunkSize() { return this.lines.length },\n\n  // Remove the n lines at offset 'at'.\n  removeInner: function removeInner(at, n) {\n    var this$1 = this;\n\n    for (var i = at, e = at + n; i < e; ++i) {\n      var line = this$1.lines[i];\n      this$1.height -= line.height;\n      cleanUpLine(line);\n      signalLater(line, \"delete\");\n    }\n    this.lines.splice(at, n);\n  },\n\n  // Helper used to collapse a small branch into a single leaf.\n  collapse: function collapse(lines) {\n    lines.push.apply(lines, this.lines);\n  },\n\n  // Insert the given array of lines at offset 'at', count them as\n  // having the given height.\n  insertInner: function insertInner(at, lines, height) {\n    var this$1 = this;\n\n    this.height += height;\n    this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n    for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }\n  },\n\n  // Used to iterate over a part of the tree.\n  iterN: function iterN(at, n, op) {\n    var this$1 = this;\n\n    for (var e = at + n; at < e; ++at)\n      { if (op(this$1.lines[at])) { return true } }\n  }\n};\n\nfunction BranchChunk(children) {\n  var this$1 = this;\n\n  this.children = children;\n  var size = 0, height = 0;\n  for (var i = 0; i < children.length; ++i) {\n    var ch = children[i];\n    size += ch.chunkSize(); height += ch.height;\n    ch.parent = this$1;\n  }\n  this.size = size;\n  this.height = height;\n  this.parent = null;\n}\n\nBranchChunk.prototype = {\n  chunkSize: function chunkSize() { return this.size },\n\n  removeInner: function removeInner(at, n) {\n    var this$1 = this;\n\n    this.size -= n;\n    for (var i = 0; i < this.children.length; ++i) {\n      var child = this$1.children[i], sz = child.chunkSize();\n      if (at < sz) {\n        var rm = Math.min(n, sz - at), oldHeight = child.height;\n        child.removeInner(at, rm);\n        this$1.height -= oldHeight - child.height;\n        if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }\n        if ((n -= rm) == 0) { break }\n        at = 0;\n      } else { at -= sz; }\n    }\n    // If the result is smaller than 25 lines, ensure that it is a\n    // single leaf node.\n    if (this.size - n < 25 &&\n        (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n      var lines = [];\n      this.collapse(lines);\n      this.children = [new LeafChunk(lines)];\n      this.children[0].parent = this;\n    }\n  },\n\n  collapse: function collapse(lines) {\n    var this$1 = this;\n\n    for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }\n  },\n\n  insertInner: function insertInner(at, lines, height) {\n    var this$1 = this;\n\n    this.size += lines.length;\n    this.height += height;\n    for (var i = 0; i < this.children.length; ++i) {\n      var child = this$1.children[i], sz = child.chunkSize();\n      if (at <= sz) {\n        child.insertInner(at, lines, height);\n        if (child.lines && child.lines.length > 50) {\n          // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n          // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n          var remaining = child.lines.length % 25 + 25;\n          for (var pos = remaining; pos < child.lines.length;) {\n            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n            child.height -= leaf.height;\n            this$1.children.splice(++i, 0, leaf);\n            leaf.parent = this$1;\n          }\n          child.lines = child.lines.slice(0, remaining);\n          this$1.maybeSpill();\n        }\n        break\n      }\n      at -= sz;\n    }\n  },\n\n  // When a node has grown, check whether it should be split.\n  maybeSpill: function maybeSpill() {\n    if (this.children.length <= 10) { return }\n    var me = this;\n    do {\n      var spilled = me.children.splice(me.children.length - 5, 5);\n      var sibling = new BranchChunk(spilled);\n      if (!me.parent) { // Become the parent node\n        var copy = new BranchChunk(me.children);\n        copy.parent = me;\n        me.children = [copy, sibling];\n        me = copy;\n     } else {\n        me.size -= sibling.size;\n        me.height -= sibling.height;\n        var myIndex = indexOf(me.parent.children, me);\n        me.parent.children.splice(myIndex + 1, 0, sibling);\n      }\n      sibling.parent = me.parent;\n    } while (me.children.length > 10)\n    me.parent.maybeSpill();\n  },\n\n  iterN: function iterN(at, n, op) {\n    var this$1 = this;\n\n    for (var i = 0; i < this.children.length; ++i) {\n      var child = this$1.children[i], sz = child.chunkSize();\n      if (at < sz) {\n        var used = Math.min(n, sz - at);\n        if (child.iterN(at, used, op)) { return true }\n        if ((n -= used) == 0) { break }\n        at = 0;\n      } else { at -= sz; }\n    }\n  }\n};\n\n// Line widgets are block elements displayed above or below a line.\n\nvar LineWidget = function(doc, node, options) {\n  var this$1 = this;\n\n  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\n    { this$1[opt] = options[opt]; } } }\n  this.doc = doc;\n  this.node = node;\n};\n\nLineWidget.prototype.clear = function () {\n    var this$1 = this;\n\n  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n  if (no == null || !ws) { return }\n  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }\n  if (!ws.length) { line.widgets = null; }\n  var height = widgetHeight(this);\n  updateLineHeight(line, Math.max(0, line.height - height));\n  if (cm) {\n    runInOp(cm, function () {\n      adjustScrollWhenAboveVisible(cm, line, -height);\n      regLineChange(cm, no, \"widget\");\n    });\n    signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n  }\n};\n\nLineWidget.prototype.changed = function () {\n    var this$1 = this;\n\n  var oldH = this.height, cm = this.doc.cm, line = this.line;\n  this.height = null;\n  var diff = widgetHeight(this) - oldH;\n  if (!diff) { return }\n  updateLineHeight(line, line.height + diff);\n  if (cm) {\n    runInOp(cm, function () {\n      cm.curOp.forceUpdate = true;\n      adjustScrollWhenAboveVisible(cm, line, diff);\n      signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n    });\n  }\n};\neventMixin(LineWidget);\n\nfunction adjustScrollWhenAboveVisible(cm, line, diff) {\n  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n    { addToScrollTop(cm, diff); }\n}\n\nfunction addLineWidget(doc, handle, node, options) {\n  var widget = new LineWidget(doc, node, options);\n  var cm = doc.cm;\n  if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\n  changeLine(doc, handle, \"widget\", function (line) {\n    var widgets = line.widgets || (line.widgets = []);\n    if (widget.insertAt == null) { widgets.push(widget); }\n    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }\n    widget.line = line;\n    if (cm && !lineIsHidden(doc, line)) {\n      var aboveVisible = heightAtLine(line) < doc.scrollTop;\n      updateLineHeight(line, line.height + widgetHeight(widget));\n      if (aboveVisible) { addToScrollTop(cm, widget.height); }\n      cm.curOp.forceUpdate = true;\n    }\n    return true\n  });\n  signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle));\n  return widget\n}\n\n// TEXTMARKERS\n\n// Created with markText and setBookmark methods. A TextMarker is a\n// handle that can be used to clear or find a marked position in the\n// document. Line objects hold arrays (markedSpans) containing\n// {from, to, marker} object pointing to such marker objects, and\n// indicating that such a marker is present on that line. Multiple\n// lines may point to the same marker when it spans across lines.\n// The spans will have null for their from/to properties when the\n// marker continues beyond the start/end of the line. Markers have\n// links back to the lines they currently touch.\n\n// Collapsed markers have unique ids, in order to be able to order\n// them, which is needed for uniquely determining an outer marker\n// when they overlap (they may nest, but not partially overlap).\nvar nextMarkerId = 0;\n\nvar TextMarker = function(doc, type) {\n  this.lines = [];\n  this.type = type;\n  this.doc = doc;\n  this.id = ++nextMarkerId;\n};\n\n// Clear the marker.\nTextMarker.prototype.clear = function () {\n    var this$1 = this;\n\n  if (this.explicitlyCleared) { return }\n  var cm = this.doc.cm, withOp = cm && !cm.curOp;\n  if (withOp) { startOperation(cm); }\n  if (hasHandler(this, \"clear\")) {\n    var found = this.find();\n    if (found) { signalLater(this, \"clear\", found.from, found.to); }\n  }\n  var min = null, max = null;\n  for (var i = 0; i < this.lines.length; ++i) {\n    var line = this$1.lines[i];\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\n    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\n    else if (cm) {\n      if (span.to != null) { max = lineNo(line); }\n      if (span.from != null) { min = lineNo(line); }\n    }\n    line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)\n      { updateLineHeight(line, textHeight(cm.display)); }\n  }\n  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);\n    if (len > cm.display.maxLineLength) {\n      cm.display.maxLine = visual;\n      cm.display.maxLineLength = len;\n      cm.display.maxLineChanged = true;\n    }\n  } }\n\n  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\n  this.lines.length = 0;\n  this.explicitlyCleared = true;\n  if (this.atomic && this.doc.cantEdit) {\n    this.doc.cantEdit = false;\n    if (cm) { reCheckSelection(cm.doc); }\n  }\n  if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\n  if (withOp) { endOperation(cm); }\n  if (this.parent) { this.parent.clear(); }\n};\n\n// Find the position of the marker in the document. Returns a {from,\n// to} object by default. Side can be passed to get a specific side\n// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n// Pos objects returned contain a line object, rather than a line\n// number (used to prevent looking up the same line twice).\nTextMarker.prototype.find = function (side, lineObj) {\n    var this$1 = this;\n\n  if (side == null && this.type == \"bookmark\") { side = 1; }\n  var from, to;\n  for (var i = 0; i < this.lines.length; ++i) {\n    var line = this$1.lines[i];\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\n    if (span.from != null) {\n      from = Pos(lineObj ? line : lineNo(line), span.from);\n      if (side == -1) { return from }\n    }\n    if (span.to != null) {\n      to = Pos(lineObj ? line : lineNo(line), span.to);\n      if (side == 1) { return to }\n    }\n  }\n  return from && {from: from, to: to}\n};\n\n// Signals that the marker's widget changed, and surrounding layout\n// should be recomputed.\nTextMarker.prototype.changed = function () {\n    var this$1 = this;\n\n  var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n  if (!pos || !cm) { return }\n  runInOp(cm, function () {\n    var line = pos.line, lineN = lineNo(pos.line);\n    var view = findViewForLine(cm, lineN);\n    if (view) {\n      clearLineMeasurementCacheFor(view);\n      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n    }\n    cm.curOp.updateMaxLine = true;\n    if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n      var oldHeight = widget.height;\n      widget.height = null;\n      var dHeight = widgetHeight(widget) - oldHeight;\n      if (dHeight)\n        { updateLineHeight(line, line.height + dHeight); }\n    }\n    signalLater(cm, \"markerChanged\", cm, this$1);\n  });\n};\n\nTextMarker.prototype.attachLine = function (line) {\n  if (!this.lines.length && this.doc.cm) {\n    var op = this.doc.cm.curOp;\n    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\n  }\n  this.lines.push(line);\n};\n\nTextMarker.prototype.detachLine = function (line) {\n  this.lines.splice(indexOf(this.lines, line), 1);\n  if (!this.lines.length && this.doc.cm) {\n    var op = this.doc.cm.curOp;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n  }\n};\neventMixin(TextMarker);\n\n// Create a marker, wire it up to the right lines, and\nfunction markText(doc, from, to, options, type) {\n  // Shared markers (across linked documents) are handled separately\n  // (markTextShared will call out to this again, once per\n  // document).\n  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\n  // Ensure we are in an operation.\n  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\n\n  var marker = new TextMarker(doc, type), diff = cmp(from, to);\n  if (options) { copyObj(options, marker, false); }\n  // Don't connect empty markers unless clearWhenEmpty is false\n  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n    { return marker }\n  if (marker.replacedWith) {\n    // Showing up as a widget implies collapsed (widget replaces text)\n    marker.collapsed = true;\n    marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\n    if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\n  }\n  if (marker.collapsed) {\n    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n      { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\n    seeCollapsedSpans();\n  }\n\n  if (marker.addToHistory)\n    { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\n\n  var curLine = from.line, cm = doc.cm, updateMaxLine;\n  doc.iter(curLine, to.line + 1, function (line) {\n    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n      { updateMaxLine = true; }\n    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\n    addMarkedSpan(line, new MarkedSpan(marker,\n                                       curLine == from.line ? from.ch : null,\n                                       curLine == to.line ? to.ch : null));\n    ++curLine;\n  });\n  // lineIsHidden depends on the presence of the spans, so needs a second pass\n  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\n    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\n  }); }\n\n  if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\n\n  if (marker.readOnly) {\n    seeReadOnlySpans();\n    if (doc.history.done.length || doc.history.undone.length)\n      { doc.clearHistory(); }\n  }\n  if (marker.collapsed) {\n    marker.id = ++nextMarkerId;\n    marker.atomic = true;\n  }\n  if (cm) {\n    // Sync editor state\n    if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\n    if (marker.collapsed)\n      { regChange(cm, from.line, to.line + 1); }\n    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\n      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \"text\"); } }\n    if (marker.atomic) { reCheckSelection(cm.doc); }\n    signalLater(cm, \"markerAdded\", cm, marker);\n  }\n  return marker\n}\n\n// SHARED TEXTMARKERS\n\n// A shared marker spans multiple linked documents. It is\n// implemented as a meta-marker-object controlling multiple normal\n// markers.\nvar SharedTextMarker = function(markers, primary) {\n  var this$1 = this;\n\n  this.markers = markers;\n  this.primary = primary;\n  for (var i = 0; i < markers.length; ++i)\n    { markers[i].parent = this$1; }\n};\n\nSharedTextMarker.prototype.clear = function () {\n    var this$1 = this;\n\n  if (this.explicitlyCleared) { return }\n  this.explicitlyCleared = true;\n  for (var i = 0; i < this.markers.length; ++i)\n    { this$1.markers[i].clear(); }\n  signalLater(this, \"clear\");\n};\n\nSharedTextMarker.prototype.find = function (side, lineObj) {\n  return this.primary.find(side, lineObj)\n};\neventMixin(SharedTextMarker);\n\nfunction markTextShared(doc, from, to, options, type) {\n  options = copyObj(options);\n  options.shared = false;\n  var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n  var widget = options.widgetNode;\n  linkedDocs(doc, function (doc) {\n    if (widget) { options.widgetNode = widget.cloneNode(true); }\n    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n    for (var i = 0; i < doc.linked.length; ++i)\n      { if (doc.linked[i].isParent) { return } }\n    primary = lst(markers);\n  });\n  return new SharedTextMarker(markers, primary)\n}\n\nfunction findSharedMarkers(doc) {\n  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\n}\n\nfunction copySharedMarkers(doc, markers) {\n  for (var i = 0; i < markers.length; i++) {\n    var marker = markers[i], pos = marker.find();\n    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n    if (cmp(mFrom, mTo)) {\n      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n      marker.markers.push(subMark);\n      subMark.parent = marker;\n    }\n  }\n}\n\nfunction detachSharedMarkers(markers) {\n  var loop = function ( i ) {\n    var marker = markers[i], linked = [marker.primary.doc];\n    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\n    for (var j = 0; j < marker.markers.length; j++) {\n      var subMarker = marker.markers[j];\n      if (indexOf(linked, subMarker.doc) == -1) {\n        subMarker.parent = null;\n        marker.markers.splice(j--, 1);\n      }\n    }\n  };\n\n  for (var i = 0; i < markers.length; i++) loop( i );\n}\n\nvar nextDocId = 0;\nvar Doc = function(text, mode, firstLine, lineSep, direction) {\n  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\n  if (firstLine == null) { firstLine = 0; }\n\n  BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n  this.first = firstLine;\n  this.scrollTop = this.scrollLeft = 0;\n  this.cantEdit = false;\n  this.cleanGeneration = 1;\n  this.modeFrontier = this.highlightFrontier = firstLine;\n  var start = Pos(firstLine, 0);\n  this.sel = simpleSelection(start);\n  this.history = new History(null);\n  this.id = ++nextDocId;\n  this.modeOption = mode;\n  this.lineSep = lineSep;\n  this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\n  this.extend = false;\n\n  if (typeof text == \"string\") { text = this.splitLines(text); }\n  updateDoc(this, {from: start, to: start, text: text});\n  setSelection(this, simpleSelection(start), sel_dontScroll);\n};\n\nDoc.prototype = createObj(BranchChunk.prototype, {\n  constructor: Doc,\n  // Iterate over the document. Supports two forms -- with only one\n  // argument, it calls that for each line in the document. With\n  // three, it iterates over the range given by the first two (with\n  // the second being non-inclusive).\n  iter: function(from, to, op) {\n    if (op) { this.iterN(from - this.first, to - from, op); }\n    else { this.iterN(this.first, this.first + this.size, from); }\n  },\n\n  // Non-public interface for adding and removing lines.\n  insert: function(at, lines) {\n    var height = 0;\n    for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\n    this.insertInner(at - this.first, lines, height);\n  },\n  remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n  // From here, the methods are part of the public interface. Most\n  // are also available from CodeMirror (editor) instances.\n\n  getValue: function(lineSep) {\n    var lines = getLines(this, this.first, this.first + this.size);\n    if (lineSep === false) { return lines }\n    return lines.join(lineSep || this.lineSeparator())\n  },\n  setValue: docMethodOp(function(code) {\n    var top = Pos(this.first, 0), last = this.first + this.size - 1;\n    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                      text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n    if (this.cm) { scrollToCoords(this.cm, 0, 0); }\n    setSelection(this, simpleSelection(top), sel_dontScroll);\n  }),\n  replaceRange: function(code, from, to, origin) {\n    from = clipPos(this, from);\n    to = to ? clipPos(this, to) : from;\n    replaceRange(this, code, from, to, origin);\n  },\n  getRange: function(from, to, lineSep) {\n    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n    if (lineSep === false) { return lines }\n    return lines.join(lineSep || this.lineSeparator())\n  },\n\n  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\n\n  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\n  getLineNumber: function(line) {return lineNo(line)},\n\n  getLineHandleVisualStart: function(line) {\n    if (typeof line == \"number\") { line = getLine(this, line); }\n    return visualLine(line)\n  },\n\n  lineCount: function() {return this.size},\n  firstLine: function() {return this.first},\n  lastLine: function() {return this.first + this.size - 1},\n\n  clipPos: function(pos) {return clipPos(this, pos)},\n\n  getCursor: function(start) {\n    var range$$1 = this.sel.primary(), pos;\n    if (start == null || start == \"head\") { pos = range$$1.head; }\n    else if (start == \"anchor\") { pos = range$$1.anchor; }\n    else if (start == \"end\" || start == \"to\" || start === false) { pos = range$$1.to(); }\n    else { pos = range$$1.from(); }\n    return pos\n  },\n  listSelections: function() { return this.sel.ranges },\n  somethingSelected: function() {return this.sel.somethingSelected()},\n\n  setCursor: docMethodOp(function(line, ch, options) {\n    setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n  }),\n  setSelection: docMethodOp(function(anchor, head, options) {\n    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n  }),\n  extendSelection: docMethodOp(function(head, other, options) {\n    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n  }),\n  extendSelections: docMethodOp(function(heads, options) {\n    extendSelections(this, clipPosArray(this, heads), options);\n  }),\n  extendSelectionsBy: docMethodOp(function(f, options) {\n    var heads = map(this.sel.ranges, f);\n    extendSelections(this, clipPosArray(this, heads), options);\n  }),\n  setSelections: docMethodOp(function(ranges, primary, options) {\n    var this$1 = this;\n\n    if (!ranges.length) { return }\n    var out = [];\n    for (var i = 0; i < ranges.length; i++)\n      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),\n                         clipPos(this$1, ranges[i].head)); }\n    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\n    setSelection(this, normalizeSelection(out, primary), options);\n  }),\n  addSelection: docMethodOp(function(anchor, head, options) {\n    var ranges = this.sel.ranges.slice(0);\n    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n  }),\n\n  getSelection: function(lineSep) {\n    var this$1 = this;\n\n    var ranges = this.sel.ranges, lines;\n    for (var i = 0; i < ranges.length; i++) {\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n      lines = lines ? lines.concat(sel) : sel;\n    }\n    if (lineSep === false) { return lines }\n    else { return lines.join(lineSep || this.lineSeparator()) }\n  },\n  getSelections: function(lineSep) {\n    var this$1 = this;\n\n    var parts = [], ranges = this.sel.ranges;\n    for (var i = 0; i < ranges.length; i++) {\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }\n      parts[i] = sel;\n    }\n    return parts\n  },\n  replaceSelection: function(code, collapse, origin) {\n    var dup = [];\n    for (var i = 0; i < this.sel.ranges.length; i++)\n      { dup[i] = code; }\n    this.replaceSelections(dup, collapse, origin || \"+input\");\n  },\n  replaceSelections: docMethodOp(function(code, collapse, origin) {\n    var this$1 = this;\n\n    var changes = [], sel = this.sel;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range$$1 = sel.ranges[i];\n      changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};\n    }\n    var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\n      { makeChange(this$1, changes[i$1]); }\n    if (newSel) { setSelectionReplaceHistory(this, newSel); }\n    else if (this.cm) { ensureCursorVisible(this.cm); }\n  }),\n  undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n  redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n  setExtending: function(val) {this.extend = val;},\n  getExtending: function() {return this.extend},\n\n  historySize: function() {\n    var hist = this.history, done = 0, undone = 0;\n    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\n    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\n    return {undo: done, redo: undone}\n  },\n  clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\n  markClean: function() {\n    this.cleanGeneration = this.changeGeneration(true);\n  },\n  changeGeneration: function(forceSplit) {\n    if (forceSplit)\n      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\n    return this.history.generation\n  },\n  isClean: function (gen) {\n    return this.history.generation == (gen || this.cleanGeneration)\n  },\n\n  getHistory: function() {\n    return {done: copyHistoryArray(this.history.done),\n            undone: copyHistoryArray(this.history.undone)}\n  },\n  setHistory: function(histData) {\n    var hist = this.history = new History(this.history.maxGeneration);\n    hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n  },\n\n  setGutterMarker: docMethodOp(function(line, gutterID, value) {\n    return changeLine(this, line, \"gutter\", function (line) {\n      var markers = line.gutterMarkers || (line.gutterMarkers = {});\n      markers[gutterID] = value;\n      if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\n      return true\n    })\n  }),\n\n  clearGutter: docMethodOp(function(gutterID) {\n    var this$1 = this;\n\n    this.iter(function (line) {\n      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n        changeLine(this$1, line, \"gutter\", function () {\n          line.gutterMarkers[gutterID] = null;\n          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\n          return true\n        });\n      }\n    });\n  }),\n\n  lineInfo: function(line) {\n    var n;\n    if (typeof line == \"number\") {\n      if (!isLine(this, line)) { return null }\n      n = line;\n      line = getLine(this, line);\n      if (!line) { return null }\n    } else {\n      n = lineNo(line);\n      if (n == null) { return null }\n    }\n    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n            widgets: line.widgets}\n  },\n\n  addLineClass: docMethodOp(function(handle, where, cls) {\n    return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n      var prop = where == \"text\" ? \"textClass\"\n               : where == \"background\" ? \"bgClass\"\n               : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n      if (!line[prop]) { line[prop] = cls; }\n      else if (classTest(cls).test(line[prop])) { return false }\n      else { line[prop] += \" \" + cls; }\n      return true\n    })\n  }),\n  removeLineClass: docMethodOp(function(handle, where, cls) {\n    return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n      var prop = where == \"text\" ? \"textClass\"\n               : where == \"background\" ? \"bgClass\"\n               : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n      var cur = line[prop];\n      if (!cur) { return false }\n      else if (cls == null) { line[prop] = null; }\n      else {\n        var found = cur.match(classTest(cls));\n        if (!found) { return false }\n        var end = found.index + found[0].length;\n        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n      }\n      return true\n    })\n  }),\n\n  addLineWidget: docMethodOp(function(handle, node, options) {\n    return addLineWidget(this, handle, node, options)\n  }),\n  removeLineWidget: function(widget) { widget.clear(); },\n\n  markText: function(from, to, options) {\n    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\")\n  },\n  setBookmark: function(pos, options) {\n    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                    insertLeft: options && options.insertLeft,\n                    clearWhenEmpty: false, shared: options && options.shared,\n                    handleMouseEvents: options && options.handleMouseEvents};\n    pos = clipPos(this, pos);\n    return markText(this, pos, pos, realOpts, \"bookmark\")\n  },\n  findMarksAt: function(pos) {\n    pos = clipPos(this, pos);\n    var markers = [], spans = getLine(this, pos.line).markedSpans;\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if ((span.from == null || span.from <= pos.ch) &&\n          (span.to == null || span.to >= pos.ch))\n        { markers.push(span.marker.parent || span.marker); }\n    } }\n    return markers\n  },\n  findMarks: function(from, to, filter) {\n    from = clipPos(this, from); to = clipPos(this, to);\n    var found = [], lineNo$$1 = from.line;\n    this.iter(from.line, to.line + 1, function (line) {\n      var spans = line.markedSpans;\n      if (spans) { for (var i = 0; i < spans.length; i++) {\n        var span = spans[i];\n        if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||\n              span.from == null && lineNo$$1 != from.line ||\n              span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&\n            (!filter || filter(span.marker)))\n          { found.push(span.marker.parent || span.marker); }\n      } }\n      ++lineNo$$1;\n    });\n    return found\n  },\n  getAllMarks: function() {\n    var markers = [];\n    this.iter(function (line) {\n      var sps = line.markedSpans;\n      if (sps) { for (var i = 0; i < sps.length; ++i)\n        { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\n    });\n    return markers\n  },\n\n  posFromIndex: function(off) {\n    var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;\n    this.iter(function (line) {\n      var sz = line.text.length + sepSize;\n      if (sz > off) { ch = off; return true }\n      off -= sz;\n      ++lineNo$$1;\n    });\n    return clipPos(this, Pos(lineNo$$1, ch))\n  },\n  indexFromPos: function (coords) {\n    coords = clipPos(this, coords);\n    var index = coords.ch;\n    if (coords.line < this.first || coords.ch < 0) { return 0 }\n    var sepSize = this.lineSeparator().length;\n    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\n      index += line.text.length + sepSize;\n    });\n    return index\n  },\n\n  copy: function(copyHistory) {\n    var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                      this.modeOption, this.first, this.lineSep, this.direction);\n    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n    doc.sel = this.sel;\n    doc.extend = false;\n    if (copyHistory) {\n      doc.history.undoDepth = this.history.undoDepth;\n      doc.setHistory(this.getHistory());\n    }\n    return doc\n  },\n\n  linkedDoc: function(options) {\n    if (!options) { options = {}; }\n    var from = this.first, to = this.first + this.size;\n    if (options.from != null && options.from > from) { from = options.from; }\n    if (options.to != null && options.to < to) { to = options.to; }\n    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n    if (options.sharedHist) { copy.history = this.history\n    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n    copySharedMarkers(copy, findSharedMarkers(this));\n    return copy\n  },\n  unlinkDoc: function(other) {\n    var this$1 = this;\n\n    if (other instanceof CodeMirror$1) { other = other.doc; }\n    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\n      var link = this$1.linked[i];\n      if (link.doc != other) { continue }\n      this$1.linked.splice(i, 1);\n      other.unlinkDoc(this$1);\n      detachSharedMarkers(findSharedMarkers(this$1));\n      break\n    } }\n    // If the histories were shared, split them again\n    if (other.history == this.history) {\n      var splitIds = [other.id];\n      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\n      other.history = new History(null);\n      other.history.done = copyHistoryArray(this.history.done, splitIds);\n      other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n    }\n  },\n  iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n  getMode: function() {return this.mode},\n  getEditor: function() {return this.cm},\n\n  splitLines: function(str) {\n    if (this.lineSep) { return str.split(this.lineSep) }\n    return splitLinesAuto(str)\n  },\n  lineSeparator: function() { return this.lineSep || \"\\n\" },\n\n  setDirection: docMethodOp(function (dir) {\n    if (dir != \"rtl\") { dir = \"ltr\"; }\n    if (dir == this.direction) { return }\n    this.direction = dir;\n    this.iter(function (line) { return line.order = null; });\n    if (this.cm) { directionChanged(this.cm); }\n  })\n});\n\n// Public alias.\nDoc.prototype.eachLine = Doc.prototype.iter;\n\n// Kludge to work around strange IE behavior where it'll sometimes\n// re-fire a series of drag-related events right after the drop (#1551)\nvar lastDrop = 0;\n\nfunction onDrop(e) {\n  var cm = this;\n  clearDragCursor(cm);\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n    { return }\n  e_preventDefault(e);\n  if (ie) { lastDrop = +new Date; }\n  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n  if (!pos || cm.isReadOnly()) { return }\n  // Might be a file drop, in which case we simply extract the text\n  // and insert it.\n  if (files && files.length && window.FileReader && window.File) {\n    var n = files.length, text = Array(n), read = 0;\n    var loadFile = function (file, i) {\n      if (cm.options.allowDropFileTypes &&\n          indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n        { return }\n\n      var reader = new FileReader;\n      reader.onload = operation(cm, function () {\n        var content = reader.result;\n        if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) { content = \"\"; }\n        text[i] = content;\n        if (++read == n) {\n          pos = clipPos(cm.doc, pos);\n          var change = {from: pos, to: pos,\n                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n                        origin: \"paste\"};\n          makeChange(cm.doc, change);\n          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n        }\n      });\n      reader.readAsText(file);\n    };\n    for (var i = 0; i < n; ++i) { loadFile(files[i], i); }\n  } else { // Normal drop\n    // Don't do a replace if the drop happened inside of the selected text.\n    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n      cm.state.draggingText(e);\n      // Ensure the editor is re-focused\n      setTimeout(function () { return cm.display.input.focus(); }, 20);\n      return\n    }\n    try {\n      var text$1 = e.dataTransfer.getData(\"Text\");\n      if (text$1) {\n        var selected;\n        if (cm.state.draggingText && !cm.state.draggingText.copy)\n          { selected = cm.listSelections(); }\n        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\n          { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\n        cm.replaceSelection(text$1, \"around\", \"paste\");\n        cm.display.input.focus();\n      }\n    }\n    catch(e){}\n  }\n}\n\nfunction onDragStart(cm, e) {\n  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\n\n  e.dataTransfer.setData(\"Text\", cm.getSelection());\n  e.dataTransfer.effectAllowed = \"copyMove\";\n\n  // Use dummy image instead of default browsers image.\n  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n  if (e.dataTransfer.setDragImage && !safari) {\n    var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n    img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    if (presto) {\n      img.width = img.height = 1;\n      cm.display.wrapper.appendChild(img);\n      // Force a relayout, or Opera won't use our image for some obscure reason\n      img._top = img.offsetTop;\n    }\n    e.dataTransfer.setDragImage(img, 0, 0);\n    if (presto) { img.parentNode.removeChild(img); }\n  }\n}\n\nfunction onDragOver(cm, e) {\n  var pos = posFromMouse(cm, e);\n  if (!pos) { return }\n  var frag = document.createDocumentFragment();\n  drawSelectionCursor(cm, pos, frag);\n  if (!cm.display.dragCursor) {\n    cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n  }\n  removeChildrenAndAdd(cm.display.dragCursor, frag);\n}\n\nfunction clearDragCursor(cm) {\n  if (cm.display.dragCursor) {\n    cm.display.lineSpace.removeChild(cm.display.dragCursor);\n    cm.display.dragCursor = null;\n  }\n}\n\n// These must be handled carefully, because naively registering a\n// handler for each editor will cause the editors to never be\n// garbage collected.\n\nfunction forEachCodeMirror(f) {\n  if (!document.getElementsByClassName) { return }\n  var byClass = document.getElementsByClassName(\"CodeMirror\");\n  for (var i = 0; i < byClass.length; i++) {\n    var cm = byClass[i].CodeMirror;\n    if (cm) { f(cm); }\n  }\n}\n\nvar globalsRegistered = false;\nfunction ensureGlobalHandlers() {\n  if (globalsRegistered) { return }\n  registerGlobalHandlers();\n  globalsRegistered = true;\n}\nfunction registerGlobalHandlers() {\n  // When the window resizes, we need to refresh active editors.\n  var resizeTimer;\n  on(window, \"resize\", function () {\n    if (resizeTimer == null) { resizeTimer = setTimeout(function () {\n      resizeTimer = null;\n      forEachCodeMirror(onResize);\n    }, 100); }\n  });\n  // When the window loses focus, we want to show the editor as blurred\n  on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\n}\n// Called when the window resizes\nfunction onResize(cm) {\n  var d = cm.display;\n  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\n    { return }\n  // Might be a text scaling operation, clear size caches.\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n  d.scrollbarsClipped = false;\n  cm.setSize();\n}\n\nvar keyNames = {\n  3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n  19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n  36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n  46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n  106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\n  173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n  221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n  63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n};\n\n// Number keys\nfor (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\n// Alphabetic keys\nfor (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\n// Function keys\nfor (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\n\nvar keyMap = {};\n\nkeyMap.basic = {\n  \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n  \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n  \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n  \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n  \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n  \"Esc\": \"singleSelection\"\n};\n// Note that the save and find-related commands aren't defined by\n// default. User code or addons can define them. Unknown commands\n// are simply ignored.\nkeyMap.pcDefault = {\n  \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n  \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n  \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n  \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n  \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n  \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n  \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n  fallthrough: \"basic\"\n};\n// Very basic readline/emacs-style bindings, which are standard on Mac.\nkeyMap.emacsy = {\n  \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n  \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n  \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n  \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\n  \"Ctrl-O\": \"openLine\"\n};\nkeyMap.macDefault = {\n  \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n  \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n  \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n  \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n  \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n  \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n  \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n  fallthrough: [\"basic\", \"emacsy\"]\n};\nkeyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n// KEYMAP DISPATCH\n\nfunction normalizeKeyName(name) {\n  var parts = name.split(/-(?!$)/);\n  name = parts[parts.length - 1];\n  var alt, ctrl, shift, cmd;\n  for (var i = 0; i < parts.length - 1; i++) {\n    var mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\n    else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n    else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n    else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n  }\n  if (alt) { name = \"Alt-\" + name; }\n  if (ctrl) { name = \"Ctrl-\" + name; }\n  if (cmd) { name = \"Cmd-\" + name; }\n  if (shift) { name = \"Shift-\" + name; }\n  return name\n}\n\n// This is a kludge to keep keymaps mostly working as raw objects\n// (backwards compatibility) while at the same time support features\n// like normalization and multi-stroke key bindings. It compiles a\n// new normalized keymap, and then updates the old object to reflect\n// this.\nfunction normalizeKeyMap(keymap) {\n  var copy = {};\n  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\n    var value = keymap[keyname];\n    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\n    if (value == \"...\") { delete keymap[keyname]; continue }\n\n    var keys = map(keyname.split(\" \"), normalizeKeyName);\n    for (var i = 0; i < keys.length; i++) {\n      var val = (void 0), name = (void 0);\n      if (i == keys.length - 1) {\n        name = keys.join(\" \");\n        val = value;\n      } else {\n        name = keys.slice(0, i + 1).join(\" \");\n        val = \"...\";\n      }\n      var prev = copy[name];\n      if (!prev) { copy[name] = val; }\n      else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\n    }\n    delete keymap[keyname];\n  } }\n  for (var prop in copy) { keymap[prop] = copy[prop]; }\n  return keymap\n}\n\nfunction lookupKey(key, map$$1, handle, context) {\n  map$$1 = getKeyMap(map$$1);\n  var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];\n  if (found === false) { return \"nothing\" }\n  if (found === \"...\") { return \"multi\" }\n  if (found != null && handle(found)) { return \"handled\" }\n\n  if (map$$1.fallthrough) {\n    if (Object.prototype.toString.call(map$$1.fallthrough) != \"[object Array]\")\n      { return lookupKey(key, map$$1.fallthrough, handle, context) }\n    for (var i = 0; i < map$$1.fallthrough.length; i++) {\n      var result = lookupKey(key, map$$1.fallthrough[i], handle, context);\n      if (result) { return result }\n    }\n  }\n}\n\n// Modifier key presses don't count as 'real' key presses for the\n// purpose of keymap fallthrough.\nfunction isModifierKey(value) {\n  var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n  return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\n}\n\nfunction addModifierNames(name, event, noShift) {\n  var base = name;\n  if (event.altKey && base != \"Alt\") { name = \"Alt-\" + name; }\n  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") { name = \"Ctrl-\" + name; }\n  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") { name = \"Cmd-\" + name; }\n  if (!noShift && event.shiftKey && base != \"Shift\") { name = \"Shift-\" + name; }\n  return name\n}\n\n// Look up the name of a key as indicated by an event object.\nfunction keyName(event, noShift) {\n  if (presto && event.keyCode == 34 && event[\"char\"]) { return false }\n  var name = keyNames[event.keyCode];\n  if (name == null || event.altGraphKey) { return false }\n  return addModifierNames(name, event, noShift)\n}\n\nfunction getKeyMap(val) {\n  return typeof val == \"string\" ? keyMap[val] : val\n}\n\n// Helper for deleting text near the selection(s), used to implement\n// backspace, delete, and similar functionality.\nfunction deleteNearSelection(cm, compute) {\n  var ranges = cm.doc.sel.ranges, kill = [];\n  // Build up a set of ranges to kill first, merging overlapping\n  // ranges.\n  for (var i = 0; i < ranges.length; i++) {\n    var toKill = compute(ranges[i]);\n    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n      var replaced = kill.pop();\n      if (cmp(replaced.from, toKill.from) < 0) {\n        toKill.from = replaced.from;\n        break\n      }\n    }\n    kill.push(toKill);\n  }\n  // Next, remove those actual ranges.\n  runInOp(cm, function () {\n    for (var i = kill.length - 1; i >= 0; i--)\n      { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\n    ensureCursorVisible(cm);\n  });\n}\n\n// Commands are parameter-less actions that can be performed on an\n// editor, mostly used for keybindings.\nvar commands = {\n  selectAll: selectAll,\n  singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\n  killLine: function (cm) { return deleteNearSelection(cm, function (range) {\n    if (range.empty()) {\n      var len = getLine(cm.doc, range.head.line).text.length;\n      if (range.head.ch == len && range.head.line < cm.lastLine())\n        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\n      else\n        { return {from: range.head, to: Pos(range.head.line, len)} }\n    } else {\n      return {from: range.from(), to: range.to()}\n    }\n  }); },\n  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n    from: Pos(range.from().line, 0),\n    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n  }); }); },\n  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n    from: Pos(range.from().line, 0), to: range.from()\n  }); }); },\n  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n    return {from: leftPos, to: range.from()}\n  }); },\n  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n    return {from: range.from(), to: rightPos }\n  }); },\n  undo: function (cm) { return cm.undo(); },\n  redo: function (cm) { return cm.redo(); },\n  undoSelection: function (cm) { return cm.undoSelection(); },\n  redoSelection: function (cm) { return cm.redoSelection(); },\n  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\n  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\n  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\n    {origin: \"+move\", bias: 1}\n  ); },\n  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\n    {origin: \"+move\", bias: 1}\n  ); },\n  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\n    {origin: \"+move\", bias: -1}\n  ); },\n  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.cursorCoords(range.head, \"div\").top + 5;\n    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\n  }, sel_move); },\n  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.cursorCoords(range.head, \"div\").top + 5;\n    return cm.coordsChar({left: 0, top: top}, \"div\")\n  }, sel_move); },\n  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.cursorCoords(range.head, \"div\").top + 5;\n    var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n    if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\n    return pos\n  }, sel_move); },\n  goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\n  goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\n  goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\n  goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\n  goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\n  goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\n  goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\n  goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\n  goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\n  goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\n  goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\n  goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\n  delCharBefore: function (cm) { return cm.deleteH(-1, \"char\"); },\n  delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\n  delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\n  delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\n  delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\n  delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\n  indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\n  indentMore: function (cm) { return cm.indentSelection(\"add\"); },\n  indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\n  insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\n  insertSoftTab: function (cm) {\n    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n    for (var i = 0; i < ranges.length; i++) {\n      var pos = ranges[i].from();\n      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n      spaces.push(spaceStr(tabSize - col % tabSize));\n    }\n    cm.replaceSelections(spaces);\n  },\n  defaultTab: function (cm) {\n    if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\n    else { cm.execCommand(\"insertTab\"); }\n  },\n  // Swap the two chars left and right of each selection's head.\n  // Move cursor behind the two swapped characters afterwards.\n  //\n  // Doesn't consider line feeds a character.\n  // Doesn't scan more than one line above to find a character.\n  // Doesn't do anything on an empty line.\n  // Doesn't do anything with non-empty selections.\n  transposeChars: function (cm) { return runInOp(cm, function () {\n    var ranges = cm.listSelections(), newSel = [];\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) { continue }\n      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n      if (line) {\n        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\n        if (cur.ch > 0) {\n          cur = new Pos(cur.line, cur.ch + 1);\n          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                          Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n        } else if (cur.line > cm.doc.first) {\n          var prev = getLine(cm.doc, cur.line - 1).text;\n          if (prev) {\n            cur = new Pos(cur.line, 1);\n            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                            prev.charAt(prev.length - 1),\n                            Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n          }\n        }\n      }\n      newSel.push(new Range(cur, cur));\n    }\n    cm.setSelections(newSel);\n  }); },\n  newlineAndIndent: function (cm) { return runInOp(cm, function () {\n    var sels = cm.listSelections();\n    for (var i = sels.length - 1; i >= 0; i--)\n      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\n    sels = cm.listSelections();\n    for (var i$1 = 0; i$1 < sels.length; i$1++)\n      { cm.indentLine(sels[i$1].from().line, null, true); }\n    ensureCursorVisible(cm);\n  }); },\n  openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\n  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\n};\n\n\nfunction lineStart(cm, lineN) {\n  var line = getLine(cm.doc, lineN);\n  var visual = visualLine(line);\n  if (visual != line) { lineN = lineNo(visual); }\n  return endOfLine(true, cm, visual, lineN, 1)\n}\nfunction lineEnd(cm, lineN) {\n  var line = getLine(cm.doc, lineN);\n  var visual = visualLineEnd(line);\n  if (visual != line) { lineN = lineNo(visual); }\n  return endOfLine(true, cm, line, lineN, -1)\n}\nfunction lineStartSmart(cm, pos) {\n  var start = lineStart(cm, pos.line);\n  var line = getLine(cm.doc, start.line);\n  var order = getOrder(line, cm.doc.direction);\n  if (!order || order[0].level == 0) {\n    var firstNonWS = Math.max(0, line.text.search(/\\S/));\n    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\n  }\n  return start\n}\n\n// Run a handler that was bound to a key.\nfunction doHandleBinding(cm, bound, dropShift) {\n  if (typeof bound == \"string\") {\n    bound = commands[bound];\n    if (!bound) { return false }\n  }\n  // Ensure previous input has been read, so that the handler sees a\n  // consistent view of the document\n  cm.display.input.ensurePolled();\n  var prevShift = cm.display.shift, done = false;\n  try {\n    if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n    if (dropShift) { cm.display.shift = false; }\n    done = bound(cm) != Pass;\n  } finally {\n    cm.display.shift = prevShift;\n    cm.state.suppressEdits = false;\n  }\n  return done\n}\n\nfunction lookupKeyForEditor(cm, name, handle) {\n  for (var i = 0; i < cm.state.keyMaps.length; i++) {\n    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n    if (result) { return result }\n  }\n  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n    || lookupKey(name, cm.options.keyMap, handle, cm)\n}\n\n// Note that, despite the name, this function is also used to check\n// for bound mouse clicks.\n\nvar stopSeq = new Delayed;\nfunction dispatchKey(cm, name, e, handle) {\n  var seq = cm.state.keySeq;\n  if (seq) {\n    if (isModifierKey(name)) { return \"handled\" }\n    stopSeq.set(50, function () {\n      if (cm.state.keySeq == seq) {\n        cm.state.keySeq = null;\n        cm.display.input.reset();\n      }\n    });\n    name = seq + \" \" + name;\n  }\n  var result = lookupKeyForEditor(cm, name, handle);\n\n  if (result == \"multi\")\n    { cm.state.keySeq = name; }\n  if (result == \"handled\")\n    { signalLater(cm, \"keyHandled\", cm, name, e); }\n\n  if (result == \"handled\" || result == \"multi\") {\n    e_preventDefault(e);\n    restartBlink(cm);\n  }\n\n  if (seq && !result && /\\'$/.test(name)) {\n    e_preventDefault(e);\n    return true\n  }\n  return !!result\n}\n\n// Handle a key from the keydown event.\nfunction handleKeyBinding(cm, e) {\n  var name = keyName(e, true);\n  if (!name) { return false }\n\n  if (e.shiftKey && !cm.state.keySeq) {\n    // First try to resolve full name (including 'Shift-'). Failing\n    // that, see if there is a cursor-motion command (starting with\n    // 'go') bound to the keyname without 'Shift-'.\n    return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\n        || dispatchKey(cm, name, e, function (b) {\n             if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n               { return doHandleBinding(cm, b) }\n           })\n  } else {\n    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\n  }\n}\n\n// Handle a key from the keypress event\nfunction handleCharBinding(cm, e, ch) {\n  return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\n}\n\nvar lastStoppedKey = null;\nfunction onKeyDown(e) {\n  var cm = this;\n  cm.curOp.focus = activeElt();\n  if (signalDOMEvent(cm, e)) { return }\n  // IE does strange things with escape.\n  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\n  var code = e.keyCode;\n  cm.display.shift = code == 16 || e.shiftKey;\n  var handled = handleKeyBinding(cm, e);\n  if (presto) {\n    lastStoppedKey = handled ? code : null;\n    // Opera has no cut event... we try to at least catch the key combo\n    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n      { cm.replaceSelection(\"\", null, \"cut\"); }\n  }\n\n  // Turn mouse into crosshair when Alt is held on Mac.\n  if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n    { showCrossHair(cm); }\n}\n\nfunction showCrossHair(cm) {\n  var lineDiv = cm.display.lineDiv;\n  addClass(lineDiv, \"CodeMirror-crosshair\");\n\n  function up(e) {\n    if (e.keyCode == 18 || !e.altKey) {\n      rmClass(lineDiv, \"CodeMirror-crosshair\");\n      off(document, \"keyup\", up);\n      off(document, \"mouseover\", up);\n    }\n  }\n  on(document, \"keyup\", up);\n  on(document, \"mouseover\", up);\n}\n\nfunction onKeyUp(e) {\n  if (e.keyCode == 16) { this.doc.sel.shift = false; }\n  signalDOMEvent(this, e);\n}\n\nfunction onKeyPress(e) {\n  var cm = this;\n  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\n  var keyCode = e.keyCode, charCode = e.charCode;\n  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\n  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\n  var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n  // Some browsers fire keypress events for backspace\n  if (ch == \"\\x08\") { return }\n  if (handleCharBinding(cm, e, ch)) { return }\n  cm.display.input.onKeyPress(e);\n}\n\nvar DOUBLECLICK_DELAY = 400;\n\nvar PastClick = function(time, pos, button) {\n  this.time = time;\n  this.pos = pos;\n  this.button = button;\n};\n\nPastClick.prototype.compare = function (time, pos, button) {\n  return this.time + DOUBLECLICK_DELAY > time &&\n    cmp(pos, this.pos) == 0 && button == this.button\n};\n\nvar lastClick;\nvar lastDoubleClick;\nfunction clickRepeat(pos, button) {\n  var now = +new Date;\n  if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n    lastClick = lastDoubleClick = null;\n    return \"triple\"\n  } else if (lastClick && lastClick.compare(now, pos, button)) {\n    lastDoubleClick = new PastClick(now, pos, button);\n    lastClick = null;\n    return \"double\"\n  } else {\n    lastClick = new PastClick(now, pos, button);\n    lastDoubleClick = null;\n    return \"single\"\n  }\n}\n\n// A mouse down can be a single click, double click, triple click,\n// start of selection drag, start of text drag, new cursor\n// (ctrl-click), rectangle drag (alt-drag), or xwin\n// middle-click-paste. Or it might be a click on something we should\n// not interfere with, such as a scrollbar or widget.\nfunction onMouseDown(e) {\n  var cm = this, display = cm.display;\n  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\n  display.input.ensurePolled();\n  display.shift = e.shiftKey;\n\n  if (eventInWidget(display, e)) {\n    if (!webkit) {\n      // Briefly turn off draggability, to allow widgets to do\n      // normal dragging things.\n      display.scroller.draggable = false;\n      setTimeout(function () { return display.scroller.draggable = true; }, 100);\n    }\n    return\n  }\n  if (clickInGutter(cm, e)) { return }\n  var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : \"single\";\n  window.focus();\n\n  // #3261: make sure, that we're not starting a second selection\n  if (button == 1 && cm.state.selectingText)\n    { cm.state.selectingText(e); }\n\n  if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }\n\n  if (button == 1) {\n    if (pos) { leftButtonDown(cm, pos, repeat, e); }\n    else if (e_target(e) == display.scroller) { e_preventDefault(e); }\n  } else if (button == 2) {\n    if (pos) { extendSelection(cm.doc, pos); }\n    setTimeout(function () { return display.input.focus(); }, 20);\n  } else if (button == 3) {\n    if (captureRightClick) { onContextMenu(cm, e); }\n    else { delayBlurEvent(cm); }\n  }\n}\n\nfunction handleMappedButton(cm, button, pos, repeat, event) {\n  var name = \"Click\";\n  if (repeat == \"double\") { name = \"Double\" + name; }\n  else if (repeat == \"triple\") { name = \"Triple\" + name; }\n  name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\n\n  return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {\n    if (typeof bound == \"string\") { bound = commands[bound]; }\n    if (!bound) { return false }\n    var done = false;\n    try {\n      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n      done = bound(cm, pos) != Pass;\n    } finally {\n      cm.state.suppressEdits = false;\n    }\n    return done\n  })\n}\n\nfunction configureMouse(cm, repeat, event) {\n  var option = cm.getOption(\"configureMouse\");\n  var value = option ? option(cm, repeat, event) : {};\n  if (value.unit == null) {\n    var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n    value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n  }\n  if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }\n  if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }\n  if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }\n  return value\n}\n\nfunction leftButtonDown(cm, pos, repeat, event) {\n  if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\n  else { cm.curOp.focus = activeElt(); }\n\n  var behavior = configureMouse(cm, repeat, event);\n\n  var sel = cm.doc.sel, contained;\n  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n      repeat == \"single\" && (contained = sel.contains(pos)) > -1 &&\n      (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&\n      (cmp(contained.to(), pos) > 0 || pos.xRel < 0))\n    { leftButtonStartDrag(cm, event, pos, behavior); }\n  else\n    { leftButtonSelect(cm, event, pos, behavior); }\n}\n\n// Start a text drag. When it ends, see if any dragging actually\n// happen, and treat as a click if it didn't.\nfunction leftButtonStartDrag(cm, event, pos, behavior) {\n  var display = cm.display, moved = false;\n  var dragEnd = operation(cm, function (e) {\n    if (webkit) { display.scroller.draggable = false; }\n    cm.state.draggingText = false;\n    off(document, \"mouseup\", dragEnd);\n    off(document, \"mousemove\", mouseMove);\n    off(display.scroller, \"dragstart\", dragStart);\n    off(display.scroller, \"drop\", dragEnd);\n    if (!moved) {\n      e_preventDefault(e);\n      if (!behavior.addNew)\n        { extendSelection(cm.doc, pos, null, null, behavior.extend); }\n      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n      if (webkit || ie && ie_version == 9)\n        { setTimeout(function () {document.body.focus(); display.input.focus();}, 20); }\n      else\n        { display.input.focus(); }\n    }\n  });\n  var mouseMove = function(e2) {\n    moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n  };\n  var dragStart = function () { return moved = true; };\n  // Let the drag handler handle this.\n  if (webkit) { display.scroller.draggable = true; }\n  cm.state.draggingText = dragEnd;\n  dragEnd.copy = !behavior.moveOnDrag;\n  // IE's approach to draggable\n  if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\n  on(document, \"mouseup\", dragEnd);\n  on(document, \"mousemove\", mouseMove);\n  on(display.scroller, \"dragstart\", dragStart);\n  on(display.scroller, \"drop\", dragEnd);\n\n  delayBlurEvent(cm);\n  setTimeout(function () { return display.input.focus(); }, 20);\n}\n\nfunction rangeForUnit(cm, pos, unit) {\n  if (unit == \"char\") { return new Range(pos, pos) }\n  if (unit == \"word\") { return cm.findWordAt(pos) }\n  if (unit == \"line\") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\n  var result = unit(cm, pos);\n  return new Range(result.from, result.to)\n}\n\n// Normal selection, as opposed to text dragging.\nfunction leftButtonSelect(cm, event, start, behavior) {\n  var display = cm.display, doc = cm.doc;\n  e_preventDefault(event);\n\n  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n  if (behavior.addNew && !behavior.extend) {\n    ourIndex = doc.sel.contains(start);\n    if (ourIndex > -1)\n      { ourRange = ranges[ourIndex]; }\n    else\n      { ourRange = new Range(start, start); }\n  } else {\n    ourRange = doc.sel.primary();\n    ourIndex = doc.sel.primIndex;\n  }\n\n  if (behavior.unit == \"rectangle\") {\n    if (!behavior.addNew) { ourRange = new Range(start, start); }\n    start = posFromMouse(cm, event, true, true);\n    ourIndex = -1;\n  } else {\n    var range$$1 = rangeForUnit(cm, start, behavior.unit);\n    if (behavior.extend)\n      { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }\n    else\n      { ourRange = range$$1; }\n  }\n\n  if (!behavior.addNew) {\n    ourIndex = 0;\n    setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n    startSel = doc.sel;\n  } else if (ourIndex == -1) {\n    ourIndex = ranges.length;\n    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\n                 {scroll: false, origin: \"*mouse\"});\n  } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\n    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                 {scroll: false, origin: \"*mouse\"});\n    startSel = doc.sel;\n  } else {\n    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n  }\n\n  var lastPos = start;\n  function extendTo(pos) {\n    if (cmp(lastPos, pos) == 0) { return }\n    lastPos = pos;\n\n    if (behavior.unit == \"rectangle\") {\n      var ranges = [], tabSize = cm.options.tabSize;\n      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n           line <= end; line++) {\n        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n        if (left == right)\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\n        else if (text.length > leftPos)\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\n      }\n      if (!ranges.length) { ranges.push(new Range(start, start)); }\n      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                   {origin: \"*mouse\", scroll: false});\n      cm.scrollIntoView(pos);\n    } else {\n      var oldRange = ourRange;\n      var range$$1 = rangeForUnit(cm, pos, behavior.unit);\n      var anchor = oldRange.anchor, head;\n      if (cmp(range$$1.anchor, anchor) > 0) {\n        head = range$$1.head;\n        anchor = minPos(oldRange.from(), range$$1.anchor);\n      } else {\n        head = range$$1.anchor;\n        anchor = maxPos(oldRange.to(), range$$1.head);\n      }\n      var ranges$1 = startSel.ranges.slice(0);\n      ranges$1[ourIndex] = new Range(clipPos(doc, anchor), head);\n      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);\n    }\n  }\n\n  var editorSize = display.wrapper.getBoundingClientRect();\n  // Used to ensure timeout re-tries don't fire when another extend\n  // happened in the meantime (clearTimeout isn't reliable -- at\n  // least on Chrome, the timeouts still happen even when cleared,\n  // if the clear happens after their scheduled firing time).\n  var counter = 0;\n\n  function extend(e) {\n    var curCount = ++counter;\n    var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n    if (!cur) { return }\n    if (cmp(cur, lastPos) != 0) {\n      cm.curOp.focus = activeElt();\n      extendTo(cur);\n      var visible = visibleLines(display, doc);\n      if (cur.line >= visible.to || cur.line < visible.from)\n        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\n    } else {\n      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n      if (outside) { setTimeout(operation(cm, function () {\n        if (counter != curCount) { return }\n        display.scroller.scrollTop += outside;\n        extend(e);\n      }), 50); }\n    }\n  }\n\n  function done(e) {\n    cm.state.selectingText = false;\n    counter = Infinity;\n    e_preventDefault(e);\n    display.input.focus();\n    off(document, \"mousemove\", move);\n    off(document, \"mouseup\", up);\n    doc.history.lastSelOrigin = null;\n  }\n\n  var move = operation(cm, function (e) {\n    if (!e_button(e)) { done(e); }\n    else { extend(e); }\n  });\n  var up = operation(cm, done);\n  cm.state.selectingText = up;\n  on(document, \"mousemove\", move);\n  on(document, \"mouseup\", up);\n}\n\n\n// Determines whether an event happened in the gutter, and fires the\n// handlers for the corresponding event.\nfunction gutterEvent(cm, e, type, prevent) {\n  var mX, mY;\n  try { mX = e.clientX; mY = e.clientY; }\n  catch(e) { return false }\n  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\n  if (prevent) { e_preventDefault(e); }\n\n  var display = cm.display;\n  var lineBox = display.lineDiv.getBoundingClientRect();\n\n  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\n  mY -= lineBox.top - display.viewOffset;\n\n  for (var i = 0; i < cm.options.gutters.length; ++i) {\n    var g = display.gutters.childNodes[i];\n    if (g && g.getBoundingClientRect().right >= mX) {\n      var line = lineAtHeight(cm.doc, mY);\n      var gutter = cm.options.gutters[i];\n      signal(cm, type, cm, line, gutter, e);\n      return e_defaultPrevented(e)\n    }\n  }\n}\n\nfunction clickInGutter(cm, e) {\n  return gutterEvent(cm, e, \"gutterClick\", true)\n}\n\n// CONTEXT MENU HANDLING\n\n// To make the context menu work, we need to briefly unhide the\n// textarea (making it as unobtrusive as possible) to let the\n// right-click take effect on it.\nfunction onContextMenu(cm, e) {\n  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\n  if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\n  cm.display.input.onContextMenu(e);\n}\n\nfunction contextMenuInGutter(cm, e) {\n  if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\n  return gutterEvent(cm, e, \"gutterContextMenu\", false)\n}\n\nfunction themeChanged(cm) {\n  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n    cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n  clearCaches(cm);\n}\n\nvar Init = {toString: function(){return \"CodeMirror.Init\"}};\n\nvar defaults = {};\nvar optionHandlers = {};\n\nfunction defineOptions(CodeMirror) {\n  var optionHandlers = CodeMirror.optionHandlers;\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) { optionHandlers[name] =\n      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\n  }\n\n  CodeMirror.defineOption = option;\n\n  // Passed to option handlers when there is no old value.\n  CodeMirror.Init = Init;\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\n  option(\"mode\", null, function (cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option(\"indentUnit\", 2, loadMode, true);\n  option(\"indentWithTabs\", false);\n  option(\"smartIndent\", true);\n  option(\"tabSize\", 4, function (cm) {\n    resetModeState(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option(\"lineSeparator\", null, function (cm, val) {\n    cm.doc.lineSep = val;\n    if (!val) { return }\n    var newBreaks = [], lineNo = cm.doc.first;\n    cm.doc.iter(function (line) {\n      for (var pos = 0;;) {\n        var found = line.text.indexOf(val, pos);\n        if (found == -1) { break }\n        pos = found + val.length;\n        newBreaks.push(Pos(lineNo, found));\n      }\n      lineNo++;\n    });\n    for (var i = newBreaks.length - 1; i >= 0; i--)\n      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\n  });\n  option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function (cm, val, old) {\n    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n    if (old != Init) { cm.refresh(); }\n  });\n  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\n  option(\"electricChars\", true);\n  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n    throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\n  }, true);\n  option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\n  option(\"rtlMoveVisually\", !windows);\n  option(\"wholeLineUpdateBefore\", true);\n\n  option(\"theme\", \"default\", function (cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option(\"keyMap\", \"default\", function (cm, val, old) {\n    var next = getKeyMap(val);\n    var prev = old != Init && getKeyMap(old);\n    if (prev && prev.detach) { prev.detach(cm, next); }\n    if (next.attach) { next.attach(cm, prev || null); }\n  });\n  option(\"extraKeys\", null);\n  option(\"configureMouse\", null);\n\n  option(\"lineWrapping\", false, wrappingChanged, true);\n  option(\"gutters\", [], function (cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"fixedGutter\", true, function (cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n    cm.refresh();\n  }, true);\n  option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\n  option(\"scrollbarStyle\", \"native\", function (cm) {\n    initScrollbars(cm);\n    updateScrollbars(cm);\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n  }, true);\n  option(\"lineNumbers\", false, function (cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"firstLineNumber\", 1, guttersChanged, true);\n  option(\"lineNumberFormatter\", function (integer) { return integer; }, guttersChanged, true);\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n  option(\"resetSelectionOnContextMenu\", true);\n  option(\"lineWiseCopyCut\", true);\n  option(\"pasteLinesPerSelection\", true);\n\n  option(\"readOnly\", false, function (cm, val) {\n    if (val == \"nocursor\") {\n      onBlur(cm);\n      cm.display.input.blur();\n    }\n    cm.display.input.readOnlyChanged(val);\n  });\n  option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\n  option(\"dragDrop\", true, dragDropChanged);\n  option(\"allowDropFileTypes\", null);\n\n  option(\"cursorBlinkRate\", 530);\n  option(\"cursorScrollMargin\", 0);\n  option(\"cursorHeight\", 1, updateSelection, true);\n  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n  option(\"workTime\", 100);\n  option(\"workDelay\", 100);\n  option(\"flattenSpans\", true, resetModeState, true);\n  option(\"addModeClass\", false, resetModeState, true);\n  option(\"pollInterval\", 100);\n  option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\n  option(\"historyEventDelay\", 1250);\n  option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\n  option(\"maxHighlightLength\", 10000, resetModeState, true);\n  option(\"moveInputWithCursor\", true, function (cm, val) {\n    if (!val) { cm.display.input.resetPosition(); }\n  });\n\n  option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\n  option(\"autofocus\", null);\n  option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\n}\n\nfunction guttersChanged(cm) {\n  updateGutters(cm);\n  regChange(cm);\n  alignHorizontally(cm);\n}\n\nfunction dragDropChanged(cm, value, old) {\n  var wasOn = old && old != Init;\n  if (!value != !wasOn) {\n    var funcs = cm.display.dragFunctions;\n    var toggle = value ? on : off;\n    toggle(cm.display.scroller, \"dragstart\", funcs.start);\n    toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n    toggle(cm.display.scroller, \"dragover\", funcs.over);\n    toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n    toggle(cm.display.scroller, \"drop\", funcs.drop);\n  }\n}\n\nfunction wrappingChanged(cm) {\n  if (cm.options.lineWrapping) {\n    addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n    cm.display.sizer.style.minWidth = \"\";\n    cm.display.sizerWidth = null;\n  } else {\n    rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n    findMaxLine(cm);\n  }\n  estimateLineHeights(cm);\n  regChange(cm);\n  clearCaches(cm);\n  setTimeout(function () { return updateScrollbars(cm); }, 100);\n}\n\n// A CodeMirror instance represents an editor. This is the object\n// that user code is usually dealing with.\n\nfunction CodeMirror$1(place, options) {\n  var this$1 = this;\n\n  if (!(this instanceof CodeMirror$1)) { return new CodeMirror$1(place, options) }\n\n  this.options = options = options ? copyObj(options) : {};\n  // Determine effective options based on given values and defaults.\n  copyObj(defaults, options, false);\n  setGuttersForLineNumbers(options);\n\n  var doc = options.value;\n  if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\n  this.doc = doc;\n\n  var input = new CodeMirror$1.inputStyles[options.inputStyle](this);\n  var display = this.display = new Display(place, doc, input);\n  display.wrapper.CodeMirror = this;\n  updateGutters(this);\n  themeChanged(this);\n  if (options.lineWrapping)\n    { this.display.wrapper.className += \" CodeMirror-wrap\"; }\n  initScrollbars(this);\n\n  this.state = {\n    keyMaps: [],  // stores maps added by addKeyMap\n    overlays: [], // highlighting overlays, as added by addOverlay\n    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n    overwrite: false,\n    delayingBlurEvent: false,\n    focused: false,\n    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\n    selectingText: false,\n    draggingText: false,\n    highlight: new Delayed(), // stores highlight worker timeout\n    keySeq: null,  // Unfinished key sequence\n    specialChars: null\n  };\n\n  if (options.autofocus && !mobile) { display.input.focus(); }\n\n  // Override magic textarea content restore that IE sometimes does\n  // on our hidden textarea on reload\n  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\n\n  registerEventHandlers(this);\n  ensureGlobalHandlers();\n\n  startOperation(this);\n  this.curOp.forceUpdate = true;\n  attachDoc(this, doc);\n\n  if ((options.autofocus && !mobile) || this.hasFocus())\n    { setTimeout(bind(onFocus, this), 20); }\n  else\n    { onBlur(this); }\n\n  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\n    { optionHandlers[opt](this$1, options[opt], Init); } }\n  maybeUpdateLineNumberWidth(this);\n  if (options.finishInit) { options.finishInit(this); }\n  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }\n  endOperation(this);\n  // Suppress optimizelegibility in Webkit, since it breaks text\n  // measuring on line wrapping boundaries.\n  if (webkit && options.lineWrapping &&\n      getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n    { display.lineDiv.style.textRendering = \"auto\"; }\n}\n\n// The default configuration options.\nCodeMirror$1.defaults = defaults;\n// Functions to run when options are changed.\nCodeMirror$1.optionHandlers = optionHandlers;\n\n// Attach the necessary event handlers when initializing the editor\nfunction registerEventHandlers(cm) {\n  var d = cm.display;\n  on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n  // Older IE's will not fire a second mousedown for a double click\n  if (ie && ie_version < 11)\n    { on(d.scroller, \"dblclick\", operation(cm, function (e) {\n      if (signalDOMEvent(cm, e)) { return }\n      var pos = posFromMouse(cm, e);\n      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\n      e_preventDefault(e);\n      var word = cm.findWordAt(pos);\n      extendSelection(cm.doc, word.anchor, word.head);\n    })); }\n  else\n    { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\n  // Some browsers fire contextmenu *after* opening the menu, at\n  // which point we can't mess with it anymore. Context menu is\n  // handled in onMouseDown for these browsers.\n  if (!captureRightClick) { on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); }); }\n\n  // Used to suppress mouse event handling when a touch happens\n  var touchFinished, prevTouch = {end: 0};\n  function finishTouch() {\n    if (d.activeTouch) {\n      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\n      prevTouch = d.activeTouch;\n      prevTouch.end = +new Date;\n    }\n  }\n  function isMouseLikeTouchEvent(e) {\n    if (e.touches.length != 1) { return false }\n    var touch = e.touches[0];\n    return touch.radiusX <= 1 && touch.radiusY <= 1\n  }\n  function farAway(touch, other) {\n    if (other.left == null) { return true }\n    var dx = other.left - touch.left, dy = other.top - touch.top;\n    return dx * dx + dy * dy > 20 * 20\n  }\n  on(d.scroller, \"touchstart\", function (e) {\n    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {\n      d.input.ensurePolled();\n      clearTimeout(touchFinished);\n      var now = +new Date;\n      d.activeTouch = {start: now, moved: false,\n                       prev: now - prevTouch.end <= 300 ? prevTouch : null};\n      if (e.touches.length == 1) {\n        d.activeTouch.left = e.touches[0].pageX;\n        d.activeTouch.top = e.touches[0].pageY;\n      }\n    }\n  });\n  on(d.scroller, \"touchmove\", function () {\n    if (d.activeTouch) { d.activeTouch.moved = true; }\n  });\n  on(d.scroller, \"touchend\", function (e) {\n    var touch = d.activeTouch;\n    if (touch && !eventInWidget(d, e) && touch.left != null &&\n        !touch.moved && new Date - touch.start < 300) {\n      var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n      if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n        { range = new Range(pos, pos); }\n      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n        { range = cm.findWordAt(pos); }\n      else // Triple tap\n        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\n      cm.setSelection(range.anchor, range.head);\n      cm.focus();\n      e_preventDefault(e);\n    }\n    finishTouch();\n  });\n  on(d.scroller, \"touchcancel\", finishTouch);\n\n  // Sync scrolling between fake scrollbars and real scrollable\n  // area, ensure viewport is updated when scrolling.\n  on(d.scroller, \"scroll\", function () {\n    if (d.scroller.clientHeight) {\n      updateScrollTop(cm, d.scroller.scrollTop);\n      setScrollLeft(cm, d.scroller.scrollLeft, true);\n      signal(cm, \"scroll\", cm);\n    }\n  });\n\n  // Listen to wheel events in order to try and update the viewport on time.\n  on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\n  on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\n\n  // Prevent wrapper from ever scrolling\n  on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n  d.dragFunctions = {\n    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\n    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n    start: function (e) { return onDragStart(cm, e); },\n    drop: operation(cm, onDrop),\n    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n  };\n\n  var inp = d.input.getField();\n  on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\n  on(inp, \"keydown\", operation(cm, onKeyDown));\n  on(inp, \"keypress\", operation(cm, onKeyPress));\n  on(inp, \"focus\", function (e) { return onFocus(cm, e); });\n  on(inp, \"blur\", function (e) { return onBlur(cm, e); });\n}\n\nvar initHooks = [];\nCodeMirror$1.defineInitHook = function (f) { return initHooks.push(f); };\n\n// Indent the given line. The how parameter can be \"smart\",\n// \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n// (typically set to true for forced single-line indents), empty\n// lines are not indented, and places where the mode returns Pass\n// are left alone.\nfunction indentLine(cm, n, how, aggressive) {\n  var doc = cm.doc, state;\n  if (how == null) { how = \"add\"; }\n  if (how == \"smart\") {\n    // Fall back to \"prev\" when the mode doesn't have an indentation\n    // method.\n    if (!doc.mode.indent) { how = \"prev\"; }\n    else { state = getContextBefore(cm, n).state; }\n  }\n\n  var tabSize = cm.options.tabSize;\n  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n  if (line.stateAfter) { line.stateAfter = null; }\n  var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n  if (!aggressive && !/\\S/.test(line.text)) {\n    indentation = 0;\n    how = \"not\";\n  } else if (how == \"smart\") {\n    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n    if (indentation == Pass || indentation > 150) {\n      if (!aggressive) { return }\n      how = \"prev\";\n    }\n  }\n  if (how == \"prev\") {\n    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\n    else { indentation = 0; }\n  } else if (how == \"add\") {\n    indentation = curSpace + cm.options.indentUnit;\n  } else if (how == \"subtract\") {\n    indentation = curSpace - cm.options.indentUnit;\n  } else if (typeof how == \"number\") {\n    indentation = curSpace + how;\n  }\n  indentation = Math.max(0, indentation);\n\n  var indentString = \"\", pos = 0;\n  if (cm.options.indentWithTabs)\n    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\n  if (pos < indentation) { indentString += spaceStr(indentation - pos); }\n\n  if (indentString != curSpaceString) {\n    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n    line.stateAfter = null;\n    return true\n  } else {\n    // Ensure that, if the cursor was in the whitespace at the start\n    // of the line, it is moved to the end of that space.\n    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n      var range = doc.sel.ranges[i$1];\n      if (range.head.line == n && range.head.ch < curSpaceString.length) {\n        var pos$1 = Pos(n, curSpaceString.length);\n        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n        break\n      }\n    }\n  }\n}\n\n// This will be set to a {lineWise: bool, text: [string]} object, so\n// that, when pasting, we know what kind of selections the copied\n// text was made out of.\nvar lastCopied = null;\n\nfunction setLastCopied(newLastCopied) {\n  lastCopied = newLastCopied;\n}\n\nfunction applyTextInput(cm, inserted, deleted, sel, origin) {\n  var doc = cm.doc;\n  cm.display.shift = false;\n  if (!sel) { sel = doc.sel; }\n\n  var paste = cm.state.pasteIncoming || origin == \"paste\";\n  var textLines = splitLinesAuto(inserted), multiPaste = null;\n  // When pasing N lines into N selections, insert one line per selection\n  if (paste && sel.ranges.length > 1) {\n    if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n      if (sel.ranges.length % lastCopied.text.length == 0) {\n        multiPaste = [];\n        for (var i = 0; i < lastCopied.text.length; i++)\n          { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\n      }\n    } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n      multiPaste = map(textLines, function (l) { return [l]; });\n    }\n  }\n\n  var updateInput;\n  // Normal behavior is to insert the new text into every selection\n  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n    var range$$1 = sel.ranges[i$1];\n    var from = range$$1.from(), to = range$$1.to();\n    if (range$$1.empty()) {\n      if (deleted && deleted > 0) // Handle deletion\n        { from = Pos(from.line, from.ch - deleted); }\n      else if (cm.state.overwrite && !paste) // Handle overwrite\n        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\n      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == inserted)\n        { from = to = Pos(from.line, 0); }\n    }\n    updateInput = cm.curOp.updateInput;\n    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                       origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\n    makeChange(cm.doc, changeEvent);\n    signalLater(cm, \"inputRead\", cm, changeEvent);\n  }\n  if (inserted && !paste)\n    { triggerElectric(cm, inserted); }\n\n  ensureCursorVisible(cm);\n  cm.curOp.updateInput = updateInput;\n  cm.curOp.typing = true;\n  cm.state.pasteIncoming = cm.state.cutIncoming = false;\n}\n\nfunction handlePaste(e, cm) {\n  var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n  if (pasted) {\n    e.preventDefault();\n    if (!cm.isReadOnly() && !cm.options.disableInput)\n      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\n    return true\n  }\n}\n\nfunction triggerElectric(cm, inserted) {\n  // When an 'electric' character is inserted, immediately trigger a reindent\n  if (!cm.options.electricChars || !cm.options.smartIndent) { return }\n  var sel = cm.doc.sel;\n\n  for (var i = sel.ranges.length - 1; i >= 0; i--) {\n    var range$$1 = sel.ranges[i];\n    if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }\n    var mode = cm.getModeAt(range$$1.head);\n    var indented = false;\n    if (mode.electricChars) {\n      for (var j = 0; j < mode.electricChars.length; j++)\n        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n          indented = indentLine(cm, range$$1.head.line, \"smart\");\n          break\n        } }\n    } else if (mode.electricInput) {\n      if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))\n        { indented = indentLine(cm, range$$1.head.line, \"smart\"); }\n    }\n    if (indented) { signalLater(cm, \"electricInput\", cm, range$$1.head.line); }\n  }\n}\n\nfunction copyableRanges(cm) {\n  var text = [], ranges = [];\n  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n    var line = cm.doc.sel.ranges[i].head.line;\n    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n    ranges.push(lineRange);\n    text.push(cm.getRange(lineRange.anchor, lineRange.head));\n  }\n  return {text: text, ranges: ranges}\n}\n\nfunction disableBrowserMagic(field, spellcheck) {\n  field.setAttribute(\"autocorrect\", \"off\");\n  field.setAttribute(\"autocapitalize\", \"off\");\n  field.setAttribute(\"spellcheck\", !!spellcheck);\n}\n\nfunction hiddenTextarea() {\n  var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n  var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n  // The textarea is kept positioned near the cursor to prevent the\n  // fact that it'll be scrolled into view on input from scrolling\n  // our fake cursor out of view. On webkit, when wrap=off, paste is\n  // very slow. So make the area wide instead.\n  if (webkit) { te.style.width = \"1000px\"; }\n  else { te.setAttribute(\"wrap\", \"off\"); }\n  // If border: 0; -- iOS fails to open keyboard (issue #1287)\n  if (ios) { te.style.border = \"1px solid black\"; }\n  disableBrowserMagic(te);\n  return div\n}\n\n// The publicly visible API. Note that methodOp(f) means\n// 'wrap f in an operation, performed on its `this` parameter'.\n\n// This is not the complete set of editor methods. Most of the\n// methods defined on the Doc type are also injected into\n// CodeMirror.prototype, for backwards compatibility and\n// convenience.\n\nvar addEditorMethods = function(CodeMirror) {\n  var optionHandlers = CodeMirror.optionHandlers;\n\n  var helpers = CodeMirror.helpers = {};\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function(){window.focus(); this.display.input.focus();},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != \"mode\") { return }\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        { operation(this, optionHandlers[option])(this, value, old); }\n      signal(this, \"optionChange\", this, option);\n    },\n\n    getOption: function(option) {return this.options[option]},\n    getDoc: function() {return this.doc},\n\n    addKeyMap: function(map$$1, bottom) {\n      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map$$1));\n    },\n    removeKeyMap: function(map$$1) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        { if (maps[i] == map$$1 || maps[i].name == map$$1) {\n          maps.splice(i, 1);\n          return true\n        } }\n    },\n\n    addOverlay: methodOp(function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\n      insertSorted(this.state.overlays,\n                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,\n                    priority: (options && options.priority) || 0},\n                   function (overlay) { return overlay.priority; });\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: methodOp(function(spec) {\n      var this$1 = this;\n\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this$1.state.modeGen++;\n          regChange(this$1);\n          return\n        }\n      }\n    }),\n\n    indentLine: methodOp(function(n, dir, aggressive) {\n      if (typeof dir != \"string\" && typeof dir != \"number\") {\n        if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\n        else { dir = dir ? \"add\" : \"subtract\"; }\n      }\n      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\n    }),\n    indentSelection: methodOp(function(how) {\n      var this$1 = this;\n\n      var ranges = this.doc.sel.ranges, end = -1;\n      for (var i = 0; i < ranges.length; i++) {\n        var range$$1 = ranges[i];\n        if (!range$$1.empty()) {\n          var from = range$$1.from(), to = range$$1.to();\n          var start = Math.max(end, from.line);\n          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n          for (var j = start; j < end; ++j)\n            { indentLine(this$1, j, how); }\n          var newRanges = this$1.doc.sel.ranges;\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\n        } else if (range$$1.head.line > end) {\n          indentLine(this$1, range$$1.head.line, how, true);\n          end = range$$1.head.line;\n          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }\n        }\n      }\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos, precise) {\n      return takeToken(this, pos, precise)\n    },\n\n    getLineTokens: function(line, precise) {\n      return takeToken(this, Pos(line), precise, true)\n    },\n\n    getTokenTypeAt: function(pos) {\n      pos = clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n      var type;\n      if (ch == 0) { type = styles[2]; }\n      else { for (;;) {\n        var mid = (before + after) >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\n        else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\n        else { type = styles[mid * 2 + 2]; break }\n      } }\n      var cut = type ? type.indexOf(\"overlay \") : -1;\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\n    },\n\n    getModeAt: function(pos) {\n      var mode = this.doc.mode;\n      if (!mode.innerMode) { return mode }\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\n    },\n\n    getHelper: function(pos, type) {\n      return this.getHelpers(pos, type)[0]\n    },\n\n    getHelpers: function(pos, type) {\n      var this$1 = this;\n\n      var found = [];\n      if (!helpers.hasOwnProperty(type)) { return found }\n      var help = helpers[type], mode = this.getModeAt(pos);\n      if (typeof mode[type] == \"string\") {\n        if (help[mode[type]]) { found.push(help[mode[type]]); }\n      } else if (mode[type]) {\n        for (var i = 0; i < mode[type].length; i++) {\n          var val = help[mode[type][i]];\n          if (val) { found.push(val); }\n        }\n      } else if (mode.helperType && help[mode.helperType]) {\n        found.push(help[mode.helperType]);\n      } else if (help[mode.name]) {\n        found.push(help[mode.name]);\n      }\n      for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n        var cur = help._global[i$1];\n        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)\n          { found.push(cur.val); }\n      }\n      return found\n    },\n\n    getStateAfter: function(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getContextBefore(this, line + 1, precise).state\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, range$$1 = this.doc.sel.primary();\n      if (start == null) { pos = range$$1.head; }\n      else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\n      else { pos = start ? range$$1.from() : range$$1.to(); }\n      return cursorCoords(this, pos, mode || \"page\")\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\n    },\n\n    coordsChar: function(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || \"page\");\n      return coordsChar(this, coords.left, coords.top)\n    },\n\n    lineAtHeight: function(height, mode) {\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n      return lineAtHeight(this.doc, height + this.display.viewOffset)\n    },\n    heightAtLine: function(line, mode, includeWidgets) {\n      var end = false, lineObj;\n      if (typeof line == \"number\") {\n        var last = this.doc.first + this.doc.size - 1;\n        if (line < this.doc.first) { line = this.doc.first; }\n        else if (line > last) { line = last; end = true; }\n        lineObj = getLine(this.doc, line);\n      } else {\n        lineObj = line;\n      }\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\n        (end ? this.doc.height - heightAtLine(lineObj) : 0)\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display) },\n    defaultCharWidth: function() { return charWidth(this.display) },\n\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = \"absolute\";\n      node.setAttribute(\"cm-ignore-events\", \"true\");\n      this.display.input.setUneditable(node);\n      display.sizer.appendChild(node);\n      if (vert == \"over\") {\n        top = pos.top;\n      } else if (vert == \"above\" || vert == \"near\") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          { top = pos.top - node.offsetHeight; }\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          { top = pos.bottom; }\n        if (left + node.offsetWidth > hspace)\n          { left = hspace - node.offsetWidth; }\n      }\n      node.style.top = top + \"px\";\n      node.style.left = node.style.right = \"\";\n      if (horiz == \"right\") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = \"0px\";\n      } else {\n        if (horiz == \"left\") { left = 0; }\n        else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\n        node.style.left = left + \"px\";\n      }\n      if (scroll)\n        { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\n    },\n\n    triggerOnKeyDown: methodOp(onKeyDown),\n    triggerOnKeyPress: methodOp(onKeyPress),\n    triggerOnKeyUp: onKeyUp,\n    triggerOnMouseDown: methodOp(onMouseDown),\n\n    execCommand: function(cmd) {\n      if (commands.hasOwnProperty(cmd))\n        { return commands[cmd].call(null, this) }\n    },\n\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n    findPosH: function(from, amount, unit, visually) {\n      var this$1 = this;\n\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      var cur = clipPos(this.doc, from);\n      for (var i = 0; i < amount; ++i) {\n        cur = findPosH(this$1.doc, cur, dir, unit, visually);\n        if (cur.hitSide) { break }\n      }\n      return cur\n    },\n\n    moveH: methodOp(function(dir, unit) {\n      var this$1 = this;\n\n      this.extendSelectionsBy(function (range$$1) {\n        if (this$1.display.shift || this$1.doc.extend || range$$1.empty())\n          { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }\n        else\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\n      }, sel_move);\n    }),\n\n    deleteH: methodOp(function(dir, unit) {\n      var sel = this.doc.sel, doc = this.doc;\n      if (sel.somethingSelected())\n        { doc.replaceSelection(\"\", null, \"+delete\"); }\n      else\n        { deleteNearSelection(this, function (range$$1) {\n          var other = findPosH(doc, range$$1.head, dir, unit, false);\n          return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}\n        }); }\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var this$1 = this;\n\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      var cur = clipPos(this.doc, from);\n      for (var i = 0; i < amount; ++i) {\n        var coords = cursorCoords(this$1, cur, \"div\");\n        if (x == null) { x = coords.left; }\n        else { coords.left = x; }\n        cur = findPosV(this$1, coords, dir, unit);\n        if (cur.hitSide) { break }\n      }\n      return cur\n    },\n\n    moveV: methodOp(function(dir, unit) {\n      var this$1 = this;\n\n      var doc = this.doc, goals = [];\n      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n      doc.extendSelectionsBy(function (range$$1) {\n        if (collapse)\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\n        var headPos = cursorCoords(this$1, range$$1.head, \"div\");\n        if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }\n        goals.push(headPos.left);\n        var pos = findPosV(this$1, headPos, dir, unit);\n        if (unit == \"page\" && range$$1 == doc.sel.primary())\n          { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\n        return pos\n      }, sel_move);\n      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\n        { doc.sel.ranges[i].goalColumn = goals[i]; } }\n    }),\n\n    // Find the word at the given position (as returned by coordsChar).\n    findWordAt: function(pos) {\n      var doc = this.doc, line = getLine(doc, pos.line).text;\n      var start = pos.ch, end = pos.ch;\n      if (line) {\n        var helper = this.getHelper(pos, \"wordChars\");\n        if ((pos.sticky == \"before\" || end == line.length) && start) { --start; } else { ++end; }\n        var startChar = line.charAt(start);\n        var check = isWordChar(startChar, helper)\n          ? function (ch) { return isWordChar(ch, helper); }\n          : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\n          : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\n        while (start > 0 && check(line.charAt(start - 1))) { --start; }\n        while (end < line.length && check(line.charAt(end))) { ++end; }\n      }\n      return new Range(Pos(pos.line, start), Pos(pos.line, end))\n    },\n\n    toggleOverwrite: function(value) {\n      if (value != null && value == this.state.overwrite) { return }\n      if (this.state.overwrite = !this.state.overwrite)\n        { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n      else\n        { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n\n      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n    },\n    hasFocus: function() { return this.display.input.getField() == activeElt() },\n    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\n\n    scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\n    },\n\n    scrollIntoView: methodOp(function(range$$1, margin) {\n      if (range$$1 == null) {\n        range$$1 = {from: this.doc.sel.primary().head, to: null};\n        if (margin == null) { margin = this.options.cursorScrollMargin; }\n      } else if (typeof range$$1 == \"number\") {\n        range$$1 = {from: Pos(range$$1, 0), to: null};\n      } else if (range$$1.from == null) {\n        range$$1 = {from: range$$1, to: null};\n      }\n      if (!range$$1.to) { range$$1.to = range$$1.from; }\n      range$$1.margin = margin || 0;\n\n      if (range$$1.from.line != null) {\n        scrollToRange(this, range$$1);\n      } else {\n        scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);\n      }\n    }),\n\n    setSize: methodOp(function(width, height) {\n      var this$1 = this;\n\n      var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\n      if (width != null) { this.display.wrapper.style.width = interpret(width); }\n      if (height != null) { this.display.wrapper.style.height = interpret(height); }\n      if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\n      var lineNo$$1 = this.display.viewFrom;\n      this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {\n        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\n          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, \"widget\"); break } } }\n        ++lineNo$$1;\n      });\n      this.curOp.forceUpdate = true;\n      signal(this, \"refresh\", this);\n    }),\n\n    operation: function(f){return runInOp(this, f)},\n    startOperation: function(){return startOperation(this)},\n    endOperation: function(){return endOperation(this)},\n\n    refresh: methodOp(function() {\n      var oldHeight = this.display.cachedTextHeight;\n      regChange(this);\n      this.curOp.forceUpdate = true;\n      clearCaches(this);\n      scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n      updateGutterSpace(this);\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n        { estimateLineHeights(this); }\n      signal(this, \"refresh\", this);\n    }),\n\n    swapDoc: methodOp(function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      this.display.input.reset();\n      scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n      this.curOp.forceScroll = true;\n      signalLater(this, \"swapDoc\", this, old);\n      return old\n    }),\n\n    getInputField: function(){return this.display.input.getField()},\n    getWrapperElement: function(){return this.display.wrapper},\n    getScrollerElement: function(){return this.display.scroller},\n    getGutterElement: function(){return this.display.gutters}\n  };\n  eventMixin(CodeMirror);\n\n  CodeMirror.registerHelper = function(type, name, value) {\n    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\n    helpers[type][name] = value;\n  };\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n    CodeMirror.registerHelper(type, name, value);\n    helpers[type]._global.push({pred: predicate, val: value});\n  };\n};\n\n// Used for horizontal relative motion. Dir is -1 or 1 (left or\n// right), unit can be \"char\", \"column\" (like char, but doesn't\n// cross line boundaries), \"word\" (across next word), or \"group\" (to\n// the start of next group of word or non-word-non-whitespace\n// chars). The visually param controls whether, in right-to-left\n// text, direction 1 means to move towards the next index in the\n// string, or towards the character to the right of the current\n// position. The resulting position will have a hitSide=true\n// property if it reached the end of the document.\nfunction findPosH(doc, pos, dir, unit, visually) {\n  var oldPos = pos;\n  var origDir = dir;\n  var lineObj = getLine(doc, pos.line);\n  function findNextLine() {\n    var l = pos.line + dir;\n    if (l < doc.first || l >= doc.first + doc.size) { return false }\n    pos = new Pos(l, pos.ch, pos.sticky);\n    return lineObj = getLine(doc, l)\n  }\n  function moveOnce(boundToLine) {\n    var next;\n    if (visually) {\n      next = moveVisually(doc.cm, lineObj, pos, dir);\n    } else {\n      next = moveLogically(lineObj, pos, dir);\n    }\n    if (next == null) {\n      if (!boundToLine && findNextLine())\n        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }\n      else\n        { return false }\n    } else {\n      pos = next;\n    }\n    return true\n  }\n\n  if (unit == \"char\") {\n    moveOnce();\n  } else if (unit == \"column\") {\n    moveOnce(true);\n  } else if (unit == \"word\" || unit == \"group\") {\n    var sawType = null, group = unit == \"group\";\n    var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n    for (var first = true;; first = false) {\n      if (dir < 0 && !moveOnce(!first)) { break }\n      var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n      var type = isWordChar(cur, helper) ? \"w\"\n        : group && cur == \"\\n\" ? \"n\"\n        : !group || /\\s/.test(cur) ? null\n        : \"p\";\n      if (group && !first && !type) { type = \"s\"; }\n      if (sawType && sawType != type) {\n        if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\n        break\n      }\n\n      if (type) { sawType = type; }\n      if (dir > 0 && !moveOnce(!first)) { break }\n    }\n  }\n  var result = skipAtomic(doc, pos, oldPos, origDir, true);\n  if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\n  return result\n}\n\n// For relative vertical movement. Dir may be -1 or 1. Unit can be\n// \"page\" or \"line\". The resulting position will have a hitSide=true\n// property if it reached the end of the document.\nfunction findPosV(cm, pos, dir, unit) {\n  var doc = cm.doc, x = pos.left, y;\n  if (unit == \"page\") {\n    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n\n  } else if (unit == \"line\") {\n    y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n  }\n  var target;\n  for (;;) {\n    target = coordsChar(cm, x, y);\n    if (!target.outside) { break }\n    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\n    y += dir * 5;\n  }\n  return target\n}\n\n// CONTENTEDITABLE INPUT STYLE\n\nvar ContentEditableInput = function(cm) {\n  this.cm = cm;\n  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n  this.polling = new Delayed();\n  this.composing = null;\n  this.gracePeriod = false;\n  this.readDOMTimeout = null;\n};\n\nContentEditableInput.prototype.init = function (display) {\n    var this$1 = this;\n\n  var input = this, cm = input.cm;\n  var div = input.div = display.lineDiv;\n  disableBrowserMagic(div, cm.options.spellcheck);\n\n  on(div, \"paste\", function (e) {\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n    // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n    if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\n  });\n\n  on(div, \"compositionstart\", function (e) {\n    this$1.composing = {data: e.data, done: false};\n  });\n  on(div, \"compositionupdate\", function (e) {\n    if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\n  });\n  on(div, \"compositionend\", function (e) {\n    if (this$1.composing) {\n      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\n      this$1.composing.done = true;\n    }\n  });\n\n  on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\n\n  on(div, \"input\", function () {\n    if (!this$1.composing) { this$1.readFromDOMSoon(); }\n  });\n\n  function onCopyCut(e) {\n    if (signalDOMEvent(cm, e)) { return }\n    if (cm.somethingSelected()) {\n      setLastCopied({lineWise: false, text: cm.getSelections()});\n      if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\n    } else if (!cm.options.lineWiseCopyCut) {\n      return\n    } else {\n      var ranges = copyableRanges(cm);\n      setLastCopied({lineWise: true, text: ranges.text});\n      if (e.type == \"cut\") {\n        cm.operation(function () {\n          cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n          cm.replaceSelection(\"\", null, \"cut\");\n        });\n      }\n    }\n    if (e.clipboardData) {\n      e.clipboardData.clearData();\n      var content = lastCopied.text.join(\"\\n\");\n      // iOS exposes the clipboard API, but seems to discard content inserted into it\n      e.clipboardData.setData(\"Text\", content);\n      if (e.clipboardData.getData(\"Text\") == content) {\n        e.preventDefault();\n        return\n      }\n    }\n    // Old-fashioned briefly-focus-a-textarea hack\n    var kludge = hiddenTextarea(), te = kludge.firstChild;\n    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n    te.value = lastCopied.text.join(\"\\n\");\n    var hadFocus = document.activeElement;\n    selectInput(te);\n    setTimeout(function () {\n      cm.display.lineSpace.removeChild(kludge);\n      hadFocus.focus();\n      if (hadFocus == div) { input.showPrimarySelection(); }\n    }, 50);\n  }\n  on(div, \"copy\", onCopyCut);\n  on(div, \"cut\", onCopyCut);\n};\n\nContentEditableInput.prototype.prepareSelection = function () {\n  var result = prepareSelection(this.cm, false);\n  result.focus = this.cm.state.focused;\n  return result\n};\n\nContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n  if (!info || !this.cm.display.view.length) { return }\n  if (info.focus || takeFocus) { this.showPrimarySelection(); }\n  this.showMultipleSelections(info);\n};\n\nContentEditableInput.prototype.showPrimarySelection = function () {\n  var sel = window.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n  var from = prim.from(), to = prim.to();\n\n  if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n    sel.removeAllRanges();\n    return\n  }\n\n  var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n  var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n      cmp(minPos(curAnchor, curFocus), from) == 0 &&\n      cmp(maxPos(curAnchor, curFocus), to) == 0)\n    { return }\n\n  var view = cm.display.view;\n  var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\n      {node: view[0].measure.map[2], offset: 0};\n  var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n  if (!end) {\n    var measure = view[view.length - 1].measure;\n    var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n    end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};\n  }\n\n  if (!start || !end) {\n    sel.removeAllRanges();\n    return\n  }\n\n  var old = sel.rangeCount && sel.getRangeAt(0), rng;\n  try { rng = range(start.node, start.offset, end.offset, end.node); }\n  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n  if (rng) {\n    if (!gecko && cm.state.focused) {\n      sel.collapse(start.node, start.offset);\n      if (!rng.collapsed) {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n    } else {\n      sel.removeAllRanges();\n      sel.addRange(rng);\n    }\n    if (old && sel.anchorNode == null) { sel.addRange(old); }\n    else if (gecko) { this.startGracePeriod(); }\n  }\n  this.rememberSelection();\n};\n\nContentEditableInput.prototype.startGracePeriod = function () {\n    var this$1 = this;\n\n  clearTimeout(this.gracePeriod);\n  this.gracePeriod = setTimeout(function () {\n    this$1.gracePeriod = false;\n    if (this$1.selectionChanged())\n      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\n  }, 20);\n};\n\nContentEditableInput.prototype.showMultipleSelections = function (info) {\n  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n};\n\nContentEditableInput.prototype.rememberSelection = function () {\n  var sel = window.getSelection();\n  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n};\n\nContentEditableInput.prototype.selectionInEditor = function () {\n  var sel = window.getSelection();\n  if (!sel.rangeCount) { return false }\n  var node = sel.getRangeAt(0).commonAncestorContainer;\n  return contains(this.div, node)\n};\n\nContentEditableInput.prototype.focus = function () {\n  if (this.cm.options.readOnly != \"nocursor\") {\n    if (!this.selectionInEditor())\n      { this.showSelection(this.prepareSelection(), true); }\n    this.div.focus();\n  }\n};\nContentEditableInput.prototype.blur = function () { this.div.blur(); };\nContentEditableInput.prototype.getField = function () { return this.div };\n\nContentEditableInput.prototype.supportsTouch = function () { return true };\n\nContentEditableInput.prototype.receivedFocus = function () {\n  var input = this;\n  if (this.selectionInEditor())\n    { this.pollSelection(); }\n  else\n    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\n\n  function poll() {\n    if (input.cm.state.focused) {\n      input.pollSelection();\n      input.polling.set(input.cm.options.pollInterval, poll);\n    }\n  }\n  this.polling.set(this.cm.options.pollInterval, poll);\n};\n\nContentEditableInput.prototype.selectionChanged = function () {\n  var sel = window.getSelection();\n  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\n};\n\nContentEditableInput.prototype.pollSelection = function () {\n  if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\n  var sel = window.getSelection(), cm = this.cm;\n  // On Android Chrome (version 56, at least), backspacing into an\n  // uneditable block element will put the cursor in that element,\n  // and then, because it's not editable, hide the virtual keyboard.\n  // Because Android doesn't allow us to actually detect backspace\n  // presses in a sane way, this code checks for when that happens\n  // and simulates a backspace press in this case.\n  if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {\n    this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\n    this.blur();\n    this.focus();\n    return\n  }\n  if (this.composing) { return }\n  this.rememberSelection();\n  var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n  var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n  if (anchor && head) { runInOp(cm, function () {\n    setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n    if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\n  }); }\n};\n\nContentEditableInput.prototype.pollContent = function () {\n  if (this.readDOMTimeout != null) {\n    clearTimeout(this.readDOMTimeout);\n    this.readDOMTimeout = null;\n  }\n\n  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n  var from = sel.from(), to = sel.to();\n  if (from.ch == 0 && from.line > cm.firstLine())\n    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\n  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n    { to = Pos(to.line + 1, 0); }\n  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\n\n  var fromIndex, fromLine, fromNode;\n  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n    fromLine = lineNo(display.view[0].line);\n    fromNode = display.view[0].node;\n  } else {\n    fromLine = lineNo(display.view[fromIndex].line);\n    fromNode = display.view[fromIndex - 1].node.nextSibling;\n  }\n  var toIndex = findViewIndex(cm, to.line);\n  var toLine, toNode;\n  if (toIndex == display.view.length - 1) {\n    toLine = display.viewTo - 1;\n    toNode = display.lineDiv.lastChild;\n  } else {\n    toLine = lineNo(display.view[toIndex + 1].line) - 1;\n    toNode = display.view[toIndex + 1].node.previousSibling;\n  }\n\n  if (!fromNode) { return false }\n  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n  while (newText.length > 1 && oldText.length > 1) {\n    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n    else { break }\n  }\n\n  var cutFront = 0, cutEnd = 0;\n  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n    { ++cutFront; }\n  var newBot = lst(newText), oldBot = lst(oldText);\n  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                           oldBot.length - (oldText.length == 1 ? cutFront : 0));\n  while (cutEnd < maxCutEnd &&\n         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n    { ++cutEnd; }\n  // Try to move start of change to start of selection if ambiguous\n  if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n    while (cutFront && cutFront > from.ch &&\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n      cutFront--;\n      cutEnd++;\n    }\n  }\n\n  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n  newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n\n  var chFrom = Pos(fromLine, cutFront);\n  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n    replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n    return true\n  }\n};\n\nContentEditableInput.prototype.ensurePolled = function () {\n  this.forceCompositionEnd();\n};\nContentEditableInput.prototype.reset = function () {\n  this.forceCompositionEnd();\n};\nContentEditableInput.prototype.forceCompositionEnd = function () {\n  if (!this.composing) { return }\n  clearTimeout(this.readDOMTimeout);\n  this.composing = null;\n  this.updateFromDOM();\n  this.div.blur();\n  this.div.focus();\n};\nContentEditableInput.prototype.readFromDOMSoon = function () {\n    var this$1 = this;\n\n  if (this.readDOMTimeout != null) { return }\n  this.readDOMTimeout = setTimeout(function () {\n    this$1.readDOMTimeout = null;\n    if (this$1.composing) {\n      if (this$1.composing.done) { this$1.composing = null; }\n      else { return }\n    }\n    this$1.updateFromDOM();\n  }, 80);\n};\n\nContentEditableInput.prototype.updateFromDOM = function () {\n    var this$1 = this;\n\n  if (this.cm.isReadOnly() || !this.pollContent())\n    { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\n};\n\nContentEditableInput.prototype.setUneditable = function (node) {\n  node.contentEditable = \"false\";\n};\n\nContentEditableInput.prototype.onKeyPress = function (e) {\n  if (e.charCode == 0) { return }\n  e.preventDefault();\n  if (!this.cm.isReadOnly())\n    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\n};\n\nContentEditableInput.prototype.readOnlyChanged = function (val) {\n  this.div.contentEditable = String(val != \"nocursor\");\n};\n\nContentEditableInput.prototype.onContextMenu = function () {};\nContentEditableInput.prototype.resetPosition = function () {};\n\nContentEditableInput.prototype.needsContentAttribute = true;\n\nfunction posToDOM(cm, pos) {\n  var view = findViewForLine(cm, pos.line);\n  if (!view || view.hidden) { return null }\n  var line = getLine(cm.doc, pos.line);\n  var info = mapFromLineView(view, line, pos.line);\n\n  var order = getOrder(line, cm.doc.direction), side = \"left\";\n  if (order) {\n    var partPos = getBidiPartAt(order, pos.ch);\n    side = partPos % 2 ? \"right\" : \"left\";\n  }\n  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n  result.offset = result.collapse == \"right\" ? result.end : result.start;\n  return result\n}\n\nfunction isInGutter(node) {\n  for (var scan = node; scan; scan = scan.parentNode)\n    { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\n  return false\n}\n\nfunction badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\n\nfunction domTextBetween(cm, from, to, fromLine, toLine) {\n  var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\n  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\n  function close() {\n    if (closing) {\n      text += lineSep;\n      closing = false;\n    }\n  }\n  function addText(str) {\n    if (str) {\n      close();\n      text += str;\n    }\n  }\n  function walk(node) {\n    if (node.nodeType == 1) {\n      var cmText = node.getAttribute(\"cm-text\");\n      if (cmText != null) {\n        addText(cmText || node.textContent.replace(/\\u200b/g, \"\"));\n        return\n      }\n      var markerID = node.getAttribute(\"cm-marker\"), range$$1;\n      if (markerID) {\n        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n        if (found.length && (range$$1 = found[0].find()))\n          { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }\n        return\n      }\n      if (node.getAttribute(\"contenteditable\") == \"false\") { return }\n      var isBlock = /^(pre|div|p)$/i.test(node.nodeName);\n      if (isBlock) { close(); }\n      for (var i = 0; i < node.childNodes.length; i++)\n        { walk(node.childNodes[i]); }\n      if (isBlock) { closing = true; }\n    } else if (node.nodeType == 3) {\n      addText(node.nodeValue);\n    }\n  }\n  for (;;) {\n    walk(from);\n    if (from == to) { break }\n    from = from.nextSibling;\n  }\n  return text\n}\n\nfunction domToPos(cm, node, offset) {\n  var lineNode;\n  if (node == cm.display.lineDiv) {\n    lineNode = cm.display.lineDiv.childNodes[offset];\n    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\n    node = null; offset = 0;\n  } else {\n    for (lineNode = node;; lineNode = lineNode.parentNode) {\n      if (!lineNode || lineNode == cm.display.lineDiv) { return null }\n      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\n    }\n  }\n  for (var i = 0; i < cm.display.view.length; i++) {\n    var lineView = cm.display.view[i];\n    if (lineView.node == lineNode)\n      { return locateNodeInLineView(lineView, node, offset) }\n  }\n}\n\nfunction locateNodeInLineView(lineView, node, offset) {\n  var wrapper = lineView.text.firstChild, bad = false;\n  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\n  if (node == wrapper) {\n    bad = true;\n    node = wrapper.childNodes[offset];\n    offset = 0;\n    if (!node) {\n      var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n      return badPos(Pos(lineNo(line), line.text.length), bad)\n    }\n  }\n\n  var textNode = node.nodeType == 3 ? node : null, topNode = node;\n  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n    textNode = node.firstChild;\n    if (offset) { offset = textNode.nodeValue.length; }\n  }\n  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\n  var measure = lineView.measure, maps = measure.maps;\n\n  function find(textNode, topNode, offset) {\n    for (var i = -1; i < (maps ? maps.length : 0); i++) {\n      var map$$1 = i < 0 ? measure.map : maps[i];\n      for (var j = 0; j < map$$1.length; j += 3) {\n        var curNode = map$$1[j + 2];\n        if (curNode == textNode || curNode == topNode) {\n          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n          var ch = map$$1[j] + offset;\n          if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }\n          return Pos(line, ch)\n        }\n      }\n    }\n  }\n  var found = find(textNode, topNode, offset);\n  if (found) { return badPos(found, bad) }\n\n  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n    found = find(after, after.firstChild, 0);\n    if (found)\n      { return badPos(Pos(found.line, found.ch - dist), bad) }\n    else\n      { dist += after.textContent.length; }\n  }\n  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n    found = find(before, before.firstChild, -1);\n    if (found)\n      { return badPos(Pos(found.line, found.ch + dist$1), bad) }\n    else\n      { dist$1 += before.textContent.length; }\n  }\n}\n\n// TEXTAREA INPUT STYLE\n\nvar TextareaInput = function(cm) {\n  this.cm = cm;\n  // See input.poll and input.reset\n  this.prevInput = \"\";\n\n  // Flag that indicates whether we expect input to appear real soon\n  // now (after some event like 'keypress' or 'input') and are\n  // polling intensively.\n  this.pollingFast = false;\n  // Self-resetting timeout for the poller\n  this.polling = new Delayed();\n  // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n  this.hasSelection = false;\n  this.composing = null;\n};\n\nTextareaInput.prototype.init = function (display) {\n    var this$1 = this;\n\n  var input = this, cm = this.cm;\n\n  // Wraps and hides input textarea\n  var div = this.wrapper = hiddenTextarea();\n  // The semihidden textarea that is focused when the editor is\n  // focused, and receives input.\n  var te = this.textarea = div.firstChild;\n  display.wrapper.insertBefore(div, display.wrapper.firstChild);\n\n  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n  if (ios) { te.style.width = \"0px\"; }\n\n  on(te, \"input\", function () {\n    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\n    input.poll();\n  });\n\n  on(te, \"paste\", function (e) {\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n\n    cm.state.pasteIncoming = true;\n    input.fastPoll();\n  });\n\n  function prepareCopyCut(e) {\n    if (signalDOMEvent(cm, e)) { return }\n    if (cm.somethingSelected()) {\n      setLastCopied({lineWise: false, text: cm.getSelections()});\n    } else if (!cm.options.lineWiseCopyCut) {\n      return\n    } else {\n      var ranges = copyableRanges(cm);\n      setLastCopied({lineWise: true, text: ranges.text});\n      if (e.type == \"cut\") {\n        cm.setSelections(ranges.ranges, null, sel_dontScroll);\n      } else {\n        input.prevInput = \"\";\n        te.value = ranges.text.join(\"\\n\");\n        selectInput(te);\n      }\n    }\n    if (e.type == \"cut\") { cm.state.cutIncoming = true; }\n  }\n  on(te, \"cut\", prepareCopyCut);\n  on(te, \"copy\", prepareCopyCut);\n\n  on(display.scroller, \"paste\", function (e) {\n    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\n    cm.state.pasteIncoming = true;\n    input.focus();\n  });\n\n  // Prevent normal selection in the editor (we handle our own)\n  on(display.lineSpace, \"selectstart\", function (e) {\n    if (!eventInWidget(display, e)) { e_preventDefault(e); }\n  });\n\n  on(te, \"compositionstart\", function () {\n    var start = cm.getCursor(\"from\");\n    if (input.composing) { input.composing.range.clear(); }\n    input.composing = {\n      start: start,\n      range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n    };\n  });\n  on(te, \"compositionend\", function () {\n    if (input.composing) {\n      input.poll();\n      input.composing.range.clear();\n      input.composing = null;\n    }\n  });\n};\n\nTextareaInput.prototype.prepareSelection = function () {\n  // Redraw the selection and/or cursor\n  var cm = this.cm, display = cm.display, doc = cm.doc;\n  var result = prepareSelection(cm);\n\n  // Move the hidden textarea near the cursor to prevent scrolling artifacts\n  if (cm.options.moveInputWithCursor) {\n    var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                        headPos.top + lineOff.top - wrapOff.top));\n    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                         headPos.left + lineOff.left - wrapOff.left));\n  }\n\n  return result\n};\n\nTextareaInput.prototype.showSelection = function (drawn) {\n  var cm = this.cm, display = cm.display;\n  removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n  removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n  if (drawn.teTop != null) {\n    this.wrapper.style.top = drawn.teTop + \"px\";\n    this.wrapper.style.left = drawn.teLeft + \"px\";\n  }\n};\n\n// Reset the input to correspond to the selection (or to be empty,\n// when not typing and nothing is selected)\nTextareaInput.prototype.reset = function (typing) {\n  if (this.contextMenuPending || this.composing) { return }\n  var cm = this.cm;\n  if (cm.somethingSelected()) {\n    this.prevInput = \"\";\n    var content = cm.getSelection();\n    this.textarea.value = content;\n    if (cm.state.focused) { selectInput(this.textarea); }\n    if (ie && ie_version >= 9) { this.hasSelection = content; }\n  } else if (!typing) {\n    this.prevInput = this.textarea.value = \"\";\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\n  }\n};\n\nTextareaInput.prototype.getField = function () { return this.textarea };\n\nTextareaInput.prototype.supportsTouch = function () { return false };\n\nTextareaInput.prototype.focus = function () {\n  if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n    try { this.textarea.focus(); }\n    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n  }\n};\n\nTextareaInput.prototype.blur = function () { this.textarea.blur(); };\n\nTextareaInput.prototype.resetPosition = function () {\n  this.wrapper.style.top = this.wrapper.style.left = 0;\n};\n\nTextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\n\n// Poll for input changes, using the normal rate of polling. This\n// runs as long as the editor is focused.\nTextareaInput.prototype.slowPoll = function () {\n    var this$1 = this;\n\n  if (this.pollingFast) { return }\n  this.polling.set(this.cm.options.pollInterval, function () {\n    this$1.poll();\n    if (this$1.cm.state.focused) { this$1.slowPoll(); }\n  });\n};\n\n// When an event has just come in that is likely to add or change\n// something in the input textarea, we poll faster, to ensure that\n// the change appears on the screen quickly.\nTextareaInput.prototype.fastPoll = function () {\n  var missed = false, input = this;\n  input.pollingFast = true;\n  function p() {\n    var changed = input.poll();\n    if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n    else {input.pollingFast = false; input.slowPoll();}\n  }\n  input.polling.set(20, p);\n};\n\n// Read input from the textarea, and update the document to match.\n// When something is selected, it is present in the textarea, and\n// selected (unless it is huge, in which case a placeholder is\n// used). When nothing is selected, the cursor sits after previously\n// seen text (can be empty), which is stored in prevInput (we must\n// not reset the textarea when typing, because that breaks IME).\nTextareaInput.prototype.poll = function () {\n    var this$1 = this;\n\n  var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n  // Since this is called a *lot*, try to bail out as cheaply as\n  // possible when it is clear that nothing happened. hasSelection\n  // will be the case when there is a lot of text in the textarea,\n  // in which case reading its value would be expensive.\n  if (this.contextMenuPending || !cm.state.focused ||\n      (hasSelection(input) && !prevInput && !this.composing) ||\n      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n    { return false }\n\n  var text = input.value;\n  // If nothing changed, bail.\n  if (text == prevInput && !cm.somethingSelected()) { return false }\n  // Work around nonsensical selection resetting in IE9/10, and\n  // inexplicable appearance of private area unicode characters on\n  // some key combos in Mac (#2689).\n  if (ie && ie_version >= 9 && this.hasSelection === text ||\n      mac && /[\\uf700-\\uf7ff]/.test(text)) {\n    cm.display.input.reset();\n    return false\n  }\n\n  if (cm.doc.sel == cm.display.selForContextMenu) {\n    var first = text.charCodeAt(0);\n    if (first == 0x200b && !prevInput) { prevInput = \"\\u200b\"; }\n    if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\n  }\n  // Find the part of the input that is actually new\n  var same = 0, l = Math.min(prevInput.length, text.length);\n  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\n\n  runInOp(cm, function () {\n    applyTextInput(cm, text.slice(same), prevInput.length - same,\n                   null, this$1.composing ? \"*compose\" : null);\n\n    // Don't leave long text in the textarea, since it makes further polling slow\n    if (text.length > 1000 || text.indexOf(\"\\n\") > -1) { input.value = this$1.prevInput = \"\"; }\n    else { this$1.prevInput = text; }\n\n    if (this$1.composing) {\n      this$1.composing.range.clear();\n      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\n                                         {className: \"CodeMirror-composing\"});\n    }\n  });\n  return true\n};\n\nTextareaInput.prototype.ensurePolled = function () {\n  if (this.pollingFast && this.poll()) { this.pollingFast = false; }\n};\n\nTextareaInput.prototype.onKeyPress = function () {\n  if (ie && ie_version >= 9) { this.hasSelection = null; }\n  this.fastPoll();\n};\n\nTextareaInput.prototype.onContextMenu = function (e) {\n  var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n  if (!pos || presto) { return } // Opera is difficult.\n\n  // Reset the current text selection only if the click is done outside of the selection\n  // and 'resetSelectionOnContextMenu' option is true.\n  var reset = cm.options.resetSelectionOnContextMenu;\n  if (reset && cm.doc.sel.contains(pos) == -1)\n    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\n\n  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n  input.wrapper.style.cssText = \"position: absolute\";\n  var wrapperBox = input.wrapper.getBoundingClientRect();\n  te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n  var oldScrollY;\n  if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\n  display.input.focus();\n  if (webkit) { window.scrollTo(null, oldScrollY); }\n  display.input.reset();\n  // Adds \"Select all\" to context menu in FF\n  if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\n  input.contextMenuPending = true;\n  display.selForContextMenu = cm.doc.sel;\n  clearTimeout(display.detectingSelectAll);\n\n  // Select-all will be greyed out if there's nothing to select, so\n  // this adds a zero-width space so that we can later check whether\n  // it got selected.\n  function prepareSelectAllHack() {\n    if (te.selectionStart != null) {\n      var selected = cm.somethingSelected();\n      var extval = \"\\u200b\" + (selected ? te.value : \"\");\n      te.value = \"\\u21da\"; // Used to catch context-menu undo\n      te.value = extval;\n      input.prevInput = selected ? \"\" : \"\\u200b\";\n      te.selectionStart = 1; te.selectionEnd = extval.length;\n      // Re-set this, in case some other handler touched the\n      // selection in the meantime.\n      display.selForContextMenu = cm.doc.sel;\n    }\n  }\n  function rehide() {\n    input.contextMenuPending = false;\n    input.wrapper.style.cssText = oldWrapperCSS;\n    te.style.cssText = oldCSS;\n    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\n\n    // Try to detect the user choosing select-all\n    if (te.selectionStart != null) {\n      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\n      var i = 0, poll = function () {\n        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n            te.selectionEnd > 0 && input.prevInput == \"\\u200b\") {\n          operation(cm, selectAll)(cm);\n        } else if (i++ < 10) {\n          display.detectingSelectAll = setTimeout(poll, 500);\n        } else {\n          display.selForContextMenu = null;\n          display.input.reset();\n        }\n      };\n      display.detectingSelectAll = setTimeout(poll, 200);\n    }\n  }\n\n  if (ie && ie_version >= 9) { prepareSelectAllHack(); }\n  if (captureRightClick) {\n    e_stop(e);\n    var mouseup = function () {\n      off(window, \"mouseup\", mouseup);\n      setTimeout(rehide, 20);\n    };\n    on(window, \"mouseup\", mouseup);\n  } else {\n    setTimeout(rehide, 50);\n  }\n};\n\nTextareaInput.prototype.readOnlyChanged = function (val) {\n  if (!val) { this.reset(); }\n  this.textarea.disabled = val == \"nocursor\";\n};\n\nTextareaInput.prototype.setUneditable = function () {};\n\nTextareaInput.prototype.needsContentAttribute = false;\n\nfunction fromTextArea(textarea, options) {\n  options = options ? copyObj(options) : {};\n  options.value = textarea.value;\n  if (!options.tabindex && textarea.tabIndex)\n    { options.tabindex = textarea.tabIndex; }\n  if (!options.placeholder && textarea.placeholder)\n    { options.placeholder = textarea.placeholder; }\n  // Set autofocus to true if this textarea is focused, or if it has\n  // autofocus and no other element is focused.\n  if (options.autofocus == null) {\n    var hasFocus = activeElt();\n    options.autofocus = hasFocus == textarea ||\n      textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n  }\n\n  function save() {textarea.value = cm.getValue();}\n\n  var realSubmit;\n  if (textarea.form) {\n    on(textarea.form, \"submit\", save);\n    // Deplorable hack to make the submit method do the right thing.\n    if (!options.leaveSubmitMethodAlone) {\n      var form = textarea.form;\n      realSubmit = form.submit;\n      try {\n        var wrappedSubmit = form.submit = function () {\n          save();\n          form.submit = realSubmit;\n          form.submit();\n          form.submit = wrappedSubmit;\n        };\n      } catch(e) {}\n    }\n  }\n\n  options.finishInit = function (cm) {\n    cm.save = save;\n    cm.getTextArea = function () { return textarea; };\n    cm.toTextArea = function () {\n      cm.toTextArea = isNaN; // Prevent this from being ran twice\n      save();\n      textarea.parentNode.removeChild(cm.getWrapperElement());\n      textarea.style.display = \"\";\n      if (textarea.form) {\n        off(textarea.form, \"submit\", save);\n        if (typeof textarea.form.submit == \"function\")\n          { textarea.form.submit = realSubmit; }\n      }\n    };\n  };\n\n  textarea.style.display = \"none\";\n  var cm = CodeMirror$1(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\n    options);\n  return cm\n}\n\nfunction addLegacyProps(CodeMirror) {\n  CodeMirror.off = off;\n  CodeMirror.on = on;\n  CodeMirror.wheelEventPixels = wheelEventPixels;\n  CodeMirror.Doc = Doc;\n  CodeMirror.splitLines = splitLinesAuto;\n  CodeMirror.countColumn = countColumn;\n  CodeMirror.findColumn = findColumn;\n  CodeMirror.isWordChar = isWordCharBasic;\n  CodeMirror.Pass = Pass;\n  CodeMirror.signal = signal;\n  CodeMirror.Line = Line;\n  CodeMirror.changeEnd = changeEnd;\n  CodeMirror.scrollbarModel = scrollbarModel;\n  CodeMirror.Pos = Pos;\n  CodeMirror.cmpPos = cmp;\n  CodeMirror.modes = modes;\n  CodeMirror.mimeModes = mimeModes;\n  CodeMirror.resolveMode = resolveMode;\n  CodeMirror.getMode = getMode;\n  CodeMirror.modeExtensions = modeExtensions;\n  CodeMirror.extendMode = extendMode;\n  CodeMirror.copyState = copyState;\n  CodeMirror.startState = startState;\n  CodeMirror.innerMode = innerMode;\n  CodeMirror.commands = commands;\n  CodeMirror.keyMap = keyMap;\n  CodeMirror.keyName = keyName;\n  CodeMirror.isModifierKey = isModifierKey;\n  CodeMirror.lookupKey = lookupKey;\n  CodeMirror.normalizeKeyMap = normalizeKeyMap;\n  CodeMirror.StringStream = StringStream;\n  CodeMirror.SharedTextMarker = SharedTextMarker;\n  CodeMirror.TextMarker = TextMarker;\n  CodeMirror.LineWidget = LineWidget;\n  CodeMirror.e_preventDefault = e_preventDefault;\n  CodeMirror.e_stopPropagation = e_stopPropagation;\n  CodeMirror.e_stop = e_stop;\n  CodeMirror.addClass = addClass;\n  CodeMirror.contains = contains;\n  CodeMirror.rmClass = rmClass;\n  CodeMirror.keyNames = keyNames;\n}\n\n// EDITOR CONSTRUCTOR\n\ndefineOptions(CodeMirror$1);\n\naddEditorMethods(CodeMirror$1);\n\n// Set up methods on CodeMirror's prototype to redirect to the editor's document.\nvar dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\nfor (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n  { CodeMirror$1.prototype[prop] = (function(method) {\n    return function() {return method.apply(this.doc, arguments)}\n  })(Doc.prototype[prop]); } }\n\neventMixin(Doc);\n\n// INPUT HANDLING\n\nCodeMirror$1.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n// MODE DEFINITION AND QUERYING\n\n// Extra arguments are stored as the mode's dependencies, which is\n// used by (legacy) mechanisms like loadmode.js to automatically\n// load a mode. (Preferred mechanism is the require/define calls.)\nCodeMirror$1.defineMode = function(name/*, mode, …*/) {\n  if (!CodeMirror$1.defaults.mode && name != \"null\") { CodeMirror$1.defaults.mode = name; }\n  defineMode.apply(this, arguments);\n};\n\nCodeMirror$1.defineMIME = defineMIME;\n\n// Minimal default mode.\nCodeMirror$1.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\nCodeMirror$1.defineMIME(\"text/plain\", \"null\");\n\n// EXTENSIONS\n\nCodeMirror$1.defineExtension = function (name, func) {\n  CodeMirror$1.prototype[name] = func;\n};\nCodeMirror$1.defineDocExtension = function (name, func) {\n  Doc.prototype[name] = func;\n};\n\nCodeMirror$1.fromTextArea = fromTextArea;\n\naddLegacyProps(CodeMirror$1);\n\nCodeMirror$1.version = \"5.28.0\";\n\nreturn CodeMirror$1;\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/lib/codemirror.js\n// module id = 144\n// module chunks = 3","/**\n * Super simple wysiwyg editor v0.8.1\n * http://summernote.org/\n *\n * summernote.js\n * Copyright 2013-2015 Alan Hong. and other contributors\n * summernote may be freely distributed under the MIT license./\n *\n * Date: 2016-05-26T08:13Z\n */\n(function (factory) {\n  /* global define */\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['jquery'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // Node/CommonJS\n    module.exports = factory(require('jquery'));\n  } else {\n    // Browser globals\n    factory(window.jQuery);\n  }\n}(function ($) {\n  'use strict';\n\n  /**\n   * @class core.func\n   *\n   * func utils (for high-order func's arg)\n   *\n   * @singleton\n   * @alternateClassName func\n   */\n  var func = (function () {\n    var eq = function (itemA) {\n      return function (itemB) {\n        return itemA === itemB;\n      };\n    };\n\n    var eq2 = function (itemA, itemB) {\n      return itemA === itemB;\n    };\n\n    var peq2 = function (propName) {\n      return function (itemA, itemB) {\n        return itemA[propName] === itemB[propName];\n      };\n    };\n\n    var ok = function () {\n      return true;\n    };\n\n    var fail = function () {\n      return false;\n    };\n\n    var not = function (f) {\n      return function () {\n        return !f.apply(f, arguments);\n      };\n    };\n\n    var and = function (fA, fB) {\n      return function (item) {\n        return fA(item) && fB(item);\n      };\n    };\n\n    var self = function (a) {\n      return a;\n    };\n\n    var invoke = function (obj, method) {\n      return function () {\n        return obj[method].apply(obj, arguments);\n      };\n    };\n\n    var idCounter = 0;\n\n    /**\n     * generate a globally-unique id\n     *\n     * @param {String} [prefix]\n     */\n    var uniqueId = function (prefix) {\n      var id = ++idCounter + '';\n      return prefix ? prefix + id : id;\n    };\n\n    /**\n     * returns bnd (bounds) from rect\n     *\n     * - IE Compatibility Issue: http://goo.gl/sRLOAo\n     * - Scroll Issue: http://goo.gl/sNjUc\n     *\n     * @param {Rect} rect\n     * @return {Object} bounds\n     * @return {Number} bounds.top\n     * @return {Number} bounds.left\n     * @return {Number} bounds.width\n     * @return {Number} bounds.height\n     */\n    var rect2bnd = function (rect) {\n      var $document = $(document);\n      return {\n        top: rect.top + $document.scrollTop(),\n        left: rect.left + $document.scrollLeft(),\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top\n      };\n    };\n\n    /**\n     * returns a copy of the object where the keys have become the values and the values the keys.\n     * @param {Object} obj\n     * @return {Object}\n     */\n    var invertObject = function (obj) {\n      var inverted = {};\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          inverted[obj[key]] = key;\n        }\n      }\n      return inverted;\n    };\n\n    /**\n     * @param {String} namespace\n     * @param {String} [prefix]\n     * @return {String}\n     */\n    var namespaceToCamel = function (namespace, prefix) {\n      prefix = prefix || '';\n      return prefix + namespace.split('.').map(function (name) {\n        return name.substring(0, 1).toUpperCase() + name.substring(1);\n      }).join('');\n    };\n\n    return {\n      eq: eq,\n      eq2: eq2,\n      peq2: peq2,\n      ok: ok,\n      fail: fail,\n      self: self,\n      not: not,\n      and: and,\n      invoke: invoke,\n      uniqueId: uniqueId,\n      rect2bnd: rect2bnd,\n      invertObject: invertObject,\n      namespaceToCamel: namespaceToCamel\n    };\n  })();\n\n  /**\n   * @class core.list\n   *\n   * list utils\n   *\n   * @singleton\n   * @alternateClassName list\n   */\n  var list = (function () {\n    /**\n     * returns the first item of an array.\n     *\n     * @param {Array} array\n     */\n    var head = function (array) {\n      return array[0];\n    };\n\n    /**\n     * returns the last item of an array.\n     *\n     * @param {Array} array\n     */\n    var last = function (array) {\n      return array[array.length - 1];\n    };\n\n    /**\n     * returns everything but the last entry of the array.\n     *\n     * @param {Array} array\n     */\n    var initial = function (array) {\n      return array.slice(0, array.length - 1);\n    };\n\n    /**\n     * returns the rest of the items in an array.\n     *\n     * @param {Array} array\n     */\n    var tail = function (array) {\n      return array.slice(1);\n    };\n\n    /**\n     * returns item of array\n     */\n    var find = function (array, pred) {\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        var item = array[idx];\n        if (pred(item)) {\n          return item;\n        }\n      }\n    };\n\n    /**\n     * returns true if all of the values in the array pass the predicate truth test.\n     */\n    var all = function (array, pred) {\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (!pred(array[idx])) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    /**\n     * returns index of item\n     */\n    var indexOf = function (array, item) {\n      return $.inArray(item, array);\n    };\n\n    /**\n     * returns true if the value is present in the list.\n     */\n    var contains = function (array, item) {\n      return indexOf(array, item) !== -1;\n    };\n\n    /**\n     * get sum from a list\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - iterator\n     */\n    var sum = function (array, fn) {\n      fn = fn || func.self;\n      return array.reduce(function (memo, v) {\n        return memo + fn(v);\n      }, 0);\n    };\n  \n    /**\n     * returns a copy of the collection with array type.\n     * @param {Collection} collection - collection eg) node.childNodes, ...\n     */\n    var from = function (collection) {\n      var result = [], idx = -1, length = collection.length;\n      while (++idx < length) {\n        result[idx] = collection[idx];\n      }\n      return result;\n    };\n\n    /**\n     * returns whether list is empty or not\n     */\n    var isEmpty = function (array) {\n      return !array || !array.length;\n    };\n  \n    /**\n     * cluster elements by predicate function.\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - predicate function for cluster rule\n     * @param {Array[]}\n     */\n    var clusterBy = function (array, fn) {\n      if (!array.length) { return []; }\n      var aTail = tail(array);\n      return aTail.reduce(function (memo, v) {\n        var aLast = last(memo);\n        if (fn(last(aLast), v)) {\n          aLast[aLast.length] = v;\n        } else {\n          memo[memo.length] = [v];\n        }\n        return memo;\n      }, [[head(array)]]);\n    };\n  \n    /**\n     * returns a copy of the array with all falsy values removed\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - predicate function for cluster rule\n     */\n    var compact = function (array) {\n      var aResult = [];\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (array[idx]) { aResult.push(array[idx]); }\n      }\n      return aResult;\n    };\n\n    /**\n     * produces a duplicate-free version of the array\n     *\n     * @param {Array} array\n     */\n    var unique = function (array) {\n      var results = [];\n\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (!contains(results, array[idx])) {\n          results.push(array[idx]);\n        }\n      }\n\n      return results;\n    };\n\n    /**\n     * returns next item.\n     * @param {Array} array\n     */\n    var next = function (array, item) {\n      var idx = indexOf(array, item);\n      if (idx === -1) { return null; }\n\n      return array[idx + 1];\n    };\n\n    /**\n     * returns prev item.\n     * @param {Array} array\n     */\n    var prev = function (array, item) {\n      var idx = indexOf(array, item);\n      if (idx === -1) { return null; }\n\n      return array[idx - 1];\n    };\n\n    return { head: head, last: last, initial: initial, tail: tail,\n             prev: prev, next: next, find: find, contains: contains,\n             all: all, sum: sum, from: from, isEmpty: isEmpty,\n             clusterBy: clusterBy, compact: compact, unique: unique };\n  })();\n\n  var isSupportAmd = typeof define === 'function' && define.amd;\n\n  /**\n   * returns whether font is installed or not.\n   *\n   * @param {String} fontName\n   * @return {Boolean}\n   */\n  var isFontInstalled = function (fontName) {\n    var testFontName = fontName === 'Comic Sans MS' ? 'Courier New' : 'Comic Sans MS';\n    var $tester = $('<div>').css({\n      position: 'absolute',\n      left: '-9999px',\n      top: '-9999px',\n      fontSize: '200px'\n    }).text('mmmmmmmmmwwwwwww').appendTo(document.body);\n\n    var originalWidth = $tester.css('fontFamily', testFontName).width();\n    var width = $tester.css('fontFamily', fontName + ',' + testFontName).width();\n\n    $tester.remove();\n\n    return originalWidth !== width;\n  };\n\n  var userAgent = navigator.userAgent;\n  var isMSIE = /MSIE|Trident/i.test(userAgent);\n  var browserVersion;\n  if (isMSIE) {\n    var matches = /MSIE (\\d+[.]\\d+)/.exec(userAgent);\n    if (matches) {\n      browserVersion = parseFloat(matches[1]);\n    }\n    matches = /Trident\\/.*rv:([0-9]{1,}[\\.0-9]{0,})/.exec(userAgent);\n    if (matches) {\n      browserVersion = parseFloat(matches[1]);\n    }\n  }\n\n  var isEdge = /Edge\\/\\d+/.test(userAgent);\n\n  var hasCodeMirror = !!window.CodeMirror;\n  if (!hasCodeMirror && isSupportAmd) {\n    try {\n      // If CodeMirror can't be resolved, `require.resolve` will throw an\n      // exception and `hasCodeMirror` won't be set to `true`.\n      require.resolve('codemirror');\n      hasCodeMirror = true;\n    } catch (e) {\n      hasCodeMirror = false;\n    }\n  }\n\n  /**\n   * @class core.agent\n   *\n   * Object which check platform and agent\n   *\n   * @singleton\n   * @alternateClassName agent\n   */\n  var agent = {\n    isMac: navigator.appVersion.indexOf('Mac') > -1,\n    isMSIE: isMSIE,\n    isEdge: isEdge,\n    isFF: !isEdge && /firefox/i.test(userAgent),\n    isPhantom: /PhantomJS/i.test(userAgent),\n    isWebkit: !isEdge && /webkit/i.test(userAgent),\n    isChrome: !isEdge && /chrome/i.test(userAgent),\n    isSafari: !isEdge && /safari/i.test(userAgent),\n    browserVersion: browserVersion,\n    jqueryVersion: parseFloat($.fn.jquery),\n    isSupportAmd: isSupportAmd,\n    hasCodeMirror: hasCodeMirror,\n    isFontInstalled: isFontInstalled,\n    isW3CRangeSupport: !!document.createRange\n  };\n\n\n  var NBSP_CHAR = String.fromCharCode(160);\n  var ZERO_WIDTH_NBSP_CHAR = '\\ufeff';\n\n  /**\n   * @class core.dom\n   *\n   * Dom functions\n   *\n   * @singleton\n   * @alternateClassName dom\n   */\n  var dom = (function () {\n    /**\n     * @method isEditable\n     *\n     * returns whether node is `note-editable` or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isEditable = function (node) {\n      return node && $(node).hasClass('note-editable');\n    };\n\n    /**\n     * @method isControlSizing\n     *\n     * returns whether node is `note-control-sizing` or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isControlSizing = function (node) {\n      return node && $(node).hasClass('note-control-sizing');\n    };\n\n    /**\n     * @method makePredByNodeName\n     *\n     * returns predicate which judge whether nodeName is same\n     *\n     * @param {String} nodeName\n     * @return {Function}\n     */\n    var makePredByNodeName = function (nodeName) {\n      nodeName = nodeName.toUpperCase();\n      return function (node) {\n        return node && node.nodeName.toUpperCase() === nodeName;\n      };\n    };\n\n    /**\n     * @method isText\n     *\n     *\n     *\n     * @param {Node} node\n     * @return {Boolean} true if node's type is text(3)\n     */\n    var isText = function (node) {\n      return node && node.nodeType === 3;\n    };\n\n    /**\n     * @method isElement\n     *\n     *\n     *\n     * @param {Node} node\n     * @return {Boolean} true if node's type is element(1)\n     */\n    var isElement = function (node) {\n      return node && node.nodeType === 1;\n    };\n\n    /**\n     * ex) br, col, embed, hr, img, input, ...\n     * @see http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\n     */\n    var isVoid = function (node) {\n      return node && /^BR|^IMG|^HR|^IFRAME|^BUTTON/.test(node.nodeName.toUpperCase());\n    };\n\n    var isPara = function (node) {\n      if (isEditable(node)) {\n        return false;\n      }\n\n      // Chrome(v31.0), FF(v25.0.1) use DIV for paragraph\n      return node && /^DIV|^P|^LI|^H[1-7]/.test(node.nodeName.toUpperCase());\n    };\n\n    var isHeading = function (node) {\n      return node && /^H[1-7]/.test(node.nodeName.toUpperCase());\n    };\n\n    var isPre = makePredByNodeName('PRE');\n\n    var isLi = makePredByNodeName('LI');\n\n    var isPurePara = function (node) {\n      return isPara(node) && !isLi(node);\n    };\n\n    var isTable = makePredByNodeName('TABLE');\n\n    var isInline = function (node) {\n      return !isBodyContainer(node) &&\n             !isList(node) &&\n             !isHr(node) &&\n             !isPara(node) &&\n             !isTable(node) &&\n             !isBlockquote(node);\n    };\n\n    var isList = function (node) {\n      return node && /^UL|^OL/.test(node.nodeName.toUpperCase());\n    };\n\n    var isHr = makePredByNodeName('HR');\n\n    var isCell = function (node) {\n      return node && /^TD|^TH/.test(node.nodeName.toUpperCase());\n    };\n\n    var isBlockquote = makePredByNodeName('BLOCKQUOTE');\n\n    var isBodyContainer = function (node) {\n      return isCell(node) || isBlockquote(node) || isEditable(node);\n    };\n\n    var isAnchor = makePredByNodeName('A');\n\n    var isParaInline = function (node) {\n      return isInline(node) && !!ancestor(node, isPara);\n    };\n\n    var isBodyInline = function (node) {\n      return isInline(node) && !ancestor(node, isPara);\n    };\n\n    var isBody = makePredByNodeName('BODY');\n\n    /**\n     * returns whether nodeB is closest sibling of nodeA\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     * @return {Boolean}\n     */\n    var isClosestSibling = function (nodeA, nodeB) {\n      return nodeA.nextSibling === nodeB ||\n             nodeA.previousSibling === nodeB;\n    };\n\n    /**\n     * returns array of closest siblings with node\n     *\n     * @param {Node} node\n     * @param {function} [pred] - predicate function\n     * @return {Node[]}\n     */\n    var withClosestSiblings = function (node, pred) {\n      pred = pred || func.ok;\n\n      var siblings = [];\n      if (node.previousSibling && pred(node.previousSibling)) {\n        siblings.push(node.previousSibling);\n      }\n      siblings.push(node);\n      if (node.nextSibling && pred(node.nextSibling)) {\n        siblings.push(node.nextSibling);\n      }\n      return siblings;\n    };\n\n    /**\n     * blank HTML for cursor position\n     * - [workaround] old IE only works with &nbsp;\n     * - [workaround] IE11 and other browser works with bogus br\n     */\n    var blankHTML = agent.isMSIE && agent.browserVersion < 11 ? '&nbsp;' : '<br>';\n\n    /**\n     * @method nodeLength\n     *\n     * returns #text's text size or element's childNodes size\n     *\n     * @param {Node} node\n     */\n    var nodeLength = function (node) {\n      if (isText(node)) {\n        return node.nodeValue.length;\n      }\n\n      return node.childNodes.length;\n    };\n\n    /**\n     * returns whether node is empty or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isEmpty = function (node) {\n      var len = nodeLength(node);\n\n      if (len === 0) {\n        return true;\n      } else if (!isText(node) && len === 1 && node.innerHTML === blankHTML) {\n        // ex) <p><br></p>, <span><br></span>\n        return true;\n      } else if (list.all(node.childNodes, isText) && node.innerHTML === '') {\n        // ex) <p></p>, <span></span>\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * padding blankHTML if node is empty (for cursor position)\n     */\n    var paddingBlankHTML = function (node) {\n      if (!isVoid(node) && !nodeLength(node)) {\n        node.innerHTML = blankHTML;\n      }\n    };\n\n    /**\n     * find nearest ancestor predicate hit\n     *\n     * @param {Node} node\n     * @param {Function} pred - predicate function\n     */\n    var ancestor = function (node, pred) {\n      while (node) {\n        if (pred(node)) { return node; }\n        if (isEditable(node)) { break; }\n\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    /**\n     * find nearest ancestor only single child blood line and predicate hit\n     *\n     * @param {Node} node\n     * @param {Function} pred - predicate function\n     */\n    var singleChildAncestor = function (node, pred) {\n      node = node.parentNode;\n\n      while (node) {\n        if (nodeLength(node) !== 1) { break; }\n        if (pred(node)) { return node; }\n        if (isEditable(node)) { break; }\n\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    /**\n     * returns new array of ancestor nodes (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [optional] pred - predicate function\n     */\n    var listAncestor = function (node, pred) {\n      pred = pred || func.fail;\n\n      var ancestors = [];\n      ancestor(node, function (el) {\n        if (!isEditable(el)) {\n          ancestors.push(el);\n        }\n\n        return pred(el);\n      });\n      return ancestors;\n    };\n\n    /**\n     * find farthest ancestor predicate hit\n     */\n    var lastAncestor = function (node, pred) {\n      var ancestors = listAncestor(node);\n      return list.last(ancestors.filter(pred));\n    };\n\n    /**\n     * returns common ancestor node between two nodes.\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     */\n    var commonAncestor = function (nodeA, nodeB) {\n      var ancestors = listAncestor(nodeA);\n      for (var n = nodeB; n; n = n.parentNode) {\n        if ($.inArray(n, ancestors) > -1) { return n; }\n      }\n      return null; // difference document area\n    };\n\n    /**\n     * listing all previous siblings (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [optional] pred - predicate function\n     */\n    var listPrev = function (node, pred) {\n      pred = pred || func.fail;\n\n      var nodes = [];\n      while (node) {\n        if (pred(node)) { break; }\n        nodes.push(node);\n        node = node.previousSibling;\n      }\n      return nodes;\n    };\n\n    /**\n     * listing next siblings (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [pred] - predicate function\n     */\n    var listNext = function (node, pred) {\n      pred = pred || func.fail;\n\n      var nodes = [];\n      while (node) {\n        if (pred(node)) { break; }\n        nodes.push(node);\n        node = node.nextSibling;\n      }\n      return nodes;\n    };\n\n    /**\n     * listing descendant nodes\n     *\n     * @param {Node} node\n     * @param {Function} [pred] - predicate function\n     */\n    var listDescendant = function (node, pred) {\n      var descendants = [];\n      pred = pred || func.ok;\n\n      // start DFS(depth first search) with node\n      (function fnWalk(current) {\n        if (node !== current && pred(current)) {\n          descendants.push(current);\n        }\n        for (var idx = 0, len = current.childNodes.length; idx < len; idx++) {\n          fnWalk(current.childNodes[idx]);\n        }\n      })(node);\n\n      return descendants;\n    };\n\n    /**\n     * wrap node with new tag.\n     *\n     * @param {Node} node\n     * @param {Node} tagName of wrapper\n     * @return {Node} - wrapper\n     */\n    var wrap = function (node, wrapperName) {\n      var parent = node.parentNode;\n      var wrapper = $('<' + wrapperName + '>')[0];\n\n      parent.insertBefore(wrapper, node);\n      wrapper.appendChild(node);\n\n      return wrapper;\n    };\n\n    /**\n     * insert node after preceding\n     *\n     * @param {Node} node\n     * @param {Node} preceding - predicate function\n     */\n    var insertAfter = function (node, preceding) {\n      var next = preceding.nextSibling, parent = preceding.parentNode;\n      if (next) {\n        parent.insertBefore(node, next);\n      } else {\n        parent.appendChild(node);\n      }\n      return node;\n    };\n\n    /**\n     * append elements.\n     *\n     * @param {Node} node\n     * @param {Collection} aChild\n     */\n    var appendChildNodes = function (node, aChild) {\n      $.each(aChild, function (idx, child) {\n        node.appendChild(child);\n      });\n      return node;\n    };\n\n    /**\n     * returns whether boundaryPoint is left edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isLeftEdgePoint = function (point) {\n      return point.offset === 0;\n    };\n\n    /**\n     * returns whether boundaryPoint is right edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isRightEdgePoint = function (point) {\n      return point.offset === nodeLength(point.node);\n    };\n\n    /**\n     * returns whether boundaryPoint is edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isEdgePoint = function (point) {\n      return isLeftEdgePoint(point) || isRightEdgePoint(point);\n    };\n\n    /**\n     * returns whether node is left edge of ancestor or not.\n     *\n     * @param {Node} node\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isLeftEdgeOf = function (node, ancestor) {\n      while (node && node !== ancestor) {\n        if (position(node) !== 0) {\n          return false;\n        }\n        node = node.parentNode;\n      }\n\n      return true;\n    };\n\n    /**\n     * returns whether node is right edge of ancestor or not.\n     *\n     * @param {Node} node\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isRightEdgeOf = function (node, ancestor) {\n      while (node && node !== ancestor) {\n        if (position(node) !== nodeLength(node.parentNode) - 1) {\n          return false;\n        }\n        node = node.parentNode;\n      }\n\n      return true;\n    };\n\n    /**\n     * returns whether point is left edge of ancestor or not.\n     * @param {BoundaryPoint} point\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isLeftEdgePointOf = function (point, ancestor) {\n      return isLeftEdgePoint(point) && isLeftEdgeOf(point.node, ancestor);\n    };\n\n    /**\n     * returns whether point is right edge of ancestor or not.\n     * @param {BoundaryPoint} point\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isRightEdgePointOf = function (point, ancestor) {\n      return isRightEdgePoint(point) && isRightEdgeOf(point.node, ancestor);\n    };\n\n    /**\n     * returns offset from parent.\n     *\n     * @param {Node} node\n     */\n    var position = function (node) {\n      var offset = 0;\n      while ((node = node.previousSibling)) {\n        offset += 1;\n      }\n      return offset;\n    };\n\n    var hasChildren = function (node) {\n      return !!(node && node.childNodes && node.childNodes.length);\n    };\n\n    /**\n     * returns previous boundaryPoint\n     *\n     * @param {BoundaryPoint} point\n     * @param {Boolean} isSkipInnerOffset\n     * @return {BoundaryPoint}\n     */\n    var prevPoint = function (point, isSkipInnerOffset) {\n      var node, offset;\n\n      if (point.offset === 0) {\n        if (isEditable(point.node)) {\n          return null;\n        }\n\n        node = point.node.parentNode;\n        offset = position(point.node);\n      } else if (hasChildren(point.node)) {\n        node = point.node.childNodes[point.offset - 1];\n        offset = nodeLength(node);\n      } else {\n        node = point.node;\n        offset = isSkipInnerOffset ? 0 : point.offset - 1;\n      }\n\n      return {\n        node: node,\n        offset: offset\n      };\n    };\n\n    /**\n     * returns next boundaryPoint\n     *\n     * @param {BoundaryPoint} point\n     * @param {Boolean} isSkipInnerOffset\n     * @return {BoundaryPoint}\n     */\n    var nextPoint = function (point, isSkipInnerOffset) {\n      var node, offset;\n\n      if (nodeLength(point.node) === point.offset) {\n        if (isEditable(point.node)) {\n          return null;\n        }\n\n        node = point.node.parentNode;\n        offset = position(point.node) + 1;\n      } else if (hasChildren(point.node)) {\n        node = point.node.childNodes[point.offset];\n        offset = 0;\n      } else {\n        node = point.node;\n        offset = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;\n      }\n\n      return {\n        node: node,\n        offset: offset\n      };\n    };\n\n    /**\n     * returns whether pointA and pointB is same or not.\n     *\n     * @param {BoundaryPoint} pointA\n     * @param {BoundaryPoint} pointB\n     * @return {Boolean}\n     */\n    var isSamePoint = function (pointA, pointB) {\n      return pointA.node === pointB.node && pointA.offset === pointB.offset;\n    };\n\n    /**\n     * returns whether point is visible (can set cursor) or not.\n     * \n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isVisiblePoint = function (point) {\n      if (isText(point.node) || !hasChildren(point.node) || isEmpty(point.node)) {\n        return true;\n      }\n\n      var leftNode = point.node.childNodes[point.offset - 1];\n      var rightNode = point.node.childNodes[point.offset];\n      if ((!leftNode || isVoid(leftNode)) && (!rightNode || isVoid(rightNode))) {\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * @method prevPointUtil\n     *\n     * @param {BoundaryPoint} point\n     * @param {Function} pred\n     * @return {BoundaryPoint}\n     */\n    var prevPointUntil = function (point, pred) {\n      while (point) {\n        if (pred(point)) {\n          return point;\n        }\n\n        point = prevPoint(point);\n      }\n\n      return null;\n    };\n\n    /**\n     * @method nextPointUntil\n     *\n     * @param {BoundaryPoint} point\n     * @param {Function} pred\n     * @return {BoundaryPoint}\n     */\n    var nextPointUntil = function (point, pred) {\n      while (point) {\n        if (pred(point)) {\n          return point;\n        }\n\n        point = nextPoint(point);\n      }\n\n      return null;\n    };\n\n    /**\n     * returns whether point has character or not.\n     *\n     * @param {Point} point\n     * @return {Boolean}\n     */\n    var isCharPoint = function (point) {\n      if (!isText(point.node)) {\n        return false;\n      }\n\n      var ch = point.node.nodeValue.charAt(point.offset - 1);\n      return ch && (ch !== ' ' && ch !== NBSP_CHAR);\n    };\n\n    /**\n     * @method walkPoint\n     *\n     * @param {BoundaryPoint} startPoint\n     * @param {BoundaryPoint} endPoint\n     * @param {Function} handler\n     * @param {Boolean} isSkipInnerOffset\n     */\n    var walkPoint = function (startPoint, endPoint, handler, isSkipInnerOffset) {\n      var point = startPoint;\n\n      while (point) {\n        handler(point);\n\n        if (isSamePoint(point, endPoint)) {\n          break;\n        }\n\n        var isSkipOffset = isSkipInnerOffset &&\n                           startPoint.node !== point.node &&\n                           endPoint.node !== point.node;\n        point = nextPoint(point, isSkipOffset);\n      }\n    };\n\n    /**\n     * @method makeOffsetPath\n     *\n     * return offsetPath(array of offset) from ancestor\n     *\n     * @param {Node} ancestor - ancestor node\n     * @param {Node} node\n     */\n    var makeOffsetPath = function (ancestor, node) {\n      var ancestors = listAncestor(node, func.eq(ancestor));\n      return ancestors.map(position).reverse();\n    };\n\n    /**\n     * @method fromOffsetPath\n     *\n     * return element from offsetPath(array of offset)\n     *\n     * @param {Node} ancestor - ancestor node\n     * @param {array} offsets - offsetPath\n     */\n    var fromOffsetPath = function (ancestor, offsets) {\n      var current = ancestor;\n      for (var i = 0, len = offsets.length; i < len; i++) {\n        if (current.childNodes.length <= offsets[i]) {\n          current = current.childNodes[current.childNodes.length - 1];\n        } else {\n          current = current.childNodes[offsets[i]];\n        }\n      }\n      return current;\n    };\n\n    /**\n     * @method splitNode\n     *\n     * split element or #text\n     *\n     * @param {BoundaryPoint} point\n     * @param {Object} [options]\n     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n     * @return {Node} right node of boundaryPoint\n     */\n    var splitNode = function (point, options) {\n      var isSkipPaddingBlankHTML = options && options.isSkipPaddingBlankHTML;\n      var isNotSplitEdgePoint = options && options.isNotSplitEdgePoint;\n\n      // edge case\n      if (isEdgePoint(point) && (isText(point.node) || isNotSplitEdgePoint)) {\n        if (isLeftEdgePoint(point)) {\n          return point.node;\n        } else if (isRightEdgePoint(point)) {\n          return point.node.nextSibling;\n        }\n      }\n\n      // split #text\n      if (isText(point.node)) {\n        return point.node.splitText(point.offset);\n      } else {\n        var childNode = point.node.childNodes[point.offset];\n        var clone = insertAfter(point.node.cloneNode(false), point.node);\n        appendChildNodes(clone, listNext(childNode));\n\n        if (!isSkipPaddingBlankHTML) {\n          paddingBlankHTML(point.node);\n          paddingBlankHTML(clone);\n        }\n\n        return clone;\n      }\n    };\n\n    /**\n     * @method splitTree\n     *\n     * split tree by point\n     *\n     * @param {Node} root - split root\n     * @param {BoundaryPoint} point\n     * @param {Object} [options]\n     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n     * @return {Node} right node of boundaryPoint\n     */\n    var splitTree = function (root, point, options) {\n      // ex) [#text, <span>, <p>]\n      var ancestors = listAncestor(point.node, func.eq(root));\n\n      if (!ancestors.length) {\n        return null;\n      } else if (ancestors.length === 1) {\n        return splitNode(point, options);\n      }\n\n      return ancestors.reduce(function (node, parent) {\n        if (node === point.node) {\n          node = splitNode(point, options);\n        }\n\n        return splitNode({\n          node: parent,\n          offset: node ? dom.position(node) : nodeLength(parent)\n        }, options);\n      });\n    };\n\n    /**\n     * split point\n     *\n     * @param {Point} point\n     * @param {Boolean} isInline\n     * @return {Object}\n     */\n    var splitPoint = function (point, isInline) {\n      // find splitRoot, container\n      //  - inline: splitRoot is a child of paragraph\n      //  - block: splitRoot is a child of bodyContainer\n      var pred = isInline ? isPara : isBodyContainer;\n      var ancestors = listAncestor(point.node, pred);\n      var topAncestor = list.last(ancestors) || point.node;\n\n      var splitRoot, container;\n      if (pred(topAncestor)) {\n        splitRoot = ancestors[ancestors.length - 2];\n        container = topAncestor;\n      } else {\n        splitRoot = topAncestor;\n        container = splitRoot.parentNode;\n      }\n\n      // if splitRoot is exists, split with splitTree\n      var pivot = splitRoot && splitTree(splitRoot, point, {\n        isSkipPaddingBlankHTML: isInline,\n        isNotSplitEdgePoint: isInline\n      });\n\n      // if container is point.node, find pivot with point.offset\n      if (!pivot && container === point.node) {\n        pivot = point.node.childNodes[point.offset];\n      }\n\n      return {\n        rightNode: pivot,\n        container: container\n      };\n    };\n\n    var create = function (nodeName) {\n      return document.createElement(nodeName);\n    };\n\n    var createText = function (text) {\n      return document.createTextNode(text);\n    };\n\n    /**\n     * @method remove\n     *\n     * remove node, (isRemoveChild: remove child or not)\n     *\n     * @param {Node} node\n     * @param {Boolean} isRemoveChild\n     */\n    var remove = function (node, isRemoveChild) {\n      if (!node || !node.parentNode) { return; }\n      if (node.removeNode) { return node.removeNode(isRemoveChild); }\n\n      var parent = node.parentNode;\n      if (!isRemoveChild) {\n        var nodes = [];\n        var i, len;\n        for (i = 0, len = node.childNodes.length; i < len; i++) {\n          nodes.push(node.childNodes[i]);\n        }\n\n        for (i = 0, len = nodes.length; i < len; i++) {\n          parent.insertBefore(nodes[i], node);\n        }\n      }\n\n      parent.removeChild(node);\n    };\n\n    /**\n     * @method removeWhile\n     *\n     * @param {Node} node\n     * @param {Function} pred\n     */\n    var removeWhile = function (node, pred) {\n      while (node) {\n        if (isEditable(node) || !pred(node)) {\n          break;\n        }\n\n        var parent = node.parentNode;\n        remove(node);\n        node = parent;\n      }\n    };\n\n    /**\n     * @method replace\n     *\n     * replace node with provided nodeName\n     *\n     * @param {Node} node\n     * @param {String} nodeName\n     * @return {Node} - new node\n     */\n    var replace = function (node, nodeName) {\n      if (node.nodeName.toUpperCase() === nodeName.toUpperCase()) {\n        return node;\n      }\n\n      var newNode = create(nodeName);\n\n      if (node.style.cssText) {\n        newNode.style.cssText = node.style.cssText;\n      }\n\n      appendChildNodes(newNode, list.from(node.childNodes));\n      insertAfter(newNode, node);\n      remove(node);\n\n      return newNode;\n    };\n\n    var isTextarea = makePredByNodeName('TEXTAREA');\n\n    /**\n     * @param {jQuery} $node\n     * @param {Boolean} [stripLinebreaks] - default: false\n     */\n    var value = function ($node, stripLinebreaks) {\n      var val = isTextarea($node[0]) ? $node.val() : $node.html();\n      if (stripLinebreaks) {\n        return val.replace(/[\\n\\r]/g, '');\n      }\n      return val;\n    };\n\n    /**\n     * @method html\n     *\n     * get the HTML contents of node\n     *\n     * @param {jQuery} $node\n     * @param {Boolean} [isNewlineOnBlock]\n     */\n    var html = function ($node, isNewlineOnBlock) {\n      var markup = value($node);\n\n      if (isNewlineOnBlock) {\n        var regexTag = /<(\\/?)(\\b(?!!)[^>\\s]*)(.*?)(\\s*\\/?>)/g;\n        markup = markup.replace(regexTag, function (match, endSlash, name) {\n          name = name.toUpperCase();\n          var isEndOfInlineContainer = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(name) &&\n                                       !!endSlash;\n          var isBlockNode = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(name);\n\n          return match + ((isEndOfInlineContainer || isBlockNode) ? '\\n' : '');\n        });\n        markup = $.trim(markup);\n      }\n\n      return markup;\n    };\n\n    var posFromPlaceholder = function (placeholder) {\n      var $placeholder = $(placeholder);\n      var pos = $placeholder.offset();\n      var height = $placeholder.outerHeight(true); // include margin\n\n      return {\n        left: pos.left,\n        top: pos.top + height\n      };\n    };\n\n    var attachEvents = function ($node, events) {\n      Object.keys(events).forEach(function (key) {\n        $node.on(key, events[key]);\n      });\n    };\n\n    var detachEvents = function ($node, events) {\n      Object.keys(events).forEach(function (key) {\n        $node.off(key, events[key]);\n      });\n    };\n\n    return {\n      /** @property {String} NBSP_CHAR */\n      NBSP_CHAR: NBSP_CHAR,\n      /** @property {String} ZERO_WIDTH_NBSP_CHAR */\n      ZERO_WIDTH_NBSP_CHAR: ZERO_WIDTH_NBSP_CHAR,\n      /** @property {String} blank */\n      blank: blankHTML,\n      /** @property {String} emptyPara */\n      emptyPara: '<p>' + blankHTML + '</p>',\n      makePredByNodeName: makePredByNodeName,\n      isEditable: isEditable,\n      isControlSizing: isControlSizing,\n      isText: isText,\n      isElement: isElement,\n      isVoid: isVoid,\n      isPara: isPara,\n      isPurePara: isPurePara,\n      isHeading: isHeading,\n      isInline: isInline,\n      isBlock: func.not(isInline),\n      isBodyInline: isBodyInline,\n      isBody: isBody,\n      isParaInline: isParaInline,\n      isPre: isPre,\n      isList: isList,\n      isTable: isTable,\n      isCell: isCell,\n      isBlockquote: isBlockquote,\n      isBodyContainer: isBodyContainer,\n      isAnchor: isAnchor,\n      isDiv: makePredByNodeName('DIV'),\n      isLi: isLi,\n      isBR: makePredByNodeName('BR'),\n      isSpan: makePredByNodeName('SPAN'),\n      isB: makePredByNodeName('B'),\n      isU: makePredByNodeName('U'),\n      isS: makePredByNodeName('S'),\n      isI: makePredByNodeName('I'),\n      isImg: makePredByNodeName('IMG'),\n      isTextarea: isTextarea,\n      isEmpty: isEmpty,\n      isEmptyAnchor: func.and(isAnchor, isEmpty),\n      isClosestSibling: isClosestSibling,\n      withClosestSiblings: withClosestSiblings,\n      nodeLength: nodeLength,\n      isLeftEdgePoint: isLeftEdgePoint,\n      isRightEdgePoint: isRightEdgePoint,\n      isEdgePoint: isEdgePoint,\n      isLeftEdgeOf: isLeftEdgeOf,\n      isRightEdgeOf: isRightEdgeOf,\n      isLeftEdgePointOf: isLeftEdgePointOf,\n      isRightEdgePointOf: isRightEdgePointOf,\n      prevPoint: prevPoint,\n      nextPoint: nextPoint,\n      isSamePoint: isSamePoint,\n      isVisiblePoint: isVisiblePoint,\n      prevPointUntil: prevPointUntil,\n      nextPointUntil: nextPointUntil,\n      isCharPoint: isCharPoint,\n      walkPoint: walkPoint,\n      ancestor: ancestor,\n      singleChildAncestor: singleChildAncestor,\n      listAncestor: listAncestor,\n      lastAncestor: lastAncestor,\n      listNext: listNext,\n      listPrev: listPrev,\n      listDescendant: listDescendant,\n      commonAncestor: commonAncestor,\n      wrap: wrap,\n      insertAfter: insertAfter,\n      appendChildNodes: appendChildNodes,\n      position: position,\n      hasChildren: hasChildren,\n      makeOffsetPath: makeOffsetPath,\n      fromOffsetPath: fromOffsetPath,\n      splitTree: splitTree,\n      splitPoint: splitPoint,\n      create: create,\n      createText: createText,\n      remove: remove,\n      removeWhile: removeWhile,\n      replace: replace,\n      html: html,\n      value: value,\n      posFromPlaceholder: posFromPlaceholder,\n      attachEvents: attachEvents,\n      detachEvents: detachEvents\n    };\n  })();\n\n  /**\n   * @param {jQuery} $note\n   * @param {Object} options\n   * @return {Context}\n   */\n  var Context = function ($note, options) {\n    var self = this;\n\n    var ui = $.summernote.ui;\n    this.memos = {};\n    this.modules = {};\n    this.layoutInfo = {};\n    this.options = options;\n\n    /**\n     * create layout and initialize modules and other resources\n     */\n    this.initialize = function () {\n      this.layoutInfo = ui.createLayout($note, options);\n      this._initialize();\n      $note.hide();\n      return this;\n    };\n\n    /**\n     * destroy modules and other resources and remove layout\n     */\n    this.destroy = function () {\n      this._destroy();\n      $note.removeData('summernote');\n      ui.removeLayout($note, this.layoutInfo);\n    };\n\n    /**\n     * destory modules and other resources and initialize it again\n     */\n    this.reset = function () {\n      var disabled = self.isDisabled();\n      this.code(dom.emptyPara);\n      this._destroy();\n      this._initialize();\n\n      if (disabled) {\n        self.disable();\n      }\n    };\n\n    this._initialize = function () {\n      // add optional buttons\n      var buttons = $.extend({}, this.options.buttons);\n      Object.keys(buttons).forEach(function (key) {\n        self.memo('button.' + key, buttons[key]);\n      });\n\n      var modules = $.extend({}, this.options.modules, $.summernote.plugins || {});\n\n      // add and initialize modules\n      Object.keys(modules).forEach(function (key) {\n        self.module(key, modules[key], true);\n      });\n\n      Object.keys(this.modules).forEach(function (key) {\n        self.initializeModule(key);\n      });\n    };\n\n    this._destroy = function () {\n      // destroy modules with reversed order\n      Object.keys(this.modules).reverse().forEach(function (key) {\n        self.removeModule(key);\n      });\n\n      Object.keys(this.memos).forEach(function (key) {\n        self.removeMemo(key);\n      });\n    };\n\n    this.code = function (html) {\n      var isActivated = this.invoke('codeview.isActivated');\n\n      if (html === undefined) {\n        this.invoke('codeview.sync');\n        return isActivated ? this.layoutInfo.codable.val() : this.layoutInfo.editable.html();\n      } else {\n        if (isActivated) {\n          this.layoutInfo.codable.val(html);\n        } else {\n          this.layoutInfo.editable.html(html);\n        }\n        $note.val(html);\n        this.triggerEvent('change', html);\n      }\n    };\n\n    this.isDisabled = function () {\n      return this.layoutInfo.editable.attr('contenteditable') === 'false';\n    };\n\n    this.enable = function () {\n      this.layoutInfo.editable.attr('contenteditable', true);\n      this.invoke('toolbar.activate', true);\n    };\n\n    this.disable = function () {\n      // close codeview if codeview is opend\n      if (this.invoke('codeview.isActivated')) {\n        this.invoke('codeview.deactivate');\n      }\n      this.layoutInfo.editable.attr('contenteditable', false);\n      this.invoke('toolbar.deactivate', true);\n    };\n\n    this.triggerEvent = function () {\n      var namespace = list.head(arguments);\n      var args = list.tail(list.from(arguments));\n\n      var callback = this.options.callbacks[func.namespaceToCamel(namespace, 'on')];\n      if (callback) {\n        callback.apply($note[0], args);\n      }\n      $note.trigger('summernote.' + namespace, args);\n    };\n\n    this.initializeModule = function (key) {\n      var module = this.modules[key];\n      module.shouldInitialize = module.shouldInitialize || func.ok;\n      if (!module.shouldInitialize()) {\n        return;\n      }\n\n      // initialize module\n      if (module.initialize) {\n        module.initialize();\n      }\n\n      // attach events\n      if (module.events) {\n        dom.attachEvents($note, module.events);\n      }\n    };\n\n    this.module = function (key, ModuleClass, withoutIntialize) {\n      if (arguments.length === 1) {\n        return this.modules[key];\n      }\n\n      this.modules[key] = new ModuleClass(this);\n\n      if (!withoutIntialize) {\n        this.initializeModule(key);\n      }\n    };\n\n    this.removeModule = function (key) {\n      var module = this.modules[key];\n      if (module.shouldInitialize()) {\n        if (module.events) {\n          dom.detachEvents($note, module.events);\n        }\n\n        if (module.destroy) {\n          module.destroy();\n        }\n      }\n\n      delete this.modules[key];\n    };\n\n    this.memo = function (key, obj) {\n      if (arguments.length === 1) {\n        return this.memos[key];\n      }\n      this.memos[key] = obj;\n    };\n\n    this.removeMemo = function (key) {\n      if (this.memos[key] && this.memos[key].destroy) {\n        this.memos[key].destroy();\n      }\n\n      delete this.memos[key];\n    };\n\n    this.createInvokeHandler = function (namespace, value) {\n      return function (event) {\n        event.preventDefault();\n        self.invoke(namespace, value || $(event.target).closest('[data-value]').data('value'));\n      };\n    };\n\n    this.invoke = function () {\n      var namespace = list.head(arguments);\n      var args = list.tail(list.from(arguments));\n\n      var splits = namespace.split('.');\n      var hasSeparator = splits.length > 1;\n      var moduleName = hasSeparator && list.head(splits);\n      var methodName = hasSeparator ? list.last(splits) : list.head(splits);\n\n      var module = this.modules[moduleName || 'editor'];\n      if (!moduleName && this[methodName]) {\n        return this[methodName].apply(this, args);\n      } else if (module && module[methodName] && module.shouldInitialize()) {\n        return module[methodName].apply(module, args);\n      }\n    };\n\n    return this.initialize();\n  };\n\n  $.fn.extend({\n    /**\n     * Summernote API\n     *\n     * @param {Object|String}\n     * @return {this}\n     */\n    summernote: function () {\n      var type = $.type(list.head(arguments));\n      var isExternalAPICalled = type === 'string';\n      var hasInitOptions = type === 'object';\n\n      var options = hasInitOptions ? list.head(arguments) : {};\n\n      options = $.extend({}, $.summernote.options, options);\n      options.langInfo = $.extend(true, {}, $.summernote.lang['en-US'], $.summernote.lang[options.lang]);\n\n      this.each(function (idx, note) {\n        var $note = $(note);\n        if (!$note.data('summernote')) {\n          var context = new Context($note, options);\n          $note.data('summernote', context);\n          $note.data('summernote').triggerEvent('init', context.layoutInfo);\n        }\n      });\n\n      var $note = this.first();\n      if ($note.length) {\n        var context = $note.data('summernote');\n        if (isExternalAPICalled) {\n          return context.invoke.apply(context, list.from(arguments));\n        } else if (options.focus) {\n          context.invoke('editor.focus');\n        }\n      }\n\n      return this;\n    }\n  });\n\n\n  var Renderer = function (markup, children, options, callback) {\n    this.render = function ($parent) {\n      var $node = $(markup);\n\n      if (options && options.contents) {\n        $node.html(options.contents);\n      }\n\n      if (options && options.className) {\n        $node.addClass(options.className);\n      }\n\n      if (options && options.data) {\n        $.each(options.data, function (k, v) {\n          $node.attr('data-' + k, v);\n        });\n      }\n\n      if (options && options.click) {\n        $node.on('click', options.click);\n      }\n\n      if (children) {\n        var $container = $node.find('.note-children-container');\n        children.forEach(function (child) {\n          child.render($container.length ? $container : $node);\n        });\n      }\n\n      if (callback) {\n        callback($node, options);\n      }\n\n      if (options && options.callback) {\n        options.callback($node);\n      }\n\n      if ($parent) {\n        $parent.append($node);\n      }\n\n      return $node;\n    };\n  };\n\n  var renderer = {\n    create: function (markup, callback) {\n      return function () {\n        var children = $.isArray(arguments[0]) ? arguments[0] : [];\n        var options = typeof arguments[1] === 'object' ? arguments[1] : arguments[0];\n        if (options && options.children) {\n          children = options.children;\n        }\n        return new Renderer(markup, children, options, callback);\n      };\n    }\n  };\n\n  var editor = renderer.create('<div class=\"note-editor note-frame panel panel-default\"/>');\n  var toolbar = renderer.create('<div class=\"note-toolbar panel-heading\"/>');\n  var editingArea = renderer.create('<div class=\"note-editing-area\"/>');\n  var codable = renderer.create('<textarea class=\"note-codable\"/>');\n  var editable = renderer.create('<div class=\"note-editable panel-body\" contentEditable=\"true\"/>');\n  var statusbar = renderer.create([\n    '<div class=\"note-statusbar\">',\n    '  <div class=\"note-resizebar\">',\n    '    <div class=\"note-icon-bar\"/>',\n    '    <div class=\"note-icon-bar\"/>',\n    '    <div class=\"note-icon-bar\"/>',\n    '  </div>',\n    '</div>'\n  ].join(''));\n\n  var airEditor = renderer.create('<div class=\"note-editor\"/>');\n  var airEditable = renderer.create('<div class=\"note-editable\" contentEditable=\"true\"/>');\n\n  var buttonGroup = renderer.create('<div class=\"note-btn-group btn-group\">');\n  var button = renderer.create('<button type=\"button\" class=\"note-btn btn btn-default btn-sm\">', function ($node, options) {\n    if (options && options.tooltip) {\n      $node.attr({\n        title: options.tooltip\n      }).tooltip({\n        container: 'body',\n        trigger: 'hover',\n        placement: 'bottom'\n      });\n    }\n  });\n\n  var dropdown = renderer.create('<div class=\"dropdown-menu\">', function ($node, options) {\n    var markup = $.isArray(options.items) ? options.items.map(function (item) {\n      var value = (typeof item === 'string') ? item : (item.value || '');\n      var content = options.template ? options.template(item) : item;\n      return '<li><a href=\"#\" data-value=\"' + value + '\">' + content + '</a></li>';\n    }).join('') : options.items;\n\n    $node.html(markup);\n  });\n\n  var dropdownCheck = renderer.create('<div class=\"dropdown-menu note-check\">', function ($node, options) {\n    var markup = $.isArray(options.items) ? options.items.map(function (item) {\n      var value = (typeof item === 'string') ? item : (item.value || '');\n      var content = options.template ? options.template(item) : item;\n      return '<li><a href=\"#\" data-value=\"' + value + '\">' + icon(options.checkClassName) + ' ' + content + '</a></li>';\n    }).join('') : options.items;\n    $node.html(markup);\n  });\n\n  var palette = renderer.create('<div class=\"note-color-palette\"/>', function ($node, options) {\n    var contents = [];\n    for (var row = 0, rowSize = options.colors.length; row < rowSize; row++) {\n      var eventName = options.eventName;\n      var colors = options.colors[row];\n      var buttons = [];\n      for (var col = 0, colSize = colors.length; col < colSize; col++) {\n        var color = colors[col];\n        buttons.push([\n          '<button type=\"button\" class=\"note-color-btn\"',\n          'style=\"background-color:', color, '\" ',\n          'data-event=\"', eventName, '\" ',\n          'data-value=\"', color, '\" ',\n          'title=\"', color, '\" ',\n          'data-toggle=\"button\" tabindex=\"-1\"></button>'\n        ].join(''));\n      }\n      contents.push('<div class=\"note-color-row\">' + buttons.join('') + '</div>');\n    }\n    $node.html(contents.join(''));\n\n    $node.find('.note-color-btn').tooltip({\n      container: 'body',\n      trigger: 'hover',\n      placement: 'bottom'\n    });\n  });\n\n  var dialog = renderer.create('<div class=\"modal\" aria-hidden=\"false\" tabindex=\"-1\"/>', function ($node, options) {\n    if (options.fade) {\n      $node.addClass('fade');\n    }\n    $node.html([\n      '<div class=\"modal-dialog\">',\n      '  <div class=\"modal-content\">',\n      (options.title ?\n      '    <div class=\"modal-header\">' +\n      '      <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>' +\n      '      <h4 class=\"modal-title\">' + options.title + '</h4>' +\n      '    </div>' : ''\n      ),\n      '    <div class=\"modal-body\">' + options.body + '</div>',\n      (options.footer ?\n      '    <div class=\"modal-footer\">' + options.footer + '</div>' : ''\n      ),\n      '  </div>',\n      '</div>'\n    ].join(''));\n  });\n\n  var popover = renderer.create([\n    '<div class=\"note-popover popover in\">',\n    '  <div class=\"arrow\"/>',\n    '  <div class=\"popover-content note-children-container\"/>',\n    '</div>'\n  ].join(''), function ($node, options) {\n    var direction = typeof options.direction !== 'undefined' ? options.direction : 'bottom';\n\n    $node.addClass(direction);\n\n    if (options.hideArrow) {\n      $node.find('.arrow').hide();\n    }\n  });\n\n  var icon = function (iconClassName, tagName) {\n    tagName = tagName || 'i';\n    return '<' + tagName + ' class=\"' + iconClassName + '\"/>';\n  };\n\n  var ui = {\n    editor: editor,\n    toolbar: toolbar,\n    editingArea: editingArea,\n    codable: codable,\n    editable: editable,\n    statusbar: statusbar,\n    airEditor: airEditor,\n    airEditable: airEditable,\n    buttonGroup: buttonGroup,\n    button: button,\n    dropdown: dropdown,\n    dropdownCheck: dropdownCheck,\n    palette: palette,\n    dialog: dialog,\n    popover: popover,\n    icon: icon,\n\n    toggleBtn: function ($btn, isEnable) {\n      $btn.toggleClass('disabled', !isEnable);\n      $btn.attr('disabled', !isEnable);\n    },\n\n    toggleBtnActive: function ($btn, isActive) {\n      $btn.toggleClass('active', isActive);\n    },\n\n    onDialogShown: function ($dialog, handler) {\n      $dialog.one('shown.bs.modal', handler);\n    },\n\n    onDialogHidden: function ($dialog, handler) {\n      $dialog.one('hidden.bs.modal', handler);\n    },\n\n    showDialog: function ($dialog) {\n      $dialog.modal('show');\n    },\n\n    hideDialog: function ($dialog) {\n      $dialog.modal('hide');\n    },\n\n    createLayout: function ($note, options) {\n      var $editor = (options.airMode ? ui.airEditor([\n        ui.editingArea([\n          ui.airEditable()\n        ])\n      ]) : ui.editor([\n        ui.toolbar(),\n        ui.editingArea([\n          ui.codable(),\n          ui.editable()\n        ]),\n        ui.statusbar()\n      ])).render();\n\n      $editor.insertAfter($note);\n\n      return {\n        note: $note,\n        editor: $editor,\n        toolbar: $editor.find('.note-toolbar'),\n        editingArea: $editor.find('.note-editing-area'),\n        editable: $editor.find('.note-editable'),\n        codable: $editor.find('.note-codable'),\n        statusbar: $editor.find('.note-statusbar')\n      };\n    },\n\n    removeLayout: function ($note, layoutInfo) {\n      $note.html(layoutInfo.editable.html());\n      layoutInfo.editor.remove();\n      $note.show();\n    }\n  };\n\n  $.summernote = $.summernote || {\n    lang: {}\n  };\n\n  $.extend($.summernote.lang, {\n    'en-US': {\n      font: {\n        bold: 'Bold',\n        italic: 'Italic',\n        underline: 'Underline',\n        clear: 'Remove Font Style',\n        height: 'Line Height',\n        name: 'Font Family',\n        strikethrough: 'Strikethrough',\n        subscript: 'Subscript',\n        superscript: 'Superscript',\n        size: 'Font Size'\n      },\n      image: {\n        image: 'Picture',\n        insert: 'Insert Image',\n        resizeFull: 'Resize Full',\n        resizeHalf: 'Resize Half',\n        resizeQuarter: 'Resize Quarter',\n        floatLeft: 'Float Left',\n        floatRight: 'Float Right',\n        floatNone: 'Float None',\n        shapeRounded: 'Shape: Rounded',\n        shapeCircle: 'Shape: Circle',\n        shapeThumbnail: 'Shape: Thumbnail',\n        shapeNone: 'Shape: None',\n        dragImageHere: 'Drag image or text here',\n        dropImage: 'Drop image or Text',\n        selectFromFiles: 'Select from files',\n        maximumFileSize: 'Maximum file size',\n        maximumFileSizeError: 'Maximum file size exceeded.',\n        url: 'Image URL',\n        remove: 'Remove Image'\n      },\n      video: {\n        video: 'Video',\n        videoLink: 'Video Link',\n        insert: 'Insert Video',\n        url: 'Video URL?',\n        providers: '(YouTube, Vimeo, Vine, Instagram, DailyMotion or Youku)'\n      },\n      link: {\n        link: 'Link',\n        insert: 'Insert Link',\n        unlink: 'Unlink',\n        edit: 'Edit',\n        textToDisplay: 'Text to display',\n        url: 'To what URL should this link go?',\n        openInNewWindow: 'Open in new window'\n      },\n      table: {\n        table: 'Table'\n      },\n      hr: {\n        insert: 'Insert Horizontal Rule'\n      },\n      style: {\n        style: 'Style',\n        normal: 'Normal',\n        blockquote: 'Quote',\n        pre: 'Code',\n        h1: 'Header 1',\n        h2: 'Header 2',\n        h3: 'Header 3',\n        h4: 'Header 4',\n        h5: 'Header 5',\n        h6: 'Header 6'\n      },\n      lists: {\n        unordered: 'Unordered list',\n        ordered: 'Ordered list'\n      },\n      options: {\n        help: 'Help',\n        fullscreen: 'Full Screen',\n        codeview: 'Code View'\n      },\n      paragraph: {\n        paragraph: 'Paragraph',\n        outdent: 'Outdent',\n        indent: 'Indent',\n        left: 'Align left',\n        center: 'Align center',\n        right: 'Align right',\n        justify: 'Justify full'\n      },\n      color: {\n        recent: 'Recent Color',\n        more: 'More Color',\n        background: 'Background Color',\n        foreground: 'Foreground Color',\n        transparent: 'Transparent',\n        setTransparent: 'Set transparent',\n        reset: 'Reset',\n        resetToDefault: 'Reset to default'\n      },\n      shortcut: {\n        shortcuts: 'Keyboard shortcuts',\n        close: 'Close',\n        textFormatting: 'Text formatting',\n        action: 'Action',\n        paragraphFormatting: 'Paragraph formatting',\n        documentStyle: 'Document Style',\n        extraKeys: 'Extra keys'\n      },\n      help: {\n        'insertParagraph': 'Insert Paragraph',\n        'undo': 'Undoes the last command',\n        'redo': 'Redoes the last command',\n        'tab': 'Tab',\n        'untab': 'Untab',\n        'bold': 'Set a bold style',\n        'italic': 'Set a italic style',\n        'underline': 'Set a underline style',\n        'strikethrough': 'Set a strikethrough style',\n        'removeFormat': 'Clean a style',\n        'justifyLeft': 'Set left align',\n        'justifyCenter': 'Set center align',\n        'justifyRight': 'Set right align',\n        'justifyFull': 'Set full align',\n        'insertUnorderedList': 'Toggle unordered list',\n        'insertOrderedList': 'Toggle ordered list',\n        'outdent': 'Outdent on current paragraph',\n        'indent': 'Indent on current paragraph',\n        'formatPara': 'Change current block\\'s format as a paragraph(P tag)',\n        'formatH1': 'Change current block\\'s format as H1',\n        'formatH2': 'Change current block\\'s format as H2',\n        'formatH3': 'Change current block\\'s format as H3',\n        'formatH4': 'Change current block\\'s format as H4',\n        'formatH5': 'Change current block\\'s format as H5',\n        'formatH6': 'Change current block\\'s format as H6',\n        'insertHorizontalRule': 'Insert horizontal rule',\n        'linkDialog.show': 'Show Link Dialog'\n      },\n      history: {\n        undo: 'Undo',\n        redo: 'Redo'\n      },\n      specialChar: {\n        specialChar: 'SPECIAL CHARACTERS',\n        select: 'Select Special characters'\n      }\n    }\n  });\n\n\n  /**\n   * @class core.key\n   *\n   * Object for keycodes.\n   *\n   * @singleton\n   * @alternateClassName key\n   */\n  var key = (function () {\n    var keyMap = {\n      'BACKSPACE': 8,\n      'TAB': 9,\n      'ENTER': 13,\n      'SPACE': 32,\n\n      // Arrow\n      'LEFT': 37,\n      'UP': 38,\n      'RIGHT': 39,\n      'DOWN': 40,\n\n      // Number: 0-9\n      'NUM0': 48,\n      'NUM1': 49,\n      'NUM2': 50,\n      'NUM3': 51,\n      'NUM4': 52,\n      'NUM5': 53,\n      'NUM6': 54,\n      'NUM7': 55,\n      'NUM8': 56,\n\n      // Alphabet: a-z\n      'B': 66,\n      'E': 69,\n      'I': 73,\n      'J': 74,\n      'K': 75,\n      'L': 76,\n      'R': 82,\n      'S': 83,\n      'U': 85,\n      'V': 86,\n      'Y': 89,\n      'Z': 90,\n\n      'SLASH': 191,\n      'LEFTBRACKET': 219,\n      'BACKSLASH': 220,\n      'RIGHTBRACKET': 221\n    };\n\n    return {\n      /**\n       * @method isEdit\n       *\n       * @param {Number} keyCode\n       * @return {Boolean}\n       */\n      isEdit: function (keyCode) {\n        return list.contains([\n          keyMap.BACKSPACE,\n          keyMap.TAB,\n          keyMap.ENTER,\n          keyMap.SPACE\n        ], keyCode);\n      },\n      /**\n       * @method isMove\n       *\n       * @param {Number} keyCode\n       * @return {Boolean}\n       */\n      isMove: function (keyCode) {\n        return list.contains([\n          keyMap.LEFT,\n          keyMap.UP,\n          keyMap.RIGHT,\n          keyMap.DOWN\n        ], keyCode);\n      },\n      /**\n       * @property {Object} nameFromCode\n       * @property {String} nameFromCode.8 \"BACKSPACE\"\n       */\n      nameFromCode: func.invertObject(keyMap),\n      code: keyMap\n    };\n  })();\n\n  var range = (function () {\n\n    /**\n     * return boundaryPoint from TextRange, inspired by Andy Na's HuskyRange.js\n     *\n     * @param {TextRange} textRange\n     * @param {Boolean} isStart\n     * @return {BoundaryPoint}\n     *\n     * @see http://msdn.microsoft.com/en-us/library/ie/ms535872(v=vs.85).aspx\n     */\n    var textRangeToPoint = function (textRange, isStart) {\n      var container = textRange.parentElement(), offset;\n  \n      var tester = document.body.createTextRange(), prevContainer;\n      var childNodes = list.from(container.childNodes);\n      for (offset = 0; offset < childNodes.length; offset++) {\n        if (dom.isText(childNodes[offset])) {\n          continue;\n        }\n        tester.moveToElementText(childNodes[offset]);\n        if (tester.compareEndPoints('StartToStart', textRange) >= 0) {\n          break;\n        }\n        prevContainer = childNodes[offset];\n      }\n  \n      if (offset !== 0 && dom.isText(childNodes[offset - 1])) {\n        var textRangeStart = document.body.createTextRange(), curTextNode = null;\n        textRangeStart.moveToElementText(prevContainer || container);\n        textRangeStart.collapse(!prevContainer);\n        curTextNode = prevContainer ? prevContainer.nextSibling : container.firstChild;\n  \n        var pointTester = textRange.duplicate();\n        pointTester.setEndPoint('StartToStart', textRangeStart);\n        var textCount = pointTester.text.replace(/[\\r\\n]/g, '').length;\n  \n        while (textCount > curTextNode.nodeValue.length && curTextNode.nextSibling) {\n          textCount -= curTextNode.nodeValue.length;\n          curTextNode = curTextNode.nextSibling;\n        }\n  \n        /* jshint ignore:start */\n        var dummy = curTextNode.nodeValue; // enforce IE to re-reference curTextNode, hack\n        /* jshint ignore:end */\n  \n        if (isStart && curTextNode.nextSibling && dom.isText(curTextNode.nextSibling) &&\n            textCount === curTextNode.nodeValue.length) {\n          textCount -= curTextNode.nodeValue.length;\n          curTextNode = curTextNode.nextSibling;\n        }\n  \n        container = curTextNode;\n        offset = textCount;\n      }\n  \n      return {\n        cont: container,\n        offset: offset\n      };\n    };\n    \n    /**\n     * return TextRange from boundary point (inspired by google closure-library)\n     * @param {BoundaryPoint} point\n     * @return {TextRange}\n     */\n    var pointToTextRange = function (point) {\n      var textRangeInfo = function (container, offset) {\n        var node, isCollapseToStart;\n  \n        if (dom.isText(container)) {\n          var prevTextNodes = dom.listPrev(container, func.not(dom.isText));\n          var prevContainer = list.last(prevTextNodes).previousSibling;\n          node =  prevContainer || container.parentNode;\n          offset += list.sum(list.tail(prevTextNodes), dom.nodeLength);\n          isCollapseToStart = !prevContainer;\n        } else {\n          node = container.childNodes[offset] || container;\n          if (dom.isText(node)) {\n            return textRangeInfo(node, 0);\n          }\n  \n          offset = 0;\n          isCollapseToStart = false;\n        }\n  \n        return {\n          node: node,\n          collapseToStart: isCollapseToStart,\n          offset: offset\n        };\n      };\n  \n      var textRange = document.body.createTextRange();\n      var info = textRangeInfo(point.node, point.offset);\n  \n      textRange.moveToElementText(info.node);\n      textRange.collapse(info.collapseToStart);\n      textRange.moveStart('character', info.offset);\n      return textRange;\n    };\n    \n    /**\n     * Wrapped Range\n     *\n     * @constructor\n     * @param {Node} sc - start container\n     * @param {Number} so - start offset\n     * @param {Node} ec - end container\n     * @param {Number} eo - end offset\n     */\n    var WrappedRange = function (sc, so, ec, eo) {\n      this.sc = sc;\n      this.so = so;\n      this.ec = ec;\n      this.eo = eo;\n  \n      // nativeRange: get nativeRange from sc, so, ec, eo\n      var nativeRange = function () {\n        if (agent.isW3CRangeSupport) {\n          var w3cRange = document.createRange();\n          w3cRange.setStart(sc, so);\n          w3cRange.setEnd(ec, eo);\n\n          return w3cRange;\n        } else {\n          var textRange = pointToTextRange({\n            node: sc,\n            offset: so\n          });\n\n          textRange.setEndPoint('EndToEnd', pointToTextRange({\n            node: ec,\n            offset: eo\n          }));\n\n          return textRange;\n        }\n      };\n\n      this.getPoints = function () {\n        return {\n          sc: sc,\n          so: so,\n          ec: ec,\n          eo: eo\n        };\n      };\n\n      this.getStartPoint = function () {\n        return {\n          node: sc,\n          offset: so\n        };\n      };\n\n      this.getEndPoint = function () {\n        return {\n          node: ec,\n          offset: eo\n        };\n      };\n\n      /**\n       * select update visible range\n       */\n      this.select = function () {\n        var nativeRng = nativeRange();\n        if (agent.isW3CRangeSupport) {\n          var selection = document.getSelection();\n          if (selection.rangeCount > 0) {\n            selection.removeAllRanges();\n          }\n          selection.addRange(nativeRng);\n        } else {\n          nativeRng.select();\n        }\n        \n        return this;\n      };\n\n      /**\n       * Moves the scrollbar to start container(sc) of current range\n       *\n       * @return {WrappedRange}\n       */\n      this.scrollIntoView = function (container) {\n        var height = $(container).height();\n        if (container.scrollTop + height < this.sc.offsetTop) {\n          container.scrollTop += Math.abs(container.scrollTop + height - this.sc.offsetTop);\n        }\n\n        return this;\n      };\n\n      /**\n       * @return {WrappedRange}\n       */\n      this.normalize = function () {\n\n        /**\n         * @param {BoundaryPoint} point\n         * @param {Boolean} isLeftToRight\n         * @return {BoundaryPoint}\n         */\n        var getVisiblePoint = function (point, isLeftToRight) {\n          if ((dom.isVisiblePoint(point) && !dom.isEdgePoint(point)) ||\n              (dom.isVisiblePoint(point) && dom.isRightEdgePoint(point) && !isLeftToRight) ||\n              (dom.isVisiblePoint(point) && dom.isLeftEdgePoint(point) && isLeftToRight) ||\n              (dom.isVisiblePoint(point) && dom.isBlock(point.node) && dom.isEmpty(point.node))) {\n            return point;\n          }\n\n          // point on block's edge\n          var block = dom.ancestor(point.node, dom.isBlock);\n          if (((dom.isLeftEdgePointOf(point, block) || dom.isVoid(dom.prevPoint(point).node)) && !isLeftToRight) ||\n              ((dom.isRightEdgePointOf(point, block) || dom.isVoid(dom.nextPoint(point).node)) && isLeftToRight)) {\n\n            // returns point already on visible point\n            if (dom.isVisiblePoint(point)) {\n              return point;\n            }\n            // reverse direction \n            isLeftToRight = !isLeftToRight;\n          }\n\n          var nextPoint = isLeftToRight ? dom.nextPointUntil(dom.nextPoint(point), dom.isVisiblePoint) :\n                                          dom.prevPointUntil(dom.prevPoint(point), dom.isVisiblePoint);\n          return nextPoint || point;\n        };\n\n        var endPoint = getVisiblePoint(this.getEndPoint(), false);\n        var startPoint = this.isCollapsed() ? endPoint : getVisiblePoint(this.getStartPoint(), true);\n\n        return new WrappedRange(\n          startPoint.node,\n          startPoint.offset,\n          endPoint.node,\n          endPoint.offset\n        );\n      };\n\n      /**\n       * returns matched nodes on range\n       *\n       * @param {Function} [pred] - predicate function\n       * @param {Object} [options]\n       * @param {Boolean} [options.includeAncestor]\n       * @param {Boolean} [options.fullyContains]\n       * @return {Node[]}\n       */\n      this.nodes = function (pred, options) {\n        pred = pred || func.ok;\n\n        var includeAncestor = options && options.includeAncestor;\n        var fullyContains = options && options.fullyContains;\n\n        // TODO compare points and sort\n        var startPoint = this.getStartPoint();\n        var endPoint = this.getEndPoint();\n\n        var nodes = [];\n        var leftEdgeNodes = [];\n\n        dom.walkPoint(startPoint, endPoint, function (point) {\n          if (dom.isEditable(point.node)) {\n            return;\n          }\n\n          var node;\n          if (fullyContains) {\n            if (dom.isLeftEdgePoint(point)) {\n              leftEdgeNodes.push(point.node);\n            }\n            if (dom.isRightEdgePoint(point) && list.contains(leftEdgeNodes, point.node)) {\n              node = point.node;\n            }\n          } else if (includeAncestor) {\n            node = dom.ancestor(point.node, pred);\n          } else {\n            node = point.node;\n          }\n\n          if (node && pred(node)) {\n            nodes.push(node);\n          }\n        }, true);\n\n        return list.unique(nodes);\n      };\n\n      /**\n       * returns commonAncestor of range\n       * @return {Element} - commonAncestor\n       */\n      this.commonAncestor = function () {\n        return dom.commonAncestor(sc, ec);\n      };\n\n      /**\n       * returns expanded range by pred\n       *\n       * @param {Function} pred - predicate function\n       * @return {WrappedRange}\n       */\n      this.expand = function (pred) {\n        var startAncestor = dom.ancestor(sc, pred);\n        var endAncestor = dom.ancestor(ec, pred);\n\n        if (!startAncestor && !endAncestor) {\n          return new WrappedRange(sc, so, ec, eo);\n        }\n\n        var boundaryPoints = this.getPoints();\n\n        if (startAncestor) {\n          boundaryPoints.sc = startAncestor;\n          boundaryPoints.so = 0;\n        }\n\n        if (endAncestor) {\n          boundaryPoints.ec = endAncestor;\n          boundaryPoints.eo = dom.nodeLength(endAncestor);\n        }\n\n        return new WrappedRange(\n          boundaryPoints.sc,\n          boundaryPoints.so,\n          boundaryPoints.ec,\n          boundaryPoints.eo\n        );\n      };\n\n      /**\n       * @param {Boolean} isCollapseToStart\n       * @return {WrappedRange}\n       */\n      this.collapse = function (isCollapseToStart) {\n        if (isCollapseToStart) {\n          return new WrappedRange(sc, so, sc, so);\n        } else {\n          return new WrappedRange(ec, eo, ec, eo);\n        }\n      };\n\n      /**\n       * splitText on range\n       */\n      this.splitText = function () {\n        var isSameContainer = sc === ec;\n        var boundaryPoints = this.getPoints();\n\n        if (dom.isText(ec) && !dom.isEdgePoint(this.getEndPoint())) {\n          ec.splitText(eo);\n        }\n\n        if (dom.isText(sc) && !dom.isEdgePoint(this.getStartPoint())) {\n          boundaryPoints.sc = sc.splitText(so);\n          boundaryPoints.so = 0;\n\n          if (isSameContainer) {\n            boundaryPoints.ec = boundaryPoints.sc;\n            boundaryPoints.eo = eo - so;\n          }\n        }\n\n        return new WrappedRange(\n          boundaryPoints.sc,\n          boundaryPoints.so,\n          boundaryPoints.ec,\n          boundaryPoints.eo\n        );\n      };\n\n      /**\n       * delete contents on range\n       * @return {WrappedRange}\n       */\n      this.deleteContents = function () {\n        if (this.isCollapsed()) {\n          return this;\n        }\n\n        var rng = this.splitText();\n        var nodes = rng.nodes(null, {\n          fullyContains: true\n        });\n\n        // find new cursor point\n        var point = dom.prevPointUntil(rng.getStartPoint(), function (point) {\n          return !list.contains(nodes, point.node);\n        });\n\n        var emptyParents = [];\n        $.each(nodes, function (idx, node) {\n          // find empty parents\n          var parent = node.parentNode;\n          if (point.node !== parent && dom.nodeLength(parent) === 1) {\n            emptyParents.push(parent);\n          }\n          dom.remove(node, false);\n        });\n\n        // remove empty parents\n        $.each(emptyParents, function (idx, node) {\n          dom.remove(node, false);\n        });\n\n        return new WrappedRange(\n          point.node,\n          point.offset,\n          point.node,\n          point.offset\n        ).normalize();\n      };\n      \n      /**\n       * makeIsOn: return isOn(pred) function\n       */\n      var makeIsOn = function (pred) {\n        return function () {\n          var ancestor = dom.ancestor(sc, pred);\n          return !!ancestor && (ancestor === dom.ancestor(ec, pred));\n        };\n      };\n  \n      // isOnEditable: judge whether range is on editable or not\n      this.isOnEditable = makeIsOn(dom.isEditable);\n      // isOnList: judge whether range is on list node or not\n      this.isOnList = makeIsOn(dom.isList);\n      // isOnAnchor: judge whether range is on anchor node or not\n      this.isOnAnchor = makeIsOn(dom.isAnchor);\n      // isOnAnchor: judge whether range is on cell node or not\n      this.isOnCell = makeIsOn(dom.isCell);\n\n      /**\n       * @param {Function} pred\n       * @return {Boolean}\n       */\n      this.isLeftEdgeOf = function (pred) {\n        if (!dom.isLeftEdgePoint(this.getStartPoint())) {\n          return false;\n        }\n\n        var node = dom.ancestor(this.sc, pred);\n        return node && dom.isLeftEdgeOf(this.sc, node);\n      };\n\n      /**\n       * returns whether range was collapsed or not\n       */\n      this.isCollapsed = function () {\n        return sc === ec && so === eo;\n      };\n\n      /**\n       * wrap inline nodes which children of body with paragraph\n       *\n       * @return {WrappedRange}\n       */\n      this.wrapBodyInlineWithPara = function () {\n        if (dom.isBodyContainer(sc) && dom.isEmpty(sc)) {\n          sc.innerHTML = dom.emptyPara;\n          return new WrappedRange(sc.firstChild, 0, sc.firstChild, 0);\n        }\n\n        /**\n         * [workaround] firefox often create range on not visible point. so normalize here.\n         *  - firefox: |<p>text</p>|\n         *  - chrome: <p>|text|</p>\n         */\n        var rng = this.normalize();\n        if (dom.isParaInline(sc) || dom.isPara(sc)) {\n          return rng;\n        }\n\n        // find inline top ancestor\n        var topAncestor;\n        if (dom.isInline(rng.sc)) {\n          var ancestors = dom.listAncestor(rng.sc, func.not(dom.isInline));\n          topAncestor = list.last(ancestors);\n          if (!dom.isInline(topAncestor)) {\n            topAncestor = ancestors[ancestors.length - 2] || rng.sc.childNodes[rng.so];\n          }\n        } else {\n          topAncestor = rng.sc.childNodes[rng.so > 0 ? rng.so - 1 : 0];\n        }\n\n        // siblings not in paragraph\n        var inlineSiblings = dom.listPrev(topAncestor, dom.isParaInline).reverse();\n        inlineSiblings = inlineSiblings.concat(dom.listNext(topAncestor.nextSibling, dom.isParaInline));\n\n        // wrap with paragraph\n        if (inlineSiblings.length) {\n          var para = dom.wrap(list.head(inlineSiblings), 'p');\n          dom.appendChildNodes(para, list.tail(inlineSiblings));\n        }\n\n        return this.normalize();\n      };\n\n      /**\n       * insert node at current cursor\n       *\n       * @param {Node} node\n       * @return {Node}\n       */\n      this.insertNode = function (node) {\n        var rng = this.wrapBodyInlineWithPara().deleteContents();\n        var info = dom.splitPoint(rng.getStartPoint(), dom.isInline(node));\n\n        if (info.rightNode) {\n          info.rightNode.parentNode.insertBefore(node, info.rightNode);\n        } else {\n          info.container.appendChild(node);\n        }\n\n        return node;\n      };\n\n      /**\n       * insert html at current cursor\n       */\n      this.pasteHTML = function (markup) {\n        var contentsContainer = $('<div></div>').html(markup)[0];\n        var childNodes = list.from(contentsContainer.childNodes);\n\n        var rng = this.wrapBodyInlineWithPara().deleteContents();\n\n        return childNodes.reverse().map(function (childNode) {\n          return rng.insertNode(childNode);\n        }).reverse();\n      };\n  \n      /**\n       * returns text in range\n       *\n       * @return {String}\n       */\n      this.toString = function () {\n        var nativeRng = nativeRange();\n        return agent.isW3CRangeSupport ? nativeRng.toString() : nativeRng.text;\n      };\n\n      /**\n       * returns range for word before cursor\n       *\n       * @param {Boolean} [findAfter] - find after cursor, default: false\n       * @return {WrappedRange}\n       */\n      this.getWordRange = function (findAfter) {\n        var endPoint = this.getEndPoint();\n\n        if (!dom.isCharPoint(endPoint)) {\n          return this;\n        }\n\n        var startPoint = dom.prevPointUntil(endPoint, function (point) {\n          return !dom.isCharPoint(point);\n        });\n\n        if (findAfter) {\n          endPoint = dom.nextPointUntil(endPoint, function (point) {\n            return !dom.isCharPoint(point);\n          });\n        }\n\n        return new WrappedRange(\n          startPoint.node,\n          startPoint.offset,\n          endPoint.node,\n          endPoint.offset\n        );\n      };\n  \n      /**\n       * create offsetPath bookmark\n       *\n       * @param {Node} editable\n       */\n      this.bookmark = function (editable) {\n        return {\n          s: {\n            path: dom.makeOffsetPath(editable, sc),\n            offset: so\n          },\n          e: {\n            path: dom.makeOffsetPath(editable, ec),\n            offset: eo\n          }\n        };\n      };\n\n      /**\n       * create offsetPath bookmark base on paragraph\n       *\n       * @param {Node[]} paras\n       */\n      this.paraBookmark = function (paras) {\n        return {\n          s: {\n            path: list.tail(dom.makeOffsetPath(list.head(paras), sc)),\n            offset: so\n          },\n          e: {\n            path: list.tail(dom.makeOffsetPath(list.last(paras), ec)),\n            offset: eo\n          }\n        };\n      };\n\n      /**\n       * getClientRects\n       * @return {Rect[]}\n       */\n      this.getClientRects = function () {\n        var nativeRng = nativeRange();\n        return nativeRng.getClientRects();\n      };\n    };\n\n  /**\n   * @class core.range\n   *\n   * Data structure\n   *  * BoundaryPoint: a point of dom tree\n   *  * BoundaryPoints: two boundaryPoints corresponding to the start and the end of the Range\n   *\n   * See to http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Position\n   *\n   * @singleton\n   * @alternateClassName range\n   */\n    return {\n      /**\n       * create Range Object From arguments or Browser Selection\n       *\n       * @param {Node} sc - start container\n       * @param {Number} so - start offset\n       * @param {Node} ec - end container\n       * @param {Number} eo - end offset\n       * @return {WrappedRange}\n       */\n      create: function (sc, so, ec, eo) {\n        if (arguments.length === 4) {\n          return new WrappedRange(sc, so, ec, eo);\n        } else if (arguments.length === 2) { //collapsed\n          ec = sc;\n          eo = so;\n          return new WrappedRange(sc, so, ec, eo);\n        } else {\n          var wrappedRange = this.createFromSelection();\n          if (!wrappedRange && arguments.length === 1) {\n            wrappedRange = this.createFromNode(arguments[0]);\n            return wrappedRange.collapse(dom.emptyPara === arguments[0].innerHTML);\n          }\n          return wrappedRange;\n        }\n      },\n\n      createFromSelection: function () {\n        var sc, so, ec, eo;\n        if (agent.isW3CRangeSupport) {\n          var selection = document.getSelection();\n          if (!selection || selection.rangeCount === 0) {\n            return null;\n          } else if (dom.isBody(selection.anchorNode)) {\n            // Firefox: returns entire body as range on initialization.\n            // We won't never need it.\n            return null;\n          }\n\n          var nativeRng = selection.getRangeAt(0);\n          sc = nativeRng.startContainer;\n          so = nativeRng.startOffset;\n          ec = nativeRng.endContainer;\n          eo = nativeRng.endOffset;\n        } else { // IE8: TextRange\n          var textRange = document.selection.createRange();\n          var textRangeEnd = textRange.duplicate();\n          textRangeEnd.collapse(false);\n          var textRangeStart = textRange;\n          textRangeStart.collapse(true);\n\n          var startPoint = textRangeToPoint(textRangeStart, true),\n          endPoint = textRangeToPoint(textRangeEnd, false);\n\n          // same visible point case: range was collapsed.\n          if (dom.isText(startPoint.node) && dom.isLeftEdgePoint(startPoint) &&\n              dom.isTextNode(endPoint.node) && dom.isRightEdgePoint(endPoint) &&\n              endPoint.node.nextSibling === startPoint.node) {\n            startPoint = endPoint;\n          }\n\n          sc = startPoint.cont;\n          so = startPoint.offset;\n          ec = endPoint.cont;\n          eo = endPoint.offset;\n        }\n\n        return new WrappedRange(sc, so, ec, eo);\n      },\n\n      /**\n       * @method \n       * \n       * create WrappedRange from node\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNode: function (node) {\n        var sc = node;\n        var so = 0;\n        var ec = node;\n        var eo = dom.nodeLength(ec);\n\n        // browsers can't target a picture or void node\n        if (dom.isVoid(sc)) {\n          so = dom.listPrev(sc).length - 1;\n          sc = sc.parentNode;\n        }\n        if (dom.isBR(ec)) {\n          eo = dom.listPrev(ec).length - 1;\n          ec = ec.parentNode;\n        } else if (dom.isVoid(ec)) {\n          eo = dom.listPrev(ec).length;\n          ec = ec.parentNode;\n        }\n\n        return this.create(sc, so, ec, eo);\n      },\n\n      /**\n       * create WrappedRange from node after position\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNodeBefore: function (node) {\n        return this.createFromNode(node).collapse(true);\n      },\n\n      /**\n       * create WrappedRange from node after position\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNodeAfter: function (node) {\n        return this.createFromNode(node).collapse();\n      },\n\n      /**\n       * @method \n       * \n       * create WrappedRange from bookmark\n       *\n       * @param {Node} editable\n       * @param {Object} bookmark\n       * @return {WrappedRange}\n       */\n      createFromBookmark: function (editable, bookmark) {\n        var sc = dom.fromOffsetPath(editable, bookmark.s.path);\n        var so = bookmark.s.offset;\n        var ec = dom.fromOffsetPath(editable, bookmark.e.path);\n        var eo = bookmark.e.offset;\n        return new WrappedRange(sc, so, ec, eo);\n      },\n\n      /**\n       * @method \n       *\n       * create WrappedRange from paraBookmark\n       *\n       * @param {Object} bookmark\n       * @param {Node[]} paras\n       * @return {WrappedRange}\n       */\n      createFromParaBookmark: function (bookmark, paras) {\n        var so = bookmark.s.offset;\n        var eo = bookmark.e.offset;\n        var sc = dom.fromOffsetPath(list.head(paras), bookmark.s.path);\n        var ec = dom.fromOffsetPath(list.last(paras), bookmark.e.path);\n\n        return new WrappedRange(sc, so, ec, eo);\n      }\n    };\n  })();\n\n  /**\n   * @class core.async\n   *\n   * Async functions which returns `Promise`\n   *\n   * @singleton\n   * @alternateClassName async\n   */\n  var async = (function () {\n    /**\n     * @method readFileAsDataURL\n     *\n     * read contents of file as representing URL\n     *\n     * @param {File} file\n     * @return {Promise} - then: dataUrl\n     */\n    var readFileAsDataURL = function (file) {\n      return $.Deferred(function (deferred) {\n        $.extend(new FileReader(), {\n          onload: function (e) {\n            var dataURL = e.target.result;\n            deferred.resolve(dataURL);\n          },\n          onerror: function () {\n            deferred.reject(this);\n          }\n        }).readAsDataURL(file);\n      }).promise();\n    };\n  \n    /**\n     * @method createImage\n     *\n     * create `<image>` from url string\n     *\n     * @param {String} url\n     * @return {Promise} - then: $image\n     */\n    var createImage = function (url) {\n      return $.Deferred(function (deferred) {\n        var $img = $('<img>');\n\n        $img.one('load', function () {\n          $img.off('error abort');\n          deferred.resolve($img);\n        }).one('error abort', function () {\n          $img.off('load').detach();\n          deferred.reject($img);\n        }).css({\n          display: 'none'\n        }).appendTo(document.body).attr('src', url);\n      }).promise();\n    };\n\n    return {\n      readFileAsDataURL: readFileAsDataURL,\n      createImage: createImage\n    };\n  })();\n\n  /**\n   * @class editing.History\n   *\n   * Editor History\n   *\n   */\n  var History = function ($editable) {\n    var stack = [], stackOffset = -1;\n    var editable = $editable[0];\n\n    var makeSnapshot = function () {\n      var rng = range.create(editable);\n      var emptyBookmark = {s: {path: [], offset: 0}, e: {path: [], offset: 0}};\n\n      return {\n        contents: $editable.html(),\n        bookmark: (rng ? rng.bookmark(editable) : emptyBookmark)\n      };\n    };\n\n    var applySnapshot = function (snapshot) {\n      if (snapshot.contents !== null) {\n        $editable.html(snapshot.contents);\n      }\n      if (snapshot.bookmark !== null) {\n        range.createFromBookmark(editable, snapshot.bookmark).select();\n      }\n    };\n\n    /**\n    * @method rewind\n    * Rewinds the history stack back to the first snapshot taken.\n    * Leaves the stack intact, so that \"Redo\" can still be used.\n    */\n    this.rewind = function () {\n      // Create snap shot if not yet recorded\n      if ($editable.html() !== stack[stackOffset].contents) {\n        this.recordUndo();\n      }\n\n      // Return to the first available snapshot.\n      stackOffset = 0;\n\n      // Apply that snapshot.\n      applySnapshot(stack[stackOffset]);\n    };\n\n    /**\n    * @method reset\n    * Resets the history stack completely; reverting to an empty editor.\n    */\n    this.reset = function () {\n      // Clear the stack.\n      stack = [];\n\n      // Restore stackOffset to its original value.\n      stackOffset = -1;\n\n      // Clear the editable area.\n      $editable.html('');\n\n      // Record our first snapshot (of nothing).\n      this.recordUndo();\n    };\n\n    /**\n     * undo\n     */\n    this.undo = function () {\n      // Create snap shot if not yet recorded\n      if ($editable.html() !== stack[stackOffset].contents) {\n        this.recordUndo();\n      }\n\n      if (0 < stackOffset) {\n        stackOffset--;\n        applySnapshot(stack[stackOffset]);\n      }\n    };\n\n    /**\n     * redo\n     */\n    this.redo = function () {\n      if (stack.length - 1 > stackOffset) {\n        stackOffset++;\n        applySnapshot(stack[stackOffset]);\n      }\n    };\n\n    /**\n     * recorded undo\n     */\n    this.recordUndo = function () {\n      stackOffset++;\n\n      // Wash out stack after stackOffset\n      if (stack.length > stackOffset) {\n        stack = stack.slice(0, stackOffset);\n      }\n\n      // Create new snapshot and push it to the end\n      stack.push(makeSnapshot());\n    };\n  };\n\n  /**\n   * @class editing.Style\n   *\n   * Style\n   *\n   */\n  var Style = function () {\n    /**\n     * @method jQueryCSS\n     *\n     * [workaround] for old jQuery\n     * passing an array of style properties to .css()\n     * will result in an object of property-value pairs.\n     * (compability with version < 1.9)\n     *\n     * @private\n     * @param  {jQuery} $obj\n     * @param  {Array} propertyNames - An array of one or more CSS properties.\n     * @return {Object}\n     */\n    var jQueryCSS = function ($obj, propertyNames) {\n      if (agent.jqueryVersion < 1.9) {\n        var result = {};\n        $.each(propertyNames, function (idx, propertyName) {\n          result[propertyName] = $obj.css(propertyName);\n        });\n        return result;\n      }\n      return $obj.css.call($obj, propertyNames);\n    };\n\n    /**\n     * returns style object from node\n     *\n     * @param {jQuery} $node\n     * @return {Object}\n     */\n    this.fromNode = function ($node) {\n      var properties = ['font-family', 'font-size', 'text-align', 'list-style-type', 'line-height'];\n      var styleInfo = jQueryCSS($node, properties) || {};\n      styleInfo['font-size'] = parseInt(styleInfo['font-size'], 10);\n      return styleInfo;\n    };\n\n    /**\n     * paragraph level style\n     *\n     * @param {WrappedRange} rng\n     * @param {Object} styleInfo\n     */\n    this.stylePara = function (rng, styleInfo) {\n      $.each(rng.nodes(dom.isPara, {\n        includeAncestor: true\n      }), function (idx, para) {\n        $(para).css(styleInfo);\n      });\n    };\n\n    /**\n     * insert and returns styleNodes on range.\n     *\n     * @param {WrappedRange} rng\n     * @param {Object} [options] - options for styleNodes\n     * @param {String} [options.nodeName] - default: `SPAN`\n     * @param {Boolean} [options.expandClosestSibling] - default: `false`\n     * @param {Boolean} [options.onlyPartialContains] - default: `false`\n     * @return {Node[]}\n     */\n    this.styleNodes = function (rng, options) {\n      rng = rng.splitText();\n\n      var nodeName = options && options.nodeName || 'SPAN';\n      var expandClosestSibling = !!(options && options.expandClosestSibling);\n      var onlyPartialContains = !!(options && options.onlyPartialContains);\n\n      if (rng.isCollapsed()) {\n        return [rng.insertNode(dom.create(nodeName))];\n      }\n\n      var pred = dom.makePredByNodeName(nodeName);\n      var nodes = rng.nodes(dom.isText, {\n        fullyContains: true\n      }).map(function (text) {\n        return dom.singleChildAncestor(text, pred) || dom.wrap(text, nodeName);\n      });\n\n      if (expandClosestSibling) {\n        if (onlyPartialContains) {\n          var nodesInRange = rng.nodes();\n          // compose with partial contains predication\n          pred = func.and(pred, function (node) {\n            return list.contains(nodesInRange, node);\n          });\n        }\n\n        return nodes.map(function (node) {\n          var siblings = dom.withClosestSiblings(node, pred);\n          var head = list.head(siblings);\n          var tails = list.tail(siblings);\n          $.each(tails, function (idx, elem) {\n            dom.appendChildNodes(head, elem.childNodes);\n            dom.remove(elem);\n          });\n          return list.head(siblings);\n        });\n      } else {\n        return nodes;\n      }\n    };\n\n    /**\n     * get current style on cursor\n     *\n     * @param {WrappedRange} rng\n     * @return {Object} - object contains style properties.\n     */\n    this.current = function (rng) {\n      var $cont = $(!dom.isElement(rng.sc) ? rng.sc.parentNode : rng.sc);\n      var styleInfo = this.fromNode($cont);\n\n      // document.queryCommandState for toggle state\n      // [workaround] prevent Firefox nsresult: \"0x80004005 (NS_ERROR_FAILURE)\"\n      try {\n        styleInfo = $.extend(styleInfo, {\n          'font-bold': document.queryCommandState('bold') ? 'bold' : 'normal',\n          'font-italic': document.queryCommandState('italic') ? 'italic' : 'normal',\n          'font-underline': document.queryCommandState('underline') ? 'underline' : 'normal',\n          'font-subscript': document.queryCommandState('subscript') ? 'subscript' : 'normal',\n          'font-superscript': document.queryCommandState('superscript') ? 'superscript' : 'normal',\n          'font-strikethrough': document.queryCommandState('strikethrough') ? 'strikethrough' : 'normal'\n        });\n      } catch (e) {}\n\n      // list-style-type to list-style(unordered, ordered)\n      if (!rng.isOnList()) {\n        styleInfo['list-style'] = 'none';\n      } else {\n        var orderedTypes = ['circle', 'disc', 'disc-leading-zero', 'square'];\n        var isUnordered = $.inArray(styleInfo['list-style-type'], orderedTypes) > -1;\n        styleInfo['list-style'] = isUnordered ? 'unordered' : 'ordered';\n      }\n\n      var para = dom.ancestor(rng.sc, dom.isPara);\n      if (para && para.style['line-height']) {\n        styleInfo['line-height'] = para.style.lineHeight;\n      } else {\n        var lineHeight = parseInt(styleInfo['line-height'], 10) / parseInt(styleInfo['font-size'], 10);\n        styleInfo['line-height'] = lineHeight.toFixed(1);\n      }\n\n      styleInfo.anchor = rng.isOnAnchor() && dom.ancestor(rng.sc, dom.isAnchor);\n      styleInfo.ancestors = dom.listAncestor(rng.sc, dom.isEditable);\n      styleInfo.range = rng;\n\n      return styleInfo;\n    };\n  };\n\n\n  /**\n   * @class editing.Bullet\n   *\n   * @alternateClassName Bullet\n   */\n  var Bullet = function () {\n    var self = this;\n\n    /**\n     * toggle ordered list\n     */\n    this.insertOrderedList = function (editable) {\n      this.toggleList('OL', editable);\n    };\n\n    /**\n     * toggle unordered list\n     */\n    this.insertUnorderedList = function (editable) {\n      this.toggleList('UL', editable);\n    };\n\n    /**\n     * indent\n     */\n    this.indent = function (editable) {\n      var self = this;\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        if (dom.isLi(head)) {\n          self.wrapList(paras, head.parentNode.nodeName);\n        } else {\n          $.each(paras, function (idx, para) {\n            $(para).css('marginLeft', function (idx, val) {\n              return (parseInt(val, 10) || 0) + 25;\n            });\n          });\n        }\n      });\n\n      rng.select();\n    };\n\n    /**\n     * outdent\n     */\n    this.outdent = function (editable) {\n      var self = this;\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        if (dom.isLi(head)) {\n          self.releaseList([paras]);\n        } else {\n          $.each(paras, function (idx, para) {\n            $(para).css('marginLeft', function (idx, val) {\n              val = (parseInt(val, 10) || 0);\n              return val > 25 ? val - 25 : '';\n            });\n          });\n        }\n      });\n\n      rng.select();\n    };\n\n    /**\n     * toggle list\n     *\n     * @param {String} listName - OL or UL\n     */\n    this.toggleList = function (listName, editable) {\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var bookmark = rng.paraBookmark(paras);\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      // paragraph to list\n      if (list.find(paras, dom.isPurePara)) {\n        var wrappedParas = [];\n        $.each(clustereds, function (idx, paras) {\n          wrappedParas = wrappedParas.concat(self.wrapList(paras, listName));\n        });\n        paras = wrappedParas;\n      // list to paragraph or change list style\n      } else {\n        var diffLists = rng.nodes(dom.isList, {\n          includeAncestor: true\n        }).filter(function (listNode) {\n          return !$.nodeName(listNode, listName);\n        });\n\n        if (diffLists.length) {\n          $.each(diffLists, function (idx, listNode) {\n            dom.replace(listNode, listName);\n          });\n        } else {\n          paras = this.releaseList(clustereds, true);\n        }\n      }\n\n      range.createFromParaBookmark(bookmark, paras).select();\n    };\n\n    /**\n     * @param {Node[]} paras\n     * @param {String} listName\n     * @return {Node[]}\n     */\n    this.wrapList = function (paras, listName) {\n      var head = list.head(paras);\n      var last = list.last(paras);\n\n      var prevList = dom.isList(head.previousSibling) && head.previousSibling;\n      var nextList = dom.isList(last.nextSibling) && last.nextSibling;\n\n      var listNode = prevList || dom.insertAfter(dom.create(listName || 'UL'), last);\n\n      // P to LI\n      paras = paras.map(function (para) {\n        return dom.isPurePara(para) ? dom.replace(para, 'LI') : para;\n      });\n\n      // append to list(<ul>, <ol>)\n      dom.appendChildNodes(listNode, paras);\n\n      if (nextList) {\n        dom.appendChildNodes(listNode, list.from(nextList.childNodes));\n        dom.remove(nextList);\n      }\n\n      return paras;\n    };\n\n    /**\n     * @method releaseList\n     *\n     * @param {Array[]} clustereds\n     * @param {Boolean} isEscapseToBody\n     * @return {Node[]}\n     */\n    this.releaseList = function (clustereds, isEscapseToBody) {\n      var releasedParas = [];\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        var last = list.last(paras);\n\n        var headList = isEscapseToBody ? dom.lastAncestor(head, dom.isList) :\n                                         head.parentNode;\n        var lastList = headList.childNodes.length > 1 ? dom.splitTree(headList, {\n          node: last.parentNode,\n          offset: dom.position(last) + 1\n        }, {\n          isSkipPaddingBlankHTML: true\n        }) : null;\n\n        var middleList = dom.splitTree(headList, {\n          node: head.parentNode,\n          offset: dom.position(head)\n        }, {\n          isSkipPaddingBlankHTML: true\n        });\n\n        paras = isEscapseToBody ? dom.listDescendant(middleList, dom.isLi) :\n                                  list.from(middleList.childNodes).filter(dom.isLi);\n\n        // LI to P\n        if (isEscapseToBody || !dom.isList(headList.parentNode)) {\n          paras = paras.map(function (para) {\n            return dom.replace(para, 'P');\n          });\n        }\n\n        $.each(list.from(paras).reverse(), function (idx, para) {\n          dom.insertAfter(para, headList);\n        });\n\n        // remove empty lists\n        var rootLists = list.compact([headList, middleList, lastList]);\n        $.each(rootLists, function (idx, rootList) {\n          var listNodes = [rootList].concat(dom.listDescendant(rootList, dom.isList));\n          $.each(listNodes.reverse(), function (idx, listNode) {\n            if (!dom.nodeLength(listNode)) {\n              dom.remove(listNode, true);\n            }\n          });\n        });\n\n        releasedParas = releasedParas.concat(paras);\n      });\n\n      return releasedParas;\n    };\n  };\n\n\n  /**\n   * @class editing.Typing\n   *\n   * Typing\n   *\n   */\n  var Typing = function () {\n\n    // a Bullet instance to toggle lists off\n    var bullet = new Bullet();\n\n    /**\n     * insert tab\n     *\n     * @param {WrappedRange} rng\n     * @param {Number} tabsize\n     */\n    this.insertTab = function (rng, tabsize) {\n      var tab = dom.createText(new Array(tabsize + 1).join(dom.NBSP_CHAR));\n      rng = rng.deleteContents();\n      rng.insertNode(tab, true);\n\n      rng = range.create(tab, tabsize);\n      rng.select();\n    };\n\n    /**\n     * insert paragraph\n     */\n    this.insertParagraph = function (editable) {\n      var rng = range.create(editable);\n\n      // deleteContents on range.\n      rng = rng.deleteContents();\n\n      // Wrap range if it needs to be wrapped by paragraph\n      rng = rng.wrapBodyInlineWithPara();\n\n      // finding paragraph\n      var splitRoot = dom.ancestor(rng.sc, dom.isPara);\n\n      var nextPara;\n      // on paragraph: split paragraph\n      if (splitRoot) {\n        // if it is an empty line with li\n        if (dom.isEmpty(splitRoot) && dom.isLi(splitRoot)) {\n          // toogle UL/OL and escape\n          bullet.toggleList(splitRoot.parentNode.nodeName);\n          return;\n        // if it is an empty line with para on blockquote\n        } else if (dom.isEmpty(splitRoot) && dom.isPara(splitRoot) && dom.isBlockquote(splitRoot.parentNode)) {\n          // escape blockquote\n          dom.insertAfter(splitRoot, splitRoot.parentNode);\n          nextPara = splitRoot;\n        // if new line has content (not a line break)\n        } else {\n          nextPara = dom.splitTree(splitRoot, rng.getStartPoint());\n\n          var emptyAnchors = dom.listDescendant(splitRoot, dom.isEmptyAnchor);\n          emptyAnchors = emptyAnchors.concat(dom.listDescendant(nextPara, dom.isEmptyAnchor));\n\n          $.each(emptyAnchors, function (idx, anchor) {\n            dom.remove(anchor);\n          });\n\n          // replace empty heading or pre with P tag\n          if ((dom.isHeading(nextPara) || dom.isPre(nextPara)) && dom.isEmpty(nextPara)) {\n            nextPara = dom.replace(nextPara, 'p');\n          }\n        }\n      // no paragraph: insert empty paragraph\n      } else {\n        var next = rng.sc.childNodes[rng.so];\n        nextPara = $(dom.emptyPara)[0];\n        if (next) {\n          rng.sc.insertBefore(nextPara, next);\n        } else {\n          rng.sc.appendChild(nextPara);\n        }\n      }\n\n      range.create(nextPara, 0).normalize().select().scrollIntoView(editable);\n    };\n  };\n\n  /**\n   * @class editing.Table\n   *\n   * Table\n   *\n   */\n  var Table = function () {\n    /**\n     * handle tab key\n     *\n     * @param {WrappedRange} rng\n     * @param {Boolean} isShift\n     */\n    this.tab = function (rng, isShift) {\n      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);\n      var table = dom.ancestor(cell, dom.isTable);\n      var cells = dom.listDescendant(table, dom.isCell);\n\n      var nextCell = list[isShift ? 'prev' : 'next'](cells, cell);\n      if (nextCell) {\n        range.create(nextCell, 0).select();\n      }\n    };\n\n    /**\n     * create empty table element\n     *\n     * @param {Number} rowCount\n     * @param {Number} colCount\n     * @return {Node}\n     */\n    this.createTable = function (colCount, rowCount, options) {\n      var tds = [], tdHTML;\n      for (var idxCol = 0; idxCol < colCount; idxCol++) {\n        tds.push('<td>' + dom.blank + '</td>');\n      }\n      tdHTML = tds.join('');\n\n      var trs = [], trHTML;\n      for (var idxRow = 0; idxRow < rowCount; idxRow++) {\n        trs.push('<tr>' + tdHTML + '</tr>');\n      }\n      trHTML = trs.join('');\n      var $table = $('<table>' + trHTML + '</table>');\n      if (options && options.tableClassName) {\n        $table.addClass(options.tableClassName);\n      }\n\n      return $table[0];\n    };\n  };\n\n\n  var KEY_BOGUS = 'bogus';\n\n  /**\n   * @class Editor\n   */\n  var Editor = function (context) {\n    var self = this;\n\n    var $note = context.layoutInfo.note;\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    var editable = $editable[0];\n    var lastRange = null;\n\n    var style = new Style();\n    var table = new Table();\n    var typing = new Typing();\n    var bullet = new Bullet();\n    var history = new History($editable);\n\n    this.initialize = function () {\n      // bind custom events\n      $editable.on('keydown', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          context.triggerEvent('enter', event);\n        }\n        context.triggerEvent('keydown', event);\n\n        if (options.shortcuts && !event.isDefaultPrevented()) {\n          self.handleKeyMap(event);\n        }\n      }).on('keyup', function (event) {\n        context.triggerEvent('keyup', event);\n      }).on('focus', function (event) {\n        context.triggerEvent('focus', event);\n      }).on('blur', function (event) {\n        context.triggerEvent('blur', event);\n      }).on('mousedown', function (event) {\n        context.triggerEvent('mousedown', event);\n      }).on('mouseup', function (event) {\n        context.triggerEvent('mouseup', event);\n      }).on('scroll', function (event) {\n        context.triggerEvent('scroll', event);\n      }).on('paste', function (event) {\n        context.triggerEvent('paste', event);\n      });\n\n      // init content before set event\n      $editable.html(dom.html($note) || dom.emptyPara);\n\n      // [workaround] IE doesn't have input events for contentEditable\n      // - see: https://goo.gl/4bfIvA\n      var changeEventName = agent.isMSIE ? 'DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted' : 'input';\n      $editable.on(changeEventName, function () {\n        context.triggerEvent('change', $editable.html());\n      });\n\n      $editor.on('focusin', function (event) {\n        context.triggerEvent('focusin', event);\n      }).on('focusout', function (event) {\n        context.triggerEvent('focusout', event);\n      });\n\n      if (!options.airMode && options.height) {\n        this.setHeight(options.height);\n      }\n      if (!options.airMode && options.maxHeight) {\n        $editable.css('max-height', options.maxHeight);\n      }\n      if (!options.airMode && options.minHeight) {\n        $editable.css('min-height', options.minHeight);\n      }\n\n      history.recordUndo();\n    };\n\n    this.destroy = function () {\n      $editable.off();\n    };\n\n    this.handleKeyMap = function (event) {\n      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n      var keys = [];\n\n      if (event.metaKey) { keys.push('CMD'); }\n      if (event.ctrlKey && !event.altKey) { keys.push('CTRL'); }\n      if (event.shiftKey) { keys.push('SHIFT'); }\n\n      var keyName = key.nameFromCode[event.keyCode];\n      if (keyName) {\n        keys.push(keyName);\n      }\n\n      var eventName = keyMap[keys.join('+')];\n      if (eventName) {\n        event.preventDefault();\n        context.invoke(eventName);\n      } else if (key.isEdit(event.keyCode)) {\n        this.afterCommand();\n      }\n    };\n\n    /**\n     * create range\n     * @return {WrappedRange}\n     */\n    this.createRange = function () {\n      this.focus();\n      return range.create(editable);\n    };\n\n    /**\n     * saveRange\n     *\n     * save current range\n     *\n     * @param {Boolean} [thenCollapse=false]\n     */\n    this.saveRange = function (thenCollapse) {\n      lastRange = this.createRange();\n      if (thenCollapse) {\n        lastRange.collapse().select();\n      }\n    };\n\n    /**\n     * restoreRange\n     *\n     * restore lately range\n     */\n    this.restoreRange = function () {\n      if (lastRange) {\n        lastRange.select();\n        this.focus();\n      }\n    };\n\n    this.saveTarget = function (node) {\n      $editable.data('target', node);\n    };\n\n    this.clearTarget = function () {\n      $editable.removeData('target');\n    };\n\n    this.restoreTarget = function () {\n      return $editable.data('target');\n    };\n\n    /**\n     * currentStyle\n     *\n     * current style\n     * @return {Object|Boolean} unfocus\n     */\n    this.currentStyle = function () {\n      var rng = range.create();\n      if (rng) {\n        rng = rng.normalize();\n      }\n      return rng ? style.current(rng) : style.fromNode($editable);\n    };\n\n    /**\n     * style from node\n     *\n     * @param {jQuery} $node\n     * @return {Object}\n     */\n    this.styleFromNode = function ($node) {\n      return style.fromNode($node);\n    };\n\n    /**\n     * undo\n     */\n    this.undo = function () {\n      context.triggerEvent('before.command', $editable.html());\n      history.undo();\n      context.triggerEvent('change', $editable.html());\n    };\n    context.memo('help.undo', lang.help.undo);\n\n    /**\n     * redo\n     */\n    this.redo = function () {\n      context.triggerEvent('before.command', $editable.html());\n      history.redo();\n      context.triggerEvent('change', $editable.html());\n    };\n    context.memo('help.redo', lang.help.redo);\n\n    /**\n     * before command\n     */\n    var beforeCommand = this.beforeCommand = function () {\n      context.triggerEvent('before.command', $editable.html());\n      // keep focus on editable before command execution\n      self.focus();\n    };\n\n    /**\n     * after command\n     * @param {Boolean} isPreventTrigger\n     */\n    var afterCommand = this.afterCommand = function (isPreventTrigger) {\n      history.recordUndo();\n      if (!isPreventTrigger) {\n        context.triggerEvent('change', $editable.html());\n      }\n    };\n\n    /* jshint ignore:start */\n    // native commands(with execCommand), generate function for execCommand\n    var commands = ['bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript',\n                    'justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull',\n                    'formatBlock', 'removeFormat',\n                    'backColor', 'foreColor', 'fontName'];\n\n    for (var idx = 0, len = commands.length; idx < len; idx ++) {\n      this[commands[idx]] = (function (sCmd) {\n        return function (value) {\n          beforeCommand();\n          document.execCommand(sCmd, false, value);\n          afterCommand(true);\n        };\n      })(commands[idx]);\n      context.memo('help.' + commands[idx], lang.help[commands[idx]]);\n    }\n    /* jshint ignore:end */\n\n    /**\n     * handle tab key\n     */\n    this.tab = function () {\n      var rng = this.createRange();\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        table.tab(rng);\n      } else {\n        beforeCommand();\n        typing.insertTab(rng, options.tabSize);\n        afterCommand();\n      }\n    };\n    context.memo('help.tab', lang.help.tab);\n\n    /**\n     * handle shift+tab key\n     */\n    this.untab = function () {\n      var rng = this.createRange();\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        table.tab(rng, true);\n      }\n    };\n    context.memo('help.untab', lang.help.untab);\n\n    /**\n     * run given function between beforeCommand and afterCommand\n     */\n    this.wrapCommand = function (fn) {\n      return function () {\n        beforeCommand();\n        fn.apply(self, arguments);\n        afterCommand();\n      };\n    };\n\n    /**\n     * insert paragraph\n     */\n    this.insertParagraph = this.wrapCommand(function () {\n      typing.insertParagraph(editable);\n    });\n    context.memo('help.insertParagraph', lang.help.insertParagraph);\n\n    this.insertOrderedList = this.wrapCommand(function () {\n      bullet.insertOrderedList(editable);\n    });\n    context.memo('help.insertOrderedList', lang.help.insertOrderedList);\n\n    this.insertUnorderedList = this.wrapCommand(function () {\n      bullet.insertUnorderedList(editable);\n    });\n    context.memo('help.insertUnorderedList', lang.help.insertUnorderedList);\n\n    this.indent = this.wrapCommand(function () {\n      bullet.indent(editable);\n    });\n    context.memo('help.indent', lang.help.indent);\n\n    this.outdent = this.wrapCommand(function () {\n      bullet.outdent(editable);\n    });\n    context.memo('help.outdent', lang.help.outdent);\n\n    /**\n     * insert image\n     *\n     * @param {String} src\n     * @param {String|Function} param\n     * @return {Promise}\n     */\n    this.insertImage = function (src, param) {\n      return async.createImage(src, param).then(function ($image) {\n        beforeCommand();\n\n        if (typeof param === 'function') {\n          param($image);\n        } else {\n          if (typeof param === 'string') {\n            $image.attr('data-filename', param);\n          }\n          $image.css('width', Math.min($editable.width(), $image.width()));\n        }\n\n        $image.show();\n        range.create(editable).insertNode($image[0]);\n        range.createFromNodeAfter($image[0]).select();\n        afterCommand();\n      }).fail(function (e) {\n        context.triggerEvent('image.upload.error', e);\n      });\n    };\n\n    /**\n     * insertImages\n     * @param {File[]} files\n     */\n    this.insertImages = function (files) {\n      $.each(files, function (idx, file) {\n        var filename = file.name;\n        if (options.maximumImageFileSize && options.maximumImageFileSize < file.size) {\n          context.triggerEvent('image.upload.error', lang.image.maximumFileSizeError);\n        } else {\n          async.readFileAsDataURL(file).then(function (dataURL) {\n            return self.insertImage(dataURL, filename);\n          }).fail(function () {\n            context.triggerEvent('image.upload.error');\n          });\n        }\n      });\n    };\n\n    /**\n     * insertImagesOrCallback\n     * @param {File[]} files\n     */\n    this.insertImagesOrCallback = function (files) {\n      var callbacks = options.callbacks;\n\n      // If onImageUpload options setted\n      if (callbacks.onImageUpload) {\n        context.triggerEvent('image.upload', files);\n      // else insert Image as dataURL\n      } else {\n        this.insertImages(files);\n      }\n    };\n\n    /**\n     * insertNode\n     * insert node\n     * @param {Node} node\n     */\n    this.insertNode = this.wrapCommand(function (node) {\n      var rng = this.createRange();\n      rng.insertNode(node);\n      range.createFromNodeAfter(node).select();\n    });\n\n    /**\n     * insert text\n     * @param {String} text\n     */\n    this.insertText = this.wrapCommand(function (text) {\n      var rng = this.createRange();\n      var textNode = rng.insertNode(dom.createText(text));\n      range.create(textNode, dom.nodeLength(textNode)).select();\n    });\n\n    /**\n     * return selected plain text\n     * @return {String} text\n     */\n    this.getSelectedText = function () {\n      var rng = this.createRange();\n\n      // if range on anchor, expand range with anchor\n      if (rng.isOnAnchor()) {\n        rng = range.createFromNode(dom.ancestor(rng.sc, dom.isAnchor));\n      }\n\n      return rng.toString();\n    };\n\n    /**\n     * paste HTML\n     * @param {String} markup\n     */\n    this.pasteHTML = this.wrapCommand(function (markup) {\n      var contents = this.createRange().pasteHTML(markup);\n      range.createFromNodeAfter(list.last(contents)).select();\n    });\n\n    /**\n     * formatBlock\n     *\n     * @param {String} tagName\n     */\n    this.formatBlock = this.wrapCommand(function (tagName) {\n      // [workaround] for MSIE, IE need `<`\n      tagName = agent.isMSIE ? '<' + tagName + '>' : tagName;\n      document.execCommand('FormatBlock', false, tagName);\n    });\n\n    this.formatPara = function () {\n      this.formatBlock('P');\n    };\n    context.memo('help.formatPara', lang.help.formatPara);\n\n    /* jshint ignore:start */\n    for (var idx = 1; idx <= 6; idx ++) {\n      this['formatH' + idx] = function (idx) {\n        return function () {\n          this.formatBlock('H' + idx);\n        };\n      }(idx);\n      context.memo('help.formatH'+idx, lang.help['formatH' + idx]);\n    };\n    /* jshint ignore:end */\n\n    /**\n     * fontSize\n     *\n     * @param {String} value - px\n     */\n    this.fontSize = function (value) {\n      var rng = this.createRange();\n\n      if (rng && rng.isCollapsed()) {\n        var spans = style.styleNodes(rng);\n        var firstSpan = list.head(spans);\n\n        $(spans).css({\n          'font-size': value + 'px'\n        });\n\n        // [workaround] added styled bogus span for style\n        //  - also bogus character needed for cursor position\n        if (firstSpan && !dom.nodeLength(firstSpan)) {\n          firstSpan.innerHTML = dom.ZERO_WIDTH_NBSP_CHAR;\n          range.createFromNodeAfter(firstSpan.firstChild).select();\n          $editable.data(KEY_BOGUS, firstSpan);\n        }\n      } else {\n        beforeCommand();\n        $(style.styleNodes(rng)).css({\n          'font-size': value + 'px'\n        });\n        afterCommand();\n      }\n    };\n\n    /**\n     * insert horizontal rule\n     */\n    this.insertHorizontalRule = this.wrapCommand(function () {\n      var hrNode = this.createRange().insertNode(dom.create('HR'));\n      if (hrNode.nextSibling) {\n        range.create(hrNode.nextSibling, 0).normalize().select();\n      }\n    });\n    context.memo('help.insertHorizontalRule', lang.help.insertHorizontalRule);\n\n    /**\n     * remove bogus node and character\n     */\n    this.removeBogus = function () {\n      var bogusNode = $editable.data(KEY_BOGUS);\n      if (!bogusNode) {\n        return;\n      }\n\n      var textNode = list.find(list.from(bogusNode.childNodes), dom.isText);\n\n      var bogusCharIdx = textNode.nodeValue.indexOf(dom.ZERO_WIDTH_NBSP_CHAR);\n      if (bogusCharIdx !== -1) {\n        textNode.deleteData(bogusCharIdx, 1);\n      }\n\n      if (dom.isEmpty(bogusNode)) {\n        dom.remove(bogusNode);\n      }\n\n      $editable.removeData(KEY_BOGUS);\n    };\n\n    /**\n     * lineHeight\n     * @param {String} value\n     */\n    this.lineHeight = this.wrapCommand(function (value) {\n      style.stylePara(this.createRange(), {\n        lineHeight: value\n      });\n    });\n\n    /**\n     * unlink\n     *\n     * @type command\n     */\n    this.unlink = function () {\n      var rng = this.createRange();\n      if (rng.isOnAnchor()) {\n        var anchor = dom.ancestor(rng.sc, dom.isAnchor);\n        rng = range.createFromNode(anchor);\n        rng.select();\n\n        beforeCommand();\n        document.execCommand('unlink');\n        afterCommand();\n      }\n    };\n\n    /**\n     * create link (command)\n     *\n     * @param {Object} linkInfo\n     */\n    this.createLink = this.wrapCommand(function (linkInfo) {\n      var linkUrl = linkInfo.url;\n      var linkText = linkInfo.text;\n      var isNewWindow = linkInfo.isNewWindow;\n      var rng = linkInfo.range || this.createRange();\n      var isTextChanged = rng.toString() !== linkText;\n\n      if (options.onCreateLink) {\n        linkUrl = options.onCreateLink(linkUrl);\n      }\n\n      var anchors = [];\n      if (isTextChanged) {\n        rng = rng.deleteContents();\n        var anchor = rng.insertNode($('<A>' + linkText + '</A>')[0]);\n        anchors.push(anchor);\n      } else {\n        anchors = style.styleNodes(rng, {\n          nodeName: 'A',\n          expandClosestSibling: true,\n          onlyPartialContains: true\n        });\n      }\n\n      $.each(anchors, function (idx, anchor) {\n        $(anchor).attr('href', linkUrl);\n        if (isNewWindow) {\n          $(anchor).attr('target', '_blank');\n        } else {\n          $(anchor).removeAttr('target');\n        }\n      });\n\n      var startRange = range.createFromNodeBefore(list.head(anchors));\n      var startPoint = startRange.getStartPoint();\n      var endRange = range.createFromNodeAfter(list.last(anchors));\n      var endPoint = endRange.getEndPoint();\n\n      range.create(\n        startPoint.node,\n        startPoint.offset,\n        endPoint.node,\n        endPoint.offset\n      ).select();\n    });\n\n    /**\n     * returns link info\n     *\n     * @return {Object}\n     * @return {WrappedRange} return.range\n     * @return {String} return.text\n     * @return {Boolean} [return.isNewWindow=true]\n     * @return {String} [return.url=\"\"]\n     */\n    this.getLinkInfo = function () {\n      var rng = this.createRange().expand(dom.isAnchor);\n\n      // Get the first anchor on range(for edit).\n      var $anchor = $(list.head(rng.nodes(dom.isAnchor)));\n\n      return {\n        range: rng,\n        text: rng.toString(),\n        isNewWindow: $anchor.length ? $anchor.attr('target') === '_blank' : false,\n        url: $anchor.length ? $anchor.attr('href') : ''\n      };\n    };\n\n    /**\n     * setting color\n     *\n     * @param {Object} sObjColor  color code\n     * @param {String} sObjColor.foreColor foreground color\n     * @param {String} sObjColor.backColor background color\n     */\n    this.color = this.wrapCommand(function (colorInfo) {\n      var foreColor = colorInfo.foreColor;\n      var backColor = colorInfo.backColor;\n\n      if (foreColor) { document.execCommand('foreColor', false, foreColor); }\n      if (backColor) { document.execCommand('backColor', false, backColor); }\n    });\n\n    /**\n     * insert Table\n     *\n     * @param {String} dimension of table (ex : \"5x5\")\n     */\n    this.insertTable = this.wrapCommand(function (dim) {\n      var dimension = dim.split('x');\n\n      var rng = this.createRange().deleteContents();\n      rng.insertNode(table.createTable(dimension[0], dimension[1], options));\n    });\n\n    /**\n     * float me\n     *\n     * @param {String} value\n     */\n    this.floatMe = this.wrapCommand(function (value) {\n      var $target = $(this.restoreTarget());\n      $target.css('float', value);\n    });\n\n    /**\n     * resize overlay element\n     * @param {String} value\n     */\n    this.resize = this.wrapCommand(function (value) {\n      var $target = $(this.restoreTarget());\n      $target.css({\n        width: value * 100 + '%',\n        height: ''\n      });\n    });\n\n    /**\n     * @param {Position} pos\n     * @param {jQuery} $target - target element\n     * @param {Boolean} [bKeepRatio] - keep ratio\n     */\n    this.resizeTo = function (pos, $target, bKeepRatio) {\n      var imageSize;\n      if (bKeepRatio) {\n        var newRatio = pos.y / pos.x;\n        var ratio = $target.data('ratio');\n        imageSize = {\n          width: ratio > newRatio ? pos.x : pos.y / ratio,\n          height: ratio > newRatio ? pos.x * ratio : pos.y\n        };\n      } else {\n        imageSize = {\n          width: pos.x,\n          height: pos.y\n        };\n      }\n\n      $target.css(imageSize);\n    };\n\n    /**\n     * remove media object\n     */\n    this.removeMedia = this.wrapCommand(function () {\n      var $target = $(this.restoreTarget()).detach();\n      context.triggerEvent('media.delete', $target, $editable);\n    });\n\n    /**\n     * returns whether editable area has focus or not.\n     */\n    this.hasFocus = function () {\n      return $editable.is(':focus');\n    };\n\n    /**\n     * set focus\n     */\n    this.focus = function () {\n      // [workaround] Screen will move when page is scolled in IE.\n      //  - do focus when not focused\n      if (!this.hasFocus()) {\n        $editable.focus();\n      }\n    };\n\n    /**\n     * returns whether contents is empty or not.\n     * @return {Boolean}\n     */\n    this.isEmpty = function () {\n      return dom.isEmpty($editable[0]) || dom.emptyPara === $editable.html();\n    };\n\n    /**\n     * Removes all contents and restores the editable instance to an _emptyPara_.\n     */\n    this.empty = function () {\n      context.invoke('code', dom.emptyPara);\n    };\n\n    /**\n     * set height for editable\n     */\n    this.setHeight = function (height) {\n      $editable.outerHeight(height);\n    };\n  };\n\n  var Clipboard = function (context) {\n    var self = this;\n\n    var $editable = context.layoutInfo.editable;\n\n    this.events = {\n      'summernote.keydown': function (we, e) {\n        if (self.needKeydownHook()) {\n          if ((e.ctrlKey || e.metaKey) && e.keyCode === key.code.V) {\n            context.invoke('editor.saveRange');\n            self.$paste.focus();\n\n            setTimeout(function () {\n              self.pasteByHook();\n            }, 0);\n          }\n        }\n      }\n    };\n\n    this.needKeydownHook = function () {\n      return (agent.isMSIE && agent.browserVersion > 10) || agent.isFF;\n    };\n\n    this.initialize = function () {\n      // [workaround] getting image from clipboard\n      //  - IE11 and Firefox: CTRL+v hook\n      //  - Webkit: event.clipboardData\n      if (this.needKeydownHook()) {\n        this.$paste = $('<div />').attr('contenteditable', true).css({\n          position: 'absolute',\n          left: -100000,\n          opacity: 0\n        });\n        $editable.before(this.$paste);\n\n        this.$paste.on('paste', function (event) {\n          context.triggerEvent('paste', event);\n        });\n      } else {\n        $editable.on('paste', this.pasteByEvent);\n      }\n    };\n\n    this.destroy = function () {\n      if (this.needKeydownHook()) {\n        this.$paste.remove();\n        this.$paste = null;\n      }\n    };\n\n    this.pasteByHook = function () {\n      var node = this.$paste[0].firstChild;\n\n      if (dom.isImg(node)) {\n        var dataURI = node.src;\n        var decodedData = atob(dataURI.split(',')[1]);\n        var array = new Uint8Array(decodedData.length);\n        for (var i = 0; i < decodedData.length; i++) {\n          array[i] = decodedData.charCodeAt(i);\n        }\n\n        var blob = new Blob([array], { type: 'image/png' });\n        blob.name = 'clipboard.png';\n\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.focus');\n        context.invoke('editor.insertImagesOrCallback', [blob]);\n      } else {\n        var pasteContent = $('<div />').html(this.$paste.html()).html();\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.focus');\n\n        if (pasteContent) {\n          context.invoke('editor.pasteHTML', pasteContent);\n        }\n      }\n\n      this.$paste.empty();\n    };\n\n    /**\n     * paste by clipboard event\n     *\n     * @param {Event} event\n     */\n    this.pasteByEvent = function (event) {\n      var clipboardData = event.originalEvent.clipboardData;\n      if (clipboardData && clipboardData.items && clipboardData.items.length) {\n        var item = list.head(clipboardData.items);\n        if (item.kind === 'file' && item.type.indexOf('image/') !== -1) {\n          context.invoke('editor.insertImagesOrCallback', [item.getAsFile()]);\n        }\n        context.invoke('editor.afterCommand');\n      }\n    };\n  };\n\n  var Dropzone = function (context) {\n    var $document = $(document);\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    var $dropzone = $([\n      '<div class=\"note-dropzone\">',\n      '  <div class=\"note-dropzone-message\"/>',\n      '</div>'\n    ].join('')).prependTo($editor);\n\n    /**\n     * attach Drag and Drop Events\n     */\n    this.initialize = function () {\n      if (options.disableDragAndDrop) {\n        // prevent default drop event\n        $document.on('drop', function (e) {\n          e.preventDefault();\n        });\n      } else {\n        this.attachDragAndDropEvent();\n      }\n    };\n\n    /**\n     * attach Drag and Drop Events\n     */\n    this.attachDragAndDropEvent = function () {\n      var collection = $(),\n          $dropzoneMessage = $dropzone.find('.note-dropzone-message');\n\n      // show dropzone on dragenter when dragging a object to document\n      // -but only if the editor is visible, i.e. has a positive width and height\n      $document.on('dragenter', function (e) {\n        var isCodeview = context.invoke('codeview.isActivated');\n        var hasEditorSize = $editor.width() > 0 && $editor.height() > 0;\n        if (!isCodeview && !collection.length && hasEditorSize) {\n          $editor.addClass('dragover');\n          $dropzone.width($editor.width());\n          $dropzone.height($editor.height());\n          $dropzoneMessage.text(lang.image.dragImageHere);\n        }\n        collection = collection.add(e.target);\n      }).on('dragleave', function (e) {\n        collection = collection.not(e.target);\n        if (!collection.length) {\n          $editor.removeClass('dragover');\n        }\n      }).on('drop', function () {\n        collection = $();\n        $editor.removeClass('dragover');\n      });\n\n      // change dropzone's message on hover.\n      $dropzone.on('dragenter', function () {\n        $dropzone.addClass('hover');\n        $dropzoneMessage.text(lang.image.dropImage);\n      }).on('dragleave', function () {\n        $dropzone.removeClass('hover');\n        $dropzoneMessage.text(lang.image.dragImageHere);\n      });\n\n      // attach dropImage\n      $dropzone.on('drop', function (event) {\n        var dataTransfer = event.originalEvent.dataTransfer;\n\n        if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {\n          event.preventDefault();\n          $editable.focus();\n          context.invoke('editor.insertImagesOrCallback', dataTransfer.files);\n        } else {\n          $.each(dataTransfer.types, function (idx, type) {\n            var content = dataTransfer.getData(type);\n\n            if (type.toLowerCase().indexOf('text') > -1) {\n              context.invoke('editor.pasteHTML', content);\n            } else {\n              $(content).each(function () {\n                context.invoke('editor.insertNode', this);\n              });\n            }\n          });\n        }\n      }).on('dragover', false); // prevent default dragover event\n    };\n  };\n\n\n  var CodeMirror;\n  if (agent.hasCodeMirror) {\n    if (agent.isSupportAmd) {\n      require(['codemirror'], function (cm) {\n        CodeMirror = cm;\n      });\n    } else {\n      CodeMirror = window.CodeMirror;\n    }\n  }\n\n  /**\n   * @class Codeview\n   */\n  var Codeview = function (context) {\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var $codable = context.layoutInfo.codable;\n    var options = context.options;\n\n    this.sync = function () {\n      var isCodeview = this.isActivated();\n      if (isCodeview && agent.hasCodeMirror) {\n        $codable.data('cmEditor').save();\n      }\n    };\n\n    /**\n     * @return {Boolean}\n     */\n    this.isActivated = function () {\n      return $editor.hasClass('codeview');\n    };\n\n    /**\n     * toggle codeview\n     */\n    this.toggle = function () {\n      if (this.isActivated()) {\n        this.deactivate();\n      } else {\n        this.activate();\n      }\n      context.triggerEvent('codeview.toggled');\n    };\n\n    /**\n     * activate code view\n     */\n    this.activate = function () {\n      $codable.val(dom.html($editable, options.prettifyHtml));\n      $codable.height($editable.height());\n\n      context.invoke('toolbar.updateCodeview', true);\n      $editor.addClass('codeview');\n      $codable.focus();\n\n      // activate CodeMirror as codable\n      if (agent.hasCodeMirror) {\n        var cmEditor = CodeMirror.fromTextArea($codable[0], options.codemirror);\n\n        // CodeMirror TernServer\n        if (options.codemirror.tern) {\n          var server = new CodeMirror.TernServer(options.codemirror.tern);\n          cmEditor.ternServer = server;\n          cmEditor.on('cursorActivity', function (cm) {\n            server.updateArgHints(cm);\n          });\n        }\n\n        // CodeMirror hasn't Padding.\n        cmEditor.setSize(null, $editable.outerHeight());\n        $codable.data('cmEditor', cmEditor);\n      }\n    };\n\n    /**\n     * deactivate code view\n     */\n    this.deactivate = function () {\n      // deactivate CodeMirror as codable\n      if (agent.hasCodeMirror) {\n        var cmEditor = $codable.data('cmEditor');\n        $codable.val(cmEditor.getValue());\n        cmEditor.toTextArea();\n      }\n\n      var value = dom.value($codable, options.prettifyHtml) || dom.emptyPara;\n      var isChange = $editable.html() !== value;\n\n      $editable.html(value);\n      $editable.height(options.height ? $codable.height() : 'auto');\n      $editor.removeClass('codeview');\n\n      if (isChange) {\n        context.triggerEvent('change', $editable.html(), $editable);\n      }\n\n      $editable.focus();\n\n      context.invoke('toolbar.updateCodeview', false);\n    };\n\n    this.destroy = function () {\n      if (this.isActivated()) {\n        this.deactivate();\n      }\n    };\n  };\n\n  var EDITABLE_PADDING = 24;\n\n  var Statusbar = function (context) {\n    var $document = $(document);\n    var $statusbar = context.layoutInfo.statusbar;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n\n    this.initialize = function () {\n      if (options.airMode || options.disableResizeEditor) {\n        return;\n      }\n\n      $statusbar.on('mousedown', function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        var editableTop = $editable.offset().top - $document.scrollTop();\n\n        $document.on('mousemove', function (event) {\n          var height = event.clientY - (editableTop + EDITABLE_PADDING);\n\n          height = (options.minheight > 0) ? Math.max(height, options.minheight) : height;\n          height = (options.maxHeight > 0) ? Math.min(height, options.maxHeight) : height;\n\n          $editable.height(height);\n        }).one('mouseup', function () {\n          $document.off('mousemove');\n        });\n      });\n    };\n\n    this.destroy = function () {\n      $statusbar.off();\n    };\n  };\n\n  var Fullscreen = function (context) {\n    var $editor = context.layoutInfo.editor;\n    var $toolbar = context.layoutInfo.toolbar;\n    var $editable = context.layoutInfo.editable;\n    var $codable = context.layoutInfo.codable;\n\n    var $window = $(window);\n    var $scrollbar = $('html, body');\n\n    /**\n     * toggle fullscreen\n     */\n    this.toggle = function () {\n      var resize = function (size) {\n        $editable.css('height', size.h);\n        $codable.css('height', size.h);\n        if ($codable.data('cmeditor')) {\n          $codable.data('cmeditor').setsize(null, size.h);\n        }\n      };\n\n      $editor.toggleClass('fullscreen');\n      if (this.isFullscreen()) {\n        $editable.data('orgHeight', $editable.css('height'));\n\n        $window.on('resize', function () {\n          resize({\n            h: $window.height() - $toolbar.outerHeight()\n          });\n        }).trigger('resize');\n\n        $scrollbar.css('overflow', 'hidden');\n      } else {\n        $window.off('resize');\n        resize({\n          h: $editable.data('orgHeight')\n        });\n        $scrollbar.css('overflow', 'visible');\n      }\n\n      context.invoke('toolbar.updateFullscreen', this.isFullscreen());\n    };\n\n    this.isFullscreen = function () {\n      return $editor.hasClass('fullscreen');\n    };\n  };\n\n  var Handle = function (context) {\n    var self = this;\n\n    var $document = $(document);\n    var $editingArea = context.layoutInfo.editingArea;\n    var options = context.options;\n\n    this.events = {\n      'summernote.mousedown': function (we, e) {\n        if (self.update(e.target)) {\n          e.preventDefault();\n        }\n      },\n      'summernote.keyup summernote.scroll summernote.change summernote.dialog.shown': function () {\n        self.update();\n      }\n    };\n\n    this.initialize = function () {\n      this.$handle = $([\n        '<div class=\"note-handle\">',\n        '<div class=\"note-control-selection\">',\n        '<div class=\"note-control-selection-bg\"></div>',\n        '<div class=\"note-control-holder note-control-nw\"></div>',\n        '<div class=\"note-control-holder note-control-ne\"></div>',\n        '<div class=\"note-control-holder note-control-sw\"></div>',\n        '<div class=\"',\n        (options.disableResizeImage ? 'note-control-holder' : 'note-control-sizing'),\n        ' note-control-se\"></div>',\n        (options.disableResizeImage ? '' : '<div class=\"note-control-selection-info\"></div>'),\n        '</div>',\n        '</div>'\n      ].join('')).prependTo($editingArea);\n\n      this.$handle.on('mousedown', function (event) {\n        if (dom.isControlSizing(event.target)) {\n          event.preventDefault();\n          event.stopPropagation();\n\n          var $target = self.$handle.find('.note-control-selection').data('target'),\n              posStart = $target.offset(),\n              scrollTop = $document.scrollTop();\n\n          $document.on('mousemove', function (event) {\n            context.invoke('editor.resizeTo', {\n              x: event.clientX - posStart.left,\n              y: event.clientY - (posStart.top - scrollTop)\n            }, $target, !event.shiftKey);\n\n            self.update($target[0]);\n          }).one('mouseup', function (e) {\n            e.preventDefault();\n            $document.off('mousemove');\n            context.invoke('editor.afterCommand');\n          });\n\n          if (!$target.data('ratio')) { // original ratio.\n            $target.data('ratio', $target.height() / $target.width());\n          }\n        }\n      });\n    };\n\n    this.destroy = function () {\n      this.$handle.remove();\n    };\n\n    this.update = function (target) {\n      var isImage = dom.isImg(target);\n      var $selection = this.$handle.find('.note-control-selection');\n\n      context.invoke('imagePopover.update', target);\n\n      if (isImage) {\n        var $image = $(target);\n        var pos = $image.position();\n\n        // include margin\n        var imageSize = {\n          w: $image.outerWidth(true),\n          h: $image.outerHeight(true)\n        };\n\n        $selection.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top,\n          width: imageSize.w,\n          height: imageSize.h\n        }).data('target', $image); // save current image element.\n\n        var sizingText = imageSize.w + 'x' + imageSize.h;\n        $selection.find('.note-control-selection-info').text(sizingText);\n        context.invoke('editor.saveTarget', target);\n      } else {\n        this.hide();\n      }\n\n      return isImage;\n    };\n\n    /**\n     * hide\n     *\n     * @param {jQuery} $handle\n     */\n    this.hide = function () {\n      context.invoke('editor.clearTarget');\n      this.$handle.children().hide();\n    };\n  };\n\n  var AutoLink = function (context) {\n    var self = this;\n    var defaultScheme = 'http://';\n    var linkPattern = /^(https?:\\/\\/|ssh:\\/\\/|ftp:\\/\\/|file:\\/|mailto:[A-Z0-9._%+-]+@)?(www\\.)?(.+)$/i;\n\n    this.events = {\n      'summernote.keyup': function (we, e) {\n        if (!e.isDefaultPrevented()) {\n          self.handleKeyup(e);\n        }\n      },\n      'summernote.keydown': function (we, e) {\n        self.handleKeydown(e);\n      }\n    };\n\n    this.initialize = function () {\n      this.lastWordRange = null;\n    };\n\n    this.destroy = function () {\n      this.lastWordRange = null;\n    };\n\n    this.replace = function () {\n      if (!this.lastWordRange) {\n        return;\n      }\n\n      var keyword = this.lastWordRange.toString();\n      var match = keyword.match(linkPattern);\n\n      if (match && (match[1] || match[2])) {\n        var link = match[1] ? keyword : defaultScheme + keyword;\n        var node = $('<a />').html(keyword).attr('href', link)[0];\n\n        this.lastWordRange.insertNode(node);\n        this.lastWordRange = null;\n        context.invoke('editor.focus');\n      }\n\n    };\n\n    this.handleKeydown = function (e) {\n      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {\n        var wordRange = context.invoke('editor.createRange').getWordRange();\n        this.lastWordRange = wordRange;\n      }\n    };\n\n    this.handleKeyup = function (e) {\n      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {\n        this.replace();\n      }\n    };\n  };\n\n  /**\n   * textarea auto sync.\n   */\n  var AutoSync = function (context) {\n    var $note = context.layoutInfo.note;\n\n    this.events = {\n      'summernote.change': function () {\n        $note.val(context.invoke('code'));\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return dom.isTextarea($note[0]);\n    };\n  };\n\n  var Placeholder = function (context) {\n    var self = this;\n    var $editingArea = context.layoutInfo.editingArea;\n    var options = context.options;\n\n    this.events = {\n      'summernote.init summernote.change': function () {\n        self.update();\n      },\n      'summernote.codeview.toggled': function () {\n        self.update();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return !!options.placeholder;\n    };\n\n    this.initialize = function () {\n      this.$placeholder = $('<div class=\"note-placeholder\">');\n      this.$placeholder.on('click', function () {\n        context.invoke('focus');\n      }).text(options.placeholder).prependTo($editingArea);\n    };\n\n    this.destroy = function () {\n      this.$placeholder.remove();\n    };\n\n    this.update = function () {\n      var isShow = !context.invoke('codeview.isActivated') && context.invoke('editor.isEmpty');\n      this.$placeholder.toggle(isShow);\n    };\n  };\n\n  var Buttons = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $toolbar = context.layoutInfo.toolbar;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    var invertedKeyMap = func.invertObject(options.keyMap[agent.isMac ? 'mac' : 'pc']);\n\n    var representShortcut = this.representShortcut = function (editorMethod) {\n      var shortcut = invertedKeyMap[editorMethod];\n      if (agent.isMac) {\n        shortcut = shortcut.replace('CMD', '⌘').replace('SHIFT', '⇧');\n      }\n\n      shortcut = shortcut.replace('BACKSLASH', '\\\\')\n                         .replace('SLASH', '/')\n                         .replace('LEFTBRACKET', '[')\n                         .replace('RIGHTBRACKET', ']');\n\n      return ' (' + shortcut + ')';\n    };\n\n    this.initialize = function () {\n      this.addToolbarButtons();\n      this.addImagePopoverButtons();\n      this.addLinkPopoverButtons();\n      this.fontInstalledMap = {};\n    };\n\n    this.destroy = function () {\n      delete this.fontInstalledMap;\n    };\n\n    this.isFontInstalled = function (name) {\n      if (!self.fontInstalledMap.hasOwnProperty(name)) {\n        self.fontInstalledMap[name] = agent.isFontInstalled(name) ||\n          list.contains(options.fontNamesIgnoreCheck, name);\n      }\n\n      return self.fontInstalledMap[name];\n    };\n\n    this.addToolbarButtons = function () {\n      context.memo('button.style', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.magic) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.style.style,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown({\n            className: 'dropdown-style',\n            items: context.options.styleTags,\n            template: function (item) {\n\n              if (typeof item === 'string') {\n                item = { tag: item, title: item };\n              }\n\n              var tag = item.tag;\n              var title = item.title;\n              var style = item.style ? ' style=\"' + item.style + '\" ' : '';\n              var className = item.className ? ' className=\"' + item.className + '\"' : '';\n\n              return '<' + tag + style + className + '>' + title + '</' + tag +  '>';\n            },\n            click: context.createInvokeHandler('editor.formatBlock')\n          })\n        ]).render();\n      });\n\n      context.memo('button.bold', function () {\n        return ui.button({\n          className: 'note-btn-bold',\n          contents: ui.icon(options.icons.bold),\n          tooltip: lang.font.bold + representShortcut('bold'),\n          click: context.createInvokeHandler('editor.bold')\n        }).render();\n      });\n\n      context.memo('button.italic', function () {\n        return ui.button({\n          className: 'note-btn-italic',\n          contents: ui.icon(options.icons.italic),\n          tooltip: lang.font.italic + representShortcut('italic'),\n          click: context.createInvokeHandler('editor.italic')\n        }).render();\n      });\n\n      context.memo('button.underline', function () {\n        return ui.button({\n          className: 'note-btn-underline',\n          contents: ui.icon(options.icons.underline),\n          tooltip: lang.font.underline + representShortcut('underline'),\n          click: context.createInvokeHandler('editor.underline')\n        }).render();\n      });\n\n      context.memo('button.clear', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.eraser),\n          tooltip: lang.font.clear + representShortcut('removeFormat'),\n          click: context.createInvokeHandler('editor.removeFormat')\n        }).render();\n      });\n\n      context.memo('button.strikethrough', function () {\n        return ui.button({\n          className: 'note-btn-strikethrough',\n          contents: ui.icon(options.icons.strikethrough),\n          tooltip: lang.font.strikethrough + representShortcut('strikethrough'),\n          click: context.createInvokeHandler('editor.strikethrough')\n        }).render();\n      });\n\n      context.memo('button.superscript', function () {\n        return ui.button({\n          className: 'note-btn-superscript',\n          contents: ui.icon(options.icons.superscript),\n          tooltip: lang.font.superscript,\n          click: context.createInvokeHandler('editor.superscript')\n        }).render();\n      });\n\n      context.memo('button.subscript', function () {\n        return ui.button({\n          className: 'note-btn-subscript',\n          contents: ui.icon(options.icons.subscript),\n          tooltip: lang.font.subscript,\n          click: context.createInvokeHandler('editor.subscript')\n        }).render();\n      });\n\n      context.memo('button.fontname', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: '<span class=\"note-current-fontname\"/> ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.font.name,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            className: 'dropdown-fontname',\n            checkClassName: options.icons.menuCheck,\n            items: options.fontNames.filter(self.isFontInstalled),\n            template: function (item) {\n              return '<span style=\"font-family:' + item + '\">' + item + '</span>';\n            },\n            click: context.createInvokeHandler('editor.fontName')\n          })\n        ]).render();\n      });\n\n      context.memo('button.fontsize', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: '<span class=\"note-current-fontsize\"/>' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.font.size,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            className: 'dropdown-fontsize',\n            checkClassName: options.icons.menuCheck,\n            items: options.fontSizes,\n            click: context.createInvokeHandler('editor.fontSize')\n          })\n        ]).render();\n      });\n\n      context.memo('button.color', function () {\n        return ui.buttonGroup({\n          className: 'note-color',\n          children: [\n            ui.button({\n              className: 'note-current-color-button',\n              contents: ui.icon(options.icons.font + ' note-recent-color'),\n              tooltip: lang.color.recent,\n              click: function (e) {\n                var $button = $(e.currentTarget);\n                context.invoke('editor.color', {\n                  backColor: $button.attr('data-backColor'),\n                  foreColor: $button.attr('data-foreColor')\n                });\n              },\n              callback: function ($button) {\n                var $recentColor = $button.find('.note-recent-color');\n                $recentColor.css('background-color', '#FFFF00');\n                $button.attr('data-backColor', '#FFFF00');\n              }\n            }),\n            ui.button({\n              className: 'dropdown-toggle',\n              contents: ui.icon(options.icons.caret, 'span'),\n              tooltip: lang.color.more,\n              data: {\n                toggle: 'dropdown'\n              }\n            }),\n            ui.dropdown({\n              items: [\n                '<li>',\n                '<div class=\"btn-group\">',\n                '  <div class=\"note-palette-title\">' + lang.color.background + '</div>',\n                '  <div>',\n                '    <button type=\"button\" class=\"note-color-reset btn btn-default\" data-event=\"backColor\" data-value=\"inherit\">',\n                lang.color.transparent,\n                '    </button>',\n                '  </div>',\n                '  <div class=\"note-holder\" data-event=\"backColor\"/>',\n                '</div>',\n                '<div class=\"btn-group\">',\n                '  <div class=\"note-palette-title\">' + lang.color.foreground + '</div>',\n                '  <div>',\n                '    <button type=\"button\" class=\"note-color-reset btn btn-default\" data-event=\"removeFormat\" data-value=\"foreColor\">',\n                lang.color.resetToDefault,\n                '    </button>',\n                '  </div>',\n                '  <div class=\"note-holder\" data-event=\"foreColor\"/>',\n                '</div>',\n                '</li>'\n              ].join(''),\n              callback: function ($dropdown) {\n                $dropdown.find('.note-holder').each(function () {\n                  var $holder = $(this);\n                  $holder.append(ui.palette({\n                    colors: options.colors,\n                    eventName: $holder.data('event')\n                  }).render());\n                });\n              },\n              click: function (event) {\n                var $button = $(event.target);\n                var eventName = $button.data('event');\n                var value = $button.data('value');\n\n                if (eventName && value) {\n                  var key = eventName === 'backColor' ? 'background-color' : 'color';\n                  var $color = $button.closest('.note-color').find('.note-recent-color');\n                  var $currentButton = $button.closest('.note-color').find('.note-current-color-button');\n\n                  $color.css(key, value);\n                  $currentButton.attr('data-' + eventName, value);\n                  context.invoke('editor.' + eventName, value);\n                }\n              }\n            })\n          ]\n        }).render();\n      });\n\n      context.memo('button.ul',  function () {\n        return ui.button({\n          contents: ui.icon(options.icons.unorderedlist),\n          tooltip: lang.lists.unordered + representShortcut('insertUnorderedList'),\n          click: context.createInvokeHandler('editor.insertUnorderedList')\n        }).render();\n      });\n\n      context.memo('button.ol', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.orderedlist),\n          tooltip: lang.lists.ordered + representShortcut('insertOrderedList'),\n          click:  context.createInvokeHandler('editor.insertOrderedList')\n        }).render();\n      });\n\n      var justifyLeft = ui.button({\n        contents: ui.icon(options.icons.alignLeft),\n        tooltip: lang.paragraph.left + representShortcut('justifyLeft'),\n        click: context.createInvokeHandler('editor.justifyLeft')\n      });\n\n      var justifyCenter = ui.button({\n        contents: ui.icon(options.icons.alignCenter),\n        tooltip: lang.paragraph.center + representShortcut('justifyCenter'),\n        click: context.createInvokeHandler('editor.justifyCenter')\n      });\n\n      var justifyRight = ui.button({\n        contents: ui.icon(options.icons.alignRight),\n        tooltip: lang.paragraph.right + representShortcut('justifyRight'),\n        click: context.createInvokeHandler('editor.justifyRight')\n      });\n\n      var justifyFull = ui.button({\n        contents: ui.icon(options.icons.alignJustify),\n        tooltip: lang.paragraph.justify + representShortcut('justifyFull'),\n        click: context.createInvokeHandler('editor.justifyFull')\n      });\n\n      var outdent = ui.button({\n        contents: ui.icon(options.icons.outdent),\n        tooltip: lang.paragraph.outdent + representShortcut('outdent'),\n        click: context.createInvokeHandler('editor.outdent')\n      });\n\n      var indent = ui.button({\n        contents: ui.icon(options.icons.indent),\n        tooltip: lang.paragraph.indent + representShortcut('indent'),\n        click: context.createInvokeHandler('editor.indent')\n      });\n\n      context.memo('button.justifyLeft', func.invoke(justifyLeft, 'render'));\n      context.memo('button.justifyCenter', func.invoke(justifyCenter, 'render'));\n      context.memo('button.justifyRight', func.invoke(justifyRight, 'render'));\n      context.memo('button.justifyFull', func.invoke(justifyFull, 'render'));\n      context.memo('button.outdent', func.invoke(outdent, 'render'));\n      context.memo('button.indent', func.invoke(indent, 'render'));\n\n      context.memo('button.paragraph', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.alignLeft) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.paragraph.paragraph,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown([\n            ui.buttonGroup({\n              className: 'note-align',\n              children: [justifyLeft, justifyCenter, justifyRight, justifyFull]\n            }),\n            ui.buttonGroup({\n              className: 'note-list',\n              children: [outdent, indent]\n            })\n          ])\n        ]).render();\n      });\n\n      context.memo('button.height', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.textHeight) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.font.height,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            items: options.lineHeights,\n            checkClassName: options.icons.menuCheck,\n            className: 'dropdown-line-height',\n            click: context.createInvokeHandler('editor.lineHeight')\n          })\n        ]).render();\n      });\n\n      context.memo('button.table', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.table) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.table.table,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown({\n            className: 'note-table',\n            items: [\n              '<div class=\"note-dimension-picker\">',\n              '  <div class=\"note-dimension-picker-mousecatcher\" data-event=\"insertTable\" data-value=\"1x1\"/>',\n              '  <div class=\"note-dimension-picker-highlighted\"/>',\n              '  <div class=\"note-dimension-picker-unhighlighted\"/>',\n              '</div>',\n              '<div class=\"note-dimension-display\">1 x 1</div>'\n            ].join('')\n          })\n        ], {\n          callback: function ($node) {\n            var $catcher = $node.find('.note-dimension-picker-mousecatcher');\n            $catcher.css({\n              width: options.insertTableMaxSize.col + 'em',\n              height: options.insertTableMaxSize.row + 'em'\n            }).mousedown(context.createInvokeHandler('editor.insertTable'))\n              .on('mousemove', self.tableMoveHandler);\n          }\n        }).render();\n      });\n\n      context.memo('button.link', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.link),\n          tooltip: lang.link.link,\n          click: context.createInvokeHandler('linkDialog.show')\n        }).render();\n      });\n\n      context.memo('button.picture', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.picture),\n          tooltip: lang.image.image,\n          click: context.createInvokeHandler('imageDialog.show')\n        }).render();\n      });\n\n      context.memo('button.video', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.video),\n          tooltip: lang.video.video,\n          click: context.createInvokeHandler('videoDialog.show')\n        }).render();\n      });\n\n      context.memo('button.hr', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.minus),\n          tooltip: lang.hr.insert + representShortcut('insertHorizontalRule'),\n          click: context.createInvokeHandler('editor.insertHorizontalRule')\n        }).render();\n      });\n\n      context.memo('button.fullscreen', function () {\n        return ui.button({\n          className: 'btn-fullscreen',\n          contents: ui.icon(options.icons.arrowsAlt),\n          tooltip: lang.options.fullscreen,\n          click: context.createInvokeHandler('fullscreen.toggle')\n        }).render();\n      });\n\n      context.memo('button.codeview', function () {\n        return ui.button({\n          className: 'btn-codeview',\n          contents: ui.icon(options.icons.code),\n          tooltip: lang.options.codeview,\n          click: context.createInvokeHandler('codeview.toggle')\n        }).render();\n      });\n\n      context.memo('button.redo', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.redo),\n          tooltip: lang.history.redo + representShortcut('redo'),\n          click: context.createInvokeHandler('editor.redo')\n        }).render();\n      });\n\n      context.memo('button.undo', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.undo),\n          tooltip: lang.history.undo + representShortcut('undo'),\n          click: context.createInvokeHandler('editor.undo')\n        }).render();\n      });\n\n      context.memo('button.help', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.question),\n          tooltip: lang.options.help,\n          click: context.createInvokeHandler('helpDialog.show')\n        }).render();\n      });\n    };\n\n    /**\n     * image : [\n     *   ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],\n     *   ['float', ['floatLeft', 'floatRight', 'floatNone' ]],\n     *   ['remove', ['removeMedia']]\n     * ],\n     */\n    this.addImagePopoverButtons = function () {\n      // Image Size Buttons\n      context.memo('button.imageSize100', function () {\n        return ui.button({\n          contents: '<span class=\"note-fontsize-10\">100%</span>',\n          tooltip: lang.image.resizeFull,\n          click: context.createInvokeHandler('editor.resize', '1')\n        }).render();\n      });\n      context.memo('button.imageSize50', function () {\n        return  ui.button({\n          contents: '<span class=\"note-fontsize-10\">50%</span>',\n          tooltip: lang.image.resizeHalf,\n          click: context.createInvokeHandler('editor.resize', '0.5')\n        }).render();\n      });\n      context.memo('button.imageSize25', function () {\n        return ui.button({\n          contents: '<span class=\"note-fontsize-10\">25%</span>',\n          tooltip: lang.image.resizeQuarter,\n          click: context.createInvokeHandler('editor.resize', '0.25')\n        }).render();\n      });\n\n      // Float Buttons\n      context.memo('button.floatLeft', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignLeft),\n          tooltip: lang.image.floatLeft,\n          click: context.createInvokeHandler('editor.floatMe', 'left')\n        }).render();\n      });\n\n      context.memo('button.floatRight', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignRight),\n          tooltip: lang.image.floatRight,\n          click: context.createInvokeHandler('editor.floatMe', 'right')\n        }).render();\n      });\n\n      context.memo('button.floatNone', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignJustify),\n          tooltip: lang.image.floatNone,\n          click: context.createInvokeHandler('editor.floatMe', 'none')\n        }).render();\n      });\n\n      // Remove Buttons\n      context.memo('button.removeMedia', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.trash),\n          tooltip: lang.image.remove,\n          click: context.createInvokeHandler('editor.removeMedia')\n        }).render();\n      });\n    };\n\n    this.addLinkPopoverButtons = function () {\n      context.memo('button.linkDialogShow', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.link),\n          tooltip: lang.link.edit,\n          click: context.createInvokeHandler('linkDialog.show')\n        }).render();\n      });\n\n      context.memo('button.unlink', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.unlink),\n          tooltip: lang.link.unlink,\n          click: context.createInvokeHandler('editor.unlink')\n        }).render();\n      });\n    };\n\n    this.build = function ($container, groups) {\n      for (var groupIdx = 0, groupLen = groups.length; groupIdx < groupLen; groupIdx++) {\n        var group = groups[groupIdx];\n        var groupName = group[0];\n        var buttons = group[1];\n\n        var $group = ui.buttonGroup({\n          className: 'note-' + groupName\n        }).render();\n\n        for (var idx = 0, len = buttons.length; idx < len; idx++) {\n          var button = context.memo('button.' + buttons[idx]);\n          if (button) {\n            $group.append(typeof button === 'function' ? button(context) : button);\n          }\n        }\n        $group.appendTo($container);\n      }\n    };\n\n    this.updateCurrentStyle = function () {\n      var styleInfo = context.invoke('editor.currentStyle');\n      this.updateBtnStates({\n        '.note-btn-bold': function () {\n          return styleInfo['font-bold'] === 'bold';\n        },\n        '.note-btn-italic': function () {\n          return styleInfo['font-italic'] === 'italic';\n        },\n        '.note-btn-underline': function () {\n          return styleInfo['font-underline'] === 'underline';\n        },\n        '.note-btn-subscript': function () {\n          return styleInfo['font-subscript'] === 'subscript';\n        },\n        '.note-btn-superscript': function () {\n          return styleInfo['font-superscript'] === 'superscript';\n        },\n        '.note-btn-strikethrough': function () {\n          return styleInfo['font-strikethrough'] === 'strikethrough';\n        }\n      });\n\n      if (styleInfo['font-family']) {\n        var fontNames = styleInfo['font-family'].split(',').map(function (name) {\n          return name.replace(/[\\'\\\"]/g, '')\n            .replace(/\\s+$/, '')\n            .replace(/^\\s+/, '');\n        });\n        var fontName = list.find(fontNames, self.isFontInstalled);\n\n        $toolbar.find('.dropdown-fontname li a').each(function () {\n          // always compare string to avoid creating another func.\n          var isChecked = ($(this).data('value') + '') === (fontName + '');\n          this.className = isChecked ? 'checked' : '';\n        });\n        $toolbar.find('.note-current-fontname').text(fontName);\n      }\n\n      if (styleInfo['font-size']) {\n        var fontSize = styleInfo['font-size'];\n        $toolbar.find('.dropdown-fontsize li a').each(function () {\n          // always compare with string to avoid creating another func.\n          var isChecked = ($(this).data('value') + '') === (fontSize + '');\n          this.className = isChecked ? 'checked' : '';\n        });\n        $toolbar.find('.note-current-fontsize').text(fontSize);\n      }\n\n      if (styleInfo['line-height']) {\n        var lineHeight = styleInfo['line-height'];\n        $toolbar.find('.dropdown-line-height li a').each(function () {\n          // always compare with string to avoid creating another func.\n          var isChecked = ($(this).data('value') + '') === (lineHeight + '');\n          this.className = isChecked ? 'checked' : '';\n        });\n      }\n    };\n\n    this.updateBtnStates = function (infos) {\n      $.each(infos, function (selector, pred) {\n        ui.toggleBtnActive($toolbar.find(selector), pred());\n      });\n    };\n\n    this.tableMoveHandler = function (event) {\n      var PX_PER_EM = 18;\n      var $picker = $(event.target.parentNode); // target is mousecatcher\n      var $dimensionDisplay = $picker.next();\n      var $catcher = $picker.find('.note-dimension-picker-mousecatcher');\n      var $highlighted = $picker.find('.note-dimension-picker-highlighted');\n      var $unhighlighted = $picker.find('.note-dimension-picker-unhighlighted');\n\n      var posOffset;\n      // HTML5 with jQuery - e.offsetX is undefined in Firefox\n      if (event.offsetX === undefined) {\n        var posCatcher = $(event.target).offset();\n        posOffset = {\n          x: event.pageX - posCatcher.left,\n          y: event.pageY - posCatcher.top\n        };\n      } else {\n        posOffset = {\n          x: event.offsetX,\n          y: event.offsetY\n        };\n      }\n\n      var dim = {\n        c: Math.ceil(posOffset.x / PX_PER_EM) || 1,\n        r: Math.ceil(posOffset.y / PX_PER_EM) || 1\n      };\n\n      $highlighted.css({ width: dim.c + 'em', height: dim.r + 'em' });\n      $catcher.data('value', dim.c + 'x' + dim.r);\n\n      if (3 < dim.c && dim.c < options.insertTableMaxSize.col) {\n        $unhighlighted.css({ width: dim.c + 1 + 'em'});\n      }\n\n      if (3 < dim.r && dim.r < options.insertTableMaxSize.row) {\n        $unhighlighted.css({ height: dim.r + 1 + 'em'});\n      }\n\n      $dimensionDisplay.html(dim.c + ' x ' + dim.r);\n    };\n  };\n\n  var Toolbar = function (context) {\n    var ui = $.summernote.ui;\n\n    var $note = context.layoutInfo.note;\n    var $toolbar = context.layoutInfo.toolbar;\n    var options = context.options;\n\n    this.shouldInitialize = function () {\n      return !options.airMode;\n    };\n\n    this.initialize = function () {\n      options.toolbar = options.toolbar || [];\n\n      if (!options.toolbar.length) {\n        $toolbar.hide();\n      } else {\n        context.invoke('buttons.build', $toolbar, options.toolbar);\n      }\n\n      if (options.toolbarContainer) {\n        $toolbar.appendTo(options.toolbarContainer);\n      }\n\n      $note.on('summernote.keyup summernote.mouseup summernote.change', function () {\n        context.invoke('buttons.updateCurrentStyle');\n      });\n\n      context.invoke('buttons.updateCurrentStyle');\n    };\n\n    this.destroy = function () {\n      $toolbar.children().remove();\n    };\n\n    this.updateFullscreen = function (isFullscreen) {\n      ui.toggleBtnActive($toolbar.find('.btn-fullscreen'), isFullscreen);\n    };\n\n    this.updateCodeview = function (isCodeview) {\n      ui.toggleBtnActive($toolbar.find('.btn-codeview'), isCodeview);\n      if (isCodeview) {\n        this.deactivate();\n      } else {\n        this.activate();\n      }\n    };\n\n    this.activate = function (isIncludeCodeview) {\n      var $btn = $toolbar.find('button');\n      if (!isIncludeCodeview) {\n        $btn = $btn.not('.btn-codeview');\n      }\n      ui.toggleBtn($btn, true);\n    };\n\n    this.deactivate = function (isIncludeCodeview) {\n      var $btn = $toolbar.find('button');\n      if (!isIncludeCodeview) {\n        $btn = $btn.not('.btn-codeview');\n      }\n      ui.toggleBtn($btn, false);\n    };\n  };\n\n  var LinkDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = '<div class=\"form-group\">' +\n                   '<label>' + lang.link.textToDisplay + '</label>' +\n                   '<input class=\"note-link-text form-control\" type=\"text\" />' +\n                 '</div>' +\n                 '<div class=\"form-group\">' +\n                   '<label>' + lang.link.url + '</label>' +\n                   '<input class=\"note-link-url form-control\" type=\"text\" value=\"http://\" />' +\n                 '</div>' +\n                 (!options.disableLinkTarget ?\n                   '<div class=\"checkbox\">' +\n                     '<label>' + '<input type=\"checkbox\" checked> ' + lang.link.openInNewWindow + '</label>' +\n                   '</div>' : ''\n                 );\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-link-btn disabled\" disabled>' + lang.link.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        className: 'link-dialog',\n        title: lang.link.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    /**\n     * Show link dialog and set event handlers on dialog controls.\n     *\n     * @param {Object} linkInfo\n     * @return {Promise}\n     */\n    this.showLinkDialog = function (linkInfo) {\n      return $.Deferred(function (deferred) {\n        var $linkText = self.$dialog.find('.note-link-text'),\n        $linkUrl = self.$dialog.find('.note-link-url'),\n        $linkBtn = self.$dialog.find('.note-link-btn'),\n        $openInNewWindow = self.$dialog.find('input[type=checkbox]');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          $linkText.val(linkInfo.text);\n\n          $linkText.on('input', function () {\n            ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());\n            // if linktext was modified by keyup,\n            // stop cloning text from linkUrl\n            linkInfo.text = $linkText.val();\n          });\n\n          // if no url was given, copy text to url\n          if (!linkInfo.url) {\n            linkInfo.url = linkInfo.text || 'http://';\n            ui.toggleBtn($linkBtn, linkInfo.text);\n          }\n\n          $linkUrl.on('input', function () {\n            ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());\n            // display same link on `Text to display` input\n            // when create a new link\n            if (!linkInfo.text) {\n              $linkText.val($linkUrl.val());\n            }\n          }).val(linkInfo.url).trigger('focus');\n\n          self.bindEnterKey($linkUrl, $linkBtn);\n          self.bindEnterKey($linkText, $linkBtn);\n\n          $openInNewWindow.prop('checked', linkInfo.isNewWindow);\n\n          $linkBtn.one('click', function (event) {\n            event.preventDefault();\n\n            deferred.resolve({\n              range: linkInfo.range,\n              url: $linkUrl.val(),\n              text: $linkText.val(),\n              isNewWindow: $openInNewWindow.is(':checked')\n            });\n            self.$dialog.modal('hide');\n          });\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          // detach events\n          $linkText.off('input keypress');\n          $linkUrl.off('input keypress');\n          $linkBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      }).promise();\n    };\n\n    /**\n     * @param {Object} layoutInfo\n     */\n    this.show = function () {\n      var linkInfo = context.invoke('editor.getLinkInfo');\n\n      context.invoke('editor.saveRange');\n      this.showLinkDialog(linkInfo).then(function (linkInfo) {\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.createLink', linkInfo);\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n    context.memo('help.linkDialog.show', options.langInfo.help['linkDialog.show']);\n  };\n\n  var LinkPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    this.events = {\n      'summernote.keyup summernote.mouseup summernote.change summernote.scroll': function () {\n        self.update();\n      },\n      'summernote.dialog.shown': function () {\n        self.hide();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return !list.isEmpty(options.popover.link);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-link-popover',\n        callback: function ($node) {\n          var $content = $node.find('.popover-content');\n          $content.prepend('<span><a target=\"_blank\"></a>&nbsp;</span>');\n        }\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.link);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function () {\n      // Prevent focusing on editable when invoke('code') is executed\n      if (!context.invoke('editor.hasFocus')) {\n        this.hide();\n        return;\n      }\n\n      var rng = context.invoke('editor.createRange');\n      if (rng.isCollapsed() && rng.isOnAnchor()) {\n        var anchor = dom.ancestor(rng.sc, dom.isAnchor);\n        var href = $(anchor).attr('href');\n        this.$popover.find('a').attr('href', href).html(href);\n\n        var pos = dom.posFromPlaceholder(anchor);\n        this.$popover.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top\n        });\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var ImageDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var imageLimitation = '';\n      if (options.maximumImageFileSize) {\n        var unit = Math.floor(Math.log(options.maximumImageFileSize) / Math.log(1024));\n        var readableSize = (options.maximumImageFileSize / Math.pow(1024, unit)).toFixed(2) * 1 +\n                           ' ' + ' KMGTP'[unit] + 'B';\n        imageLimitation = '<small>' + lang.image.maximumFileSize + ' : ' + readableSize + '</small>';\n      }\n\n      var body = '<div class=\"form-group note-group-select-from-files\">' +\n                   '<label>' + lang.image.selectFromFiles + '</label>' +\n                   '<input class=\"note-image-input form-control\" type=\"file\" name=\"files\" accept=\"image/*\" multiple=\"multiple\" />' +\n                   imageLimitation +\n                 '</div>' +\n                 '<div class=\"form-group\" style=\"overflow:auto;\">' +\n                   '<label>' + lang.image.url + '</label>' +\n                   '<input class=\"note-image-url form-control col-md-12\" type=\"text\" />' +\n                 '</div>';\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-image-btn disabled\" disabled>' + lang.image.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        title: lang.image.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    this.show = function () {\n      context.invoke('editor.saveRange');\n      this.showImageDialog().then(function (data) {\n        // [workaround] hide dialog before restore range for IE range focus\n        ui.hideDialog(self.$dialog);\n        context.invoke('editor.restoreRange');\n\n        if (typeof data === 'string') { // image url\n          context.invoke('editor.insertImage', data);\n        } else { // array of files\n          context.invoke('editor.insertImagesOrCallback', data);\n        }\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n\n    /**\n     * show image dialog\n     *\n     * @param {jQuery} $dialog\n     * @return {Promise}\n     */\n    this.showImageDialog = function () {\n      return $.Deferred(function (deferred) {\n        var $imageInput = self.$dialog.find('.note-image-input'),\n            $imageUrl = self.$dialog.find('.note-image-url'),\n            $imageBtn = self.$dialog.find('.note-image-btn');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          // Cloning imageInput to clear element.\n          $imageInput.replaceWith($imageInput.clone()\n            .on('change', function () {\n              deferred.resolve(this.files || this.value);\n            })\n            .val('')\n          );\n\n          $imageBtn.click(function (event) {\n            event.preventDefault();\n\n            deferred.resolve($imageUrl.val());\n          });\n\n          $imageUrl.on('keyup paste', function () {\n            var url = $imageUrl.val();\n            ui.toggleBtn($imageBtn, url);\n          }).val('').trigger('focus');\n          self.bindEnterKey($imageUrl, $imageBtn);\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          $imageInput.off('change');\n          $imageUrl.off('keyup paste keypress');\n          $imageBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      });\n    };\n  };\n\n  var ImagePopover = function (context) {\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    this.shouldInitialize = function () {\n      return !list.isEmpty(options.popover.image);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-image-popover'\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.image);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function (target) {\n      if (dom.isImg(target)) {\n        var pos = dom.posFromPlaceholder(target);\n        this.$popover.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top\n        });\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var VideoDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = '<div class=\"form-group row-fluid\">' +\n          '<label>' + lang.video.url + ' <small class=\"text-muted\">' + lang.video.providers + '</small></label>' +\n          '<input class=\"note-video-url form-control span12\" type=\"text\" />' +\n          '</div>';\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-video-btn disabled\" disabled>' + lang.video.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        title: lang.video.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    this.createVideoNode = function (url) {\n      // video url patterns(youtube, instagram, vimeo, dailymotion, youku, mp4, ogg, webm)\n      var ytRegExp = /^(?:https?:\\/\\/)?(?:www\\.)?(?:youtu\\.be\\/|youtube\\.com\\/(?:embed\\/|v\\/|watch\\?v=|watch\\?.+&v=))((\\w|-){11})(?:\\S+)?$/;\n      var ytMatch = url.match(ytRegExp);\n\n      var igRegExp = /\\/\\/instagram.com\\/p\\/(.[a-zA-Z0-9_-]*)/;\n      var igMatch = url.match(igRegExp);\n\n      var vRegExp = /\\/\\/vine.co\\/v\\/(.[a-zA-Z0-9]*)/;\n      var vMatch = url.match(vRegExp);\n\n      var vimRegExp = /\\/\\/(player.)?vimeo.com\\/([a-z]*\\/)*([0-9]{6,11})[?]?.*/;\n      var vimMatch = url.match(vimRegExp);\n\n      var dmRegExp = /.+dailymotion.com\\/(video|hub)\\/([^_]+)[^#]*(#video=([^_&]+))?/;\n      var dmMatch = url.match(dmRegExp);\n\n      var youkuRegExp = /\\/\\/v\\.youku\\.com\\/v_show\\/id_(\\w+)=*\\.html/;\n      var youkuMatch = url.match(youkuRegExp);\n\n      var mp4RegExp = /^.+.(mp4|m4v)$/;\n      var mp4Match = url.match(mp4RegExp);\n\n      var oggRegExp = /^.+.(ogg|ogv)$/;\n      var oggMatch = url.match(oggRegExp);\n\n      var webmRegExp = /^.+.(webm)$/;\n      var webmMatch = url.match(webmRegExp);\n\n      var $video;\n      if (ytMatch && ytMatch[1].length === 11) {\n        var youtubeId = ytMatch[1];\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', '//www.youtube.com/embed/' + youtubeId)\n            .attr('width', '640').attr('height', '360');\n      } else if (igMatch && igMatch[0].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', igMatch[0] + '/embed/')\n            .attr('width', '612').attr('height', '710')\n            .attr('scrolling', 'no')\n            .attr('allowtransparency', 'true');\n      } else if (vMatch && vMatch[0].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', vMatch[0] + '/embed/simple')\n            .attr('width', '600').attr('height', '600')\n            .attr('class', 'vine-embed');\n      } else if (vimMatch && vimMatch[3].length) {\n        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n            .attr('frameborder', 0)\n            .attr('src', '//player.vimeo.com/video/' + vimMatch[3])\n            .attr('width', '640').attr('height', '360');\n      } else if (dmMatch && dmMatch[2].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', '//www.dailymotion.com/embed/video/' + dmMatch[2])\n            .attr('width', '640').attr('height', '360');\n      } else if (youkuMatch && youkuMatch[1].length) {\n        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n            .attr('frameborder', 0)\n            .attr('height', '498')\n            .attr('width', '510')\n            .attr('src', '//player.youku.com/embed/' + youkuMatch[1]);\n      } else if (mp4Match || oggMatch || webmMatch) {\n        $video = $('<video controls>')\n            .attr('src', url)\n            .attr('width', '640').attr('height', '360');\n      } else {\n        // this is not a known video link. Now what, Cat? Now what?\n        return false;\n      }\n\n      $video.addClass('note-video-clip');\n\n      return $video[0];\n    };\n\n    this.show = function () {\n      var text = context.invoke('editor.getSelectedText');\n      context.invoke('editor.saveRange');\n      this.showVideoDialog(text).then(function (url) {\n        // [workaround] hide dialog before restore range for IE range focus\n        ui.hideDialog(self.$dialog);\n        context.invoke('editor.restoreRange');\n\n        // build node\n        var $node = self.createVideoNode(url);\n\n        if ($node) {\n          // insert video node\n          context.invoke('editor.insertNode', $node);\n        }\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n\n    /**\n     * show image dialog\n     *\n     * @param {jQuery} $dialog\n     * @return {Promise}\n     */\n    this.showVideoDialog = function (text) {\n      return $.Deferred(function (deferred) {\n        var $videoUrl = self.$dialog.find('.note-video-url'),\n            $videoBtn = self.$dialog.find('.note-video-btn');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          $videoUrl.val(text).on('input', function () {\n            ui.toggleBtn($videoBtn, $videoUrl.val());\n          }).trigger('focus');\n\n          $videoBtn.click(function (event) {\n            event.preventDefault();\n\n            deferred.resolve($videoUrl.val());\n          });\n\n          self.bindEnterKey($videoUrl, $videoBtn);\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          $videoUrl.off('input');\n          $videoBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      });\n    };\n  };\n\n  var HelpDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.createShortCutList = function () {\n      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n      return Object.keys(keyMap).map(function (key) {\n        var command = keyMap[key];\n        var $row = $('<div><div class=\"help-list-item\"/></div>');\n        $row.append($('<label><kbd>' + key + '</kdb></label>').css({\n          'width': 180,\n          'margin-right': 10\n        })).append($('<span/>').html(context.memo('help.' + command) || command));\n        return $row.html();\n      }).join('');\n    };\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = [\n        '<p class=\"text-center\">',\n        '<a href=\"//summernote.org/\" target=\"_blank\">Summernote 0.8.1</a> · ',\n        '<a href=\"//github.com/summernote/summernote\" target=\"_blank\">Project</a> · ',\n        '<a href=\"//github.com/summernote/summernote/issues\" target=\"_blank\">Issues</a>',\n        '</p>'\n      ].join('');\n\n      this.$dialog = ui.dialog({\n        title: lang.options.help,\n        fade: options.dialogsFade,\n        body: this.createShortCutList(),\n        footer: body,\n        callback: function ($node) {\n          $node.find('.modal-body').css({\n            'max-height': 300,\n            'overflow': 'scroll'\n          });\n        }\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    /**\n     * show help dialog\n     *\n     * @return {Promise}\n     */\n    this.showHelpDialog = function () {\n      return $.Deferred(function (deferred) {\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n          deferred.resolve();\n        });\n        ui.showDialog(self.$dialog);\n      }).promise();\n    };\n\n    this.show = function () {\n      context.invoke('editor.saveRange');\n      this.showHelpDialog().then(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n  };\n\n  var AirPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    var AIR_MODE_POPOVER_X_OFFSET = 20;\n\n    this.events = {\n      'summernote.keyup summernote.mouseup summernote.scroll': function () {\n        self.update();\n      },\n      'summernote.change summernote.dialog.shown': function () {\n        self.hide();\n      },\n      'summernote.focusout': function (we, e) {\n        // [workaround] Firefox doesn't support relatedTarget on focusout\n        //  - Ignore hide action on focus out in FF.\n        if (agent.isFF) {\n          return;\n        }\n\n        if (!e.relatedTarget || !dom.ancestor(e.relatedTarget, func.eq(self.$popover[0]))) {\n          self.hide();\n        }\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return options.airMode && !list.isEmpty(options.popover.air);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-air-popover'\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.air);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function () {\n      var styleInfo = context.invoke('editor.currentStyle');\n      if (styleInfo.range && !styleInfo.range.isCollapsed()) {\n        var rect = list.last(styleInfo.range.getClientRects());\n        if (rect) {\n          var bnd = func.rect2bnd(rect);\n          this.$popover.css({\n            display: 'block',\n            left: Math.max(bnd.left + bnd.width / 2, 0) - AIR_MODE_POPOVER_X_OFFSET,\n            top: bnd.top + bnd.height\n          });\n        }\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var HintPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var POPOVER_DIST = 5;\n    var hint = context.options.hint || [];\n    var direction = context.options.hintDirection || 'bottom';\n    var hints = $.isArray(hint) ? hint : [hint];\n\n    this.events = {\n      'summernote.keyup': function (we, e) {\n        if (!e.isDefaultPrevented()) {\n          self.handleKeyup(e);\n        }\n      },\n      'summernote.keydown': function (we, e) {\n        self.handleKeydown(e);\n      },\n      'summernote.dialog.shown': function () {\n        self.hide();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return hints.length > 0;\n    };\n\n    this.initialize = function () {\n      this.lastWordRange = null;\n      this.$popover = ui.popover({\n        className: 'note-hint-popover',\n        hideArrow: true,\n        direction: ''\n      }).render().appendTo('body');\n\n      this.$popover.hide();\n\n      this.$content = this.$popover.find('.popover-content');\n\n      this.$content.on('click', '.note-hint-item', function () {\n        self.$content.find('.active').removeClass('active');\n        $(this).addClass('active');\n        self.replace();\n      });\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.selectItem = function ($item) {\n      this.$content.find('.active').removeClass('active');\n      $item.addClass('active');\n\n      this.$content[0].scrollTop = $item[0].offsetTop - (this.$content.innerHeight() / 2);\n    };\n\n    this.moveDown = function () {\n      var $current = this.$content.find('.note-hint-item.active');\n      var $next = $current.next();\n\n      if ($next.length) {\n        this.selectItem($next);\n      } else {\n        var $nextGroup = $current.parent().next();\n\n        if (!$nextGroup.length) {\n          $nextGroup = this.$content.find('.note-hint-group').first();\n        }\n\n        this.selectItem($nextGroup.find('.note-hint-item').first());\n      }\n    };\n\n    this.moveUp = function () {\n      var $current = this.$content.find('.note-hint-item.active');\n      var $prev = $current.prev();\n\n      if ($prev.length) {\n        this.selectItem($prev);\n      } else {\n        var $prevGroup = $current.parent().prev();\n\n        if (!$prevGroup.length) {\n          $prevGroup = this.$content.find('.note-hint-group').last();\n        }\n\n        this.selectItem($prevGroup.find('.note-hint-item').last());\n      }\n    };\n\n    this.replace = function () {\n      var $item = this.$content.find('.note-hint-item.active');\n\n      if ($item.length) {\n        var node = this.nodeFromItem($item);\n        this.lastWordRange.insertNode(node);\n        range.createFromNode(node).collapse().select();\n\n        this.lastWordRange = null;\n        this.hide();\n        context.invoke('editor.focus');\n      }\n\n    };\n\n    this.nodeFromItem = function ($item) {\n      var hint = hints[$item.data('index')];\n      var item = $item.data('item');\n      var node = hint.content ? hint.content(item) : item;\n      if (typeof node === 'string') {\n        node = dom.createText(node);\n      }\n      return node;\n    };\n\n    this.createItemTemplates = function (hintIdx, items) {\n      var hint = hints[hintIdx];\n      return items.map(function (item, idx) {\n        var $item = $('<div class=\"note-hint-item\"/>');\n        $item.append(hint.template ? hint.template(item) : item + '');\n        $item.data({\n          'index': hintIdx,\n          'item': item\n        });\n\n        if (hintIdx === 0 && idx === 0) {\n          $item.addClass('active');\n        }\n        return $item;\n      });\n    };\n\n    this.handleKeydown = function (e) {\n      if (!this.$popover.is(':visible')) {\n        return;\n      }\n\n      if (e.keyCode === key.code.ENTER) {\n        e.preventDefault();\n        this.replace();\n      } else if (e.keyCode === key.code.UP) {\n        e.preventDefault();\n        this.moveUp();\n      } else if (e.keyCode === key.code.DOWN) {\n        e.preventDefault();\n        this.moveDown();\n      }\n    };\n\n    this.searchKeyword = function (index, keyword, callback) {\n      var hint = hints[index];\n      if (hint && hint.match.test(keyword) && hint.search) {\n        var matches = hint.match.exec(keyword);\n        hint.search(matches[1], callback);\n      } else {\n        callback();\n      }\n    };\n\n    this.createGroup = function (idx, keyword) {\n      var $group = $('<div class=\"note-hint-group note-hint-group-' + idx + '\"/>');\n      this.searchKeyword(idx, keyword, function (items) {\n        items = items || [];\n        if (items.length) {\n          $group.html(self.createItemTemplates(idx, items));\n          self.show();\n        }\n      });\n\n      return $group;\n    };\n\n    this.handleKeyup = function (e) {\n      if (list.contains([key.code.ENTER, key.code.UP, key.code.DOWN], e.keyCode)) {\n        if (e.keyCode === key.code.ENTER) {\n          if (this.$popover.is(':visible')) {\n            return;\n          }\n        }\n      } else {\n        var wordRange = context.invoke('editor.createRange').getWordRange();\n        var keyword = wordRange.toString();\n        if (hints.length && keyword) {\n          this.$content.empty();\n\n          var bnd = func.rect2bnd(list.last(wordRange.getClientRects()));\n          if (bnd) {\n\n            this.$popover.hide();\n\n            this.lastWordRange = wordRange;\n\n            hints.forEach(function (hint, idx) {\n              if (hint.match.test(keyword)) {\n                self.createGroup(idx, keyword).appendTo(self.$content);\n              }\n            });\n\n            // set position for popover after group is created\n            if (direction === 'top') {\n              this.$popover.css({\n                left: bnd.left,\n                top: bnd.top - this.$popover.outerHeight() - POPOVER_DIST\n              });\n            } else {\n              this.$popover.css({\n                left: bnd.left,\n                top: bnd.top + bnd.height + POPOVER_DIST\n              });\n            }\n\n          }\n        } else {\n          this.hide();\n        }\n      }\n    };\n\n    this.show = function () {\n      this.$popover.show();\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n\n  $.summernote = $.extend($.summernote, {\n    version: '0.8.1',\n    ui: ui,\n\n    plugins: {},\n\n    options: {\n      modules: {\n        'editor': Editor,\n        'clipboard': Clipboard,\n        'dropzone': Dropzone,\n        'codeview': Codeview,\n        'statusbar': Statusbar,\n        'fullscreen': Fullscreen,\n        'handle': Handle,\n        // FIXME: HintPopover must be front of autolink\n        //  - Script error about range when Enter key is pressed on hint popover\n        'hintPopover': HintPopover,\n        'autoLink': AutoLink,\n        'autoSync': AutoSync,\n        'placeholder': Placeholder,\n        'buttons': Buttons,\n        'toolbar': Toolbar,\n        'linkDialog': LinkDialog,\n        'linkPopover': LinkPopover,\n        'imageDialog': ImageDialog,\n        'imagePopover': ImagePopover,\n        'videoDialog': VideoDialog,\n        'helpDialog': HelpDialog,\n        'airPopover': AirPopover\n      },\n\n      buttons: {},\n      \n      lang: 'en-US',\n\n      // toolbar\n      toolbar: [\n        ['style', ['style']],\n        ['font', ['bold', 'underline', 'clear']],\n        ['fontname', ['fontname']],\n        ['color', ['color']],\n        ['para', ['ul', 'ol', 'paragraph']],\n        ['table', ['table']],\n        ['insert', ['link', 'picture', 'video']],\n        ['view', ['fullscreen', 'codeview', 'help']]\n      ],\n\n      // popover\n      popover: {\n        image: [\n          ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],\n          ['float', ['floatLeft', 'floatRight', 'floatNone']],\n          ['remove', ['removeMedia']]\n        ],\n        link: [\n          ['link', ['linkDialogShow', 'unlink']]\n        ],\n        air: [\n          ['color', ['color']],\n          ['font', ['bold', 'underline', 'clear']],\n          ['para', ['ul', 'paragraph']],\n          ['table', ['table']],\n          ['insert', ['link', 'picture']]\n        ]\n      },\n\n      // air mode: inline editor\n      airMode: false,\n\n      width: null,\n      height: null,\n\n      focus: false,\n      tabSize: 4,\n      styleWithSpan: true,\n      shortcuts: true,\n      textareaAutoSync: true,\n      direction: null,\n\n      styleTags: ['p', 'blockquote', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\n\n      fontNames: [\n        'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New',\n        'Helvetica Neue', 'Helvetica', 'Impact', 'Lucida Grande',\n        'Tahoma', 'Times New Roman', 'Verdana'\n      ],\n\n      fontSizes: ['8', '9', '10', '11', '12', '14', '18', '24', '36'],\n\n      // pallete colors(n x n)\n      colors: [\n        ['#000000', '#424242', '#636363', '#9C9C94', '#CEC6CE', '#EFEFEF', '#F7F7F7', '#FFFFFF'],\n        ['#FF0000', '#FF9C00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#9C00FF', '#FF00FF'],\n        ['#F7C6CE', '#FFE7CE', '#FFEFC6', '#D6EFD6', '#CEDEE7', '#CEE7F7', '#D6D6E7', '#E7D6DE'],\n        ['#E79C9C', '#FFC69C', '#FFE79C', '#B5D6A5', '#A5C6CE', '#9CC6EF', '#B5A5D6', '#D6A5BD'],\n        ['#E76363', '#F7AD6B', '#FFD663', '#94BD7B', '#73A5AD', '#6BADDE', '#8C7BC6', '#C67BA5'],\n        ['#CE0000', '#E79439', '#EFC631', '#6BA54A', '#4A7B8C', '#3984C6', '#634AA5', '#A54A7B'],\n        ['#9C0000', '#B56308', '#BD9400', '#397B21', '#104A5A', '#085294', '#311873', '#731842'],\n        ['#630000', '#7B3900', '#846300', '#295218', '#083139', '#003163', '#21104A', '#4A1031']\n      ],\n\n      lineHeights: ['1.0', '1.2', '1.4', '1.5', '1.6', '1.8', '2.0', '3.0'],\n\n      tableClassName: 'table table-bordered',\n\n      insertTableMaxSize: {\n        col: 10,\n        row: 10\n      },\n\n      dialogsInBody: false,\n      dialogsFade: false,\n\n      maximumImageFileSize: null,\n\n      callbacks: {\n        onInit: null,\n        onFocus: null,\n        onBlur: null,\n        onEnter: null,\n        onKeyup: null,\n        onKeydown: null,\n        onSubmit: null,\n        onImageUpload: null,\n        onImageUploadError: null\n      },\n\n      codemirror: {\n        mode: 'text/html',\n        htmlMode: true,\n        lineNumbers: true\n      },\n\n      keyMap: {\n        pc: {\n          'ENTER': 'insertParagraph',\n          'CTRL+Z': 'undo',\n          'CTRL+Y': 'redo',\n          'TAB': 'tab',\n          'SHIFT+TAB': 'untab',\n          'CTRL+B': 'bold',\n          'CTRL+I': 'italic',\n          'CTRL+U': 'underline',\n          'CTRL+SHIFT+S': 'strikethrough',\n          'CTRL+BACKSLASH': 'removeFormat',\n          'CTRL+SHIFT+L': 'justifyLeft',\n          'CTRL+SHIFT+E': 'justifyCenter',\n          'CTRL+SHIFT+R': 'justifyRight',\n          'CTRL+SHIFT+J': 'justifyFull',\n          'CTRL+SHIFT+NUM7': 'insertUnorderedList',\n          'CTRL+SHIFT+NUM8': 'insertOrderedList',\n          'CTRL+LEFTBRACKET': 'outdent',\n          'CTRL+RIGHTBRACKET': 'indent',\n          'CTRL+NUM0': 'formatPara',\n          'CTRL+NUM1': 'formatH1',\n          'CTRL+NUM2': 'formatH2',\n          'CTRL+NUM3': 'formatH3',\n          'CTRL+NUM4': 'formatH4',\n          'CTRL+NUM5': 'formatH5',\n          'CTRL+NUM6': 'formatH6',\n          'CTRL+ENTER': 'insertHorizontalRule',\n          'CTRL+K': 'linkDialog.show'\n        },\n\n        mac: {\n          'ENTER': 'insertParagraph',\n          'CMD+Z': 'undo',\n          'CMD+SHIFT+Z': 'redo',\n          'TAB': 'tab',\n          'SHIFT+TAB': 'untab',\n          'CMD+B': 'bold',\n          'CMD+I': 'italic',\n          'CMD+U': 'underline',\n          'CMD+SHIFT+S': 'strikethrough',\n          'CMD+BACKSLASH': 'removeFormat',\n          'CMD+SHIFT+L': 'justifyLeft',\n          'CMD+SHIFT+E': 'justifyCenter',\n          'CMD+SHIFT+R': 'justifyRight',\n          'CMD+SHIFT+J': 'justifyFull',\n          'CMD+SHIFT+NUM7': 'insertUnorderedList',\n          'CMD+SHIFT+NUM8': 'insertOrderedList',\n          'CMD+LEFTBRACKET': 'outdent',\n          'CMD+RIGHTBRACKET': 'indent',\n          'CMD+NUM0': 'formatPara',\n          'CMD+NUM1': 'formatH1',\n          'CMD+NUM2': 'formatH2',\n          'CMD+NUM3': 'formatH3',\n          'CMD+NUM4': 'formatH4',\n          'CMD+NUM5': 'formatH5',\n          'CMD+NUM6': 'formatH6',\n          'CMD+ENTER': 'insertHorizontalRule',\n          'CMD+K': 'linkDialog.show'\n        }\n      },\n      icons: {\n        'align': 'note-icon-align',\n        'alignCenter': 'note-icon-align-center',\n        'alignJustify': 'note-icon-align-justify',\n        'alignLeft': 'note-icon-align-left',\n        'alignRight': 'note-icon-align-right',\n        'indent': 'note-icon-align-indent',\n        'outdent': 'note-icon-align-outdent',\n        'arrowsAlt': 'note-icon-arrows-alt',\n        'bold': 'note-icon-bold',\n        'caret': 'note-icon-caret',\n        'circle': 'note-icon-circle',\n        'close': 'note-icon-close',\n        'code': 'note-icon-code',\n        'eraser': 'note-icon-eraser',\n        'font': 'note-icon-font',\n        'frame': 'note-icon-frame',\n        'italic': 'note-icon-italic',\n        'link': 'note-icon-link',\n        'unlink': 'note-icon-chain-broken',\n        'magic': 'note-icon-magic',\n        'menuCheck': 'note-icon-check',\n        'minus': 'note-icon-minus',\n        'orderedlist': 'note-icon-orderedlist',\n        'pencil': 'note-icon-pencil',\n        'picture': 'note-icon-picture',\n        'question': 'note-icon-question',\n        'redo': 'note-icon-redo',\n        'square': 'note-icon-square',\n        'strikethrough': 'note-icon-strikethrough',\n        'subscript': 'note-icon-subscript',\n        'superscript': 'note-icon-superscript',\n        'table': 'note-icon-table',\n        'textHeight': 'note-icon-text-height',\n        'trash': 'note-icon-trash',\n        'underline': 'note-icon-underline',\n        'undo': 'note-icon-undo',\n        'unorderedlist': 'note-icon-unorderedlist',\n        'video': 'note-icon-video'\n      }\n    }\n  });\n\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/summernote-webpack/dist/summernote.js\n// module id = 179\n// module chunks = 3","/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/amd-options.js\n// module id = 180\n// module chunks = 3"],"sourceRoot":""}